
### Полезности
- [Руководство](https://metanit.com/python/)

### Команды

Работы с виртуальным окружением:
- `python -m venv myenv` - создание виртуального окружения в текущей директории. myenv - название окружения и папки, в которой это окружение будет храниться
- `myenv\Scripts\activate` - активация окружения (для windows)
- `deactivate` - деактивация окружения (возврат к глобальному окружению)
- `rm -rf myenv` - удаление виртуального окружения (просто удаление папки)
Команды pip:
- `pip install numpy` - установка библиотеки (например numpy)
- `pip install -r requirements.txt` - установка всех необходимых библиотек
- `pip freeze > requirements.txt` - генерация файла текущих зависимостей
- `pip install pip-autoremove` - удаление неиспользуемых зависимостей
- `pip-autoremove -r requirements.txt -y`

### Окружение

**Виртуальное окружение** — это изолированная среда для работы с Python. Нужно, чтобы устанавливаемые зависимости влияли только на данный проект и не портили глобальное окружение. Содержит:
- Интерпретатор (программа, которая выполняет Python-код) или ссылку на него
- Отдельные установленные пакеты (`site-packages/`)
- Настройки путей (`PATH`, `PYTHONPATH`)

##### Варианты запуска Python
1. При вводе `python` или `python3` в терминале система ищет исполняемый файл в переменной `PATH`. Порядок поиска такой:
	1. Активированные виртуальные окружения (если есть)
	2. Пути, указанные в `PATH` (например, `/usr/bin/python3` в Linux или `C:\Python39\` в Windows)
2. Указание явного пути
	- Можно запустить конкретную версию: `C:\Python310\python.exe`

##### Как определяется активное окружение?
Активация меняет переменную `PATH`, подставляя путь к локальному интерпретатору (меняется только для текущего окна терминала. Если закрыть консоль — изменения пропадут). После активации:
- `where python` покажет путь к окружению
- `sys.executable` в Python выведет текущий интерпретатор

##### Переменные окружения
Python учитывает переменные, которые влияют на его работу:
- **`PYTHONPATH`** — добавляет каталоги в `sys.path` (где Python ищет модули)    
- **`VIRTUAL_ENV`** — указывает на активное виртуальное окружение

##### Некоторые библиотеки
- `NumPy` - для работы с массивами, матрицами и векторами, для линала, преобразования матриц и так далее
- `SciPy` - это расширение `NumPy` (может решать СЛАУ)
- `Matplotlib` - для визуализации матриц

### Интересные вопросы

#### Как передаются аргументы в функцию?

Аргументы всегда передаются в функцию по ссылке на объект, но поведение зависит от типа объекта. 

Объекты бывают:
1. **Неизменяемые** (при присвоении нового значения, объект пересоздаётся)
	- Числа (`int`, `float`)
	- Логические значения (`bool`)
	- Строки (`str`)
	- Кортежи (`tuple`)
	- Замороженные множества (`frozenset`)
2. **Изменяемые**
	- Списки (`list`)
	- Множества (`set`)
	- Словари (`dict`)
	- Пользовательские объекты (экземпляры классов)

#### Как переопределяются операторы в Python?

В Python переопределение операторов (например, `[]`, `>`, `+`) осуществляется с помощью **магических методов** (или dunder methods, от "double underscore"). Например:
- `__getitem__` — для оператора `[]`
- `__setitem__` — для присваивания через `[]`
- `__gt__` — для оператора `>`
- `__and__` — для оператора `&`

### Типы данных

#### Особенности
- Python — это высокоуровневый язык с динамической типизацией
- Все переменные в Python являются ссылками на объекты, которые хранятся в куче
- Все типы данных (классы) организованы в иерархию. Базовым классом для всех объектов является `object`
- В Python стек используется только для управления вызовами функций (хранение локальных переменных и адресов возврата). Однако сами данные (объекты) всегда хранятся в куче

#### Оптимизации
- Интернирование: Python кэширует небольшие целые числа и короткие строки, чтобы избежать создания дубликатов объектов
- Неизменяемость: Базовые типы, такие как `int`, `float`, `str`, являются неизменяемыми. Это позволяет Python эффективно управлять памятью, так как объекты этих типов не могут быть изменены после создания
- Мелкие объекты: Python использует специальные механизмы для управления памятью мелких объектов, чтобы минимизировать накладные расходы на выделение и освобождение памяти