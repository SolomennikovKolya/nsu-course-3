
### Полезности
- [Руководство](https://metanit.com/python/)

### Команды

Работы с виртуальным окружением:
- `python -m venv myenv` - создание виртуального окружения в текущей директории. myenv - название окружения и папки, в которой это окружение будет храниться
- `myenv\Scripts\activate` - активация окружения (для windows)
- `deactivate` - деактивация окружения (возврат к глобальному окружению)
- `rm -rf myenv` - удаление виртуального окружения (просто удаление папки)
Команды pip:
- `pip install numpy` - установка библиотеки (например numpy)
- `pip install -r requirements.txt` - установка всех необходимых библиотек
- `pip freeze > requirements.txt` - генерация файла текущих зависимостей
- `pip install pip-autoremove` - удаление неиспользуемых зависимостей
- `pip-autoremove -r requirements.txt -y`

### Окружение

**Виртуальное окружение** — это изолированная среда для работы с Python. Нужно, чтобы устанавливаемые зависимости влияли только на данный проект и не портили глобальное окружение. Содержит:
- Интерпретатор (программа, которая выполняет Python-код) или ссылку на него
- Отдельные установленные пакеты (`site-packages/`)
- Настройки путей (`PATH`, `PYTHONPATH`)

##### Варианты запуска Python
1. При вводе `python` или `python3` в терминале система ищет исполняемый файл в переменной `PATH`. Порядок поиска такой:
	1. Активированные виртуальные окружения (если есть)
	2. Пути, указанные в `PATH` (например, `/usr/bin/python3` в Linux или `C:\Python39\` в Windows)
2. Указание явного пути
	- Можно запустить конкретную версию: `C:\Python310\python.exe`

##### Как определяется активное окружение?
Активация меняет переменную `PATH`, подставляя путь к локальному интерпретатору (меняется только для текущего окна терминала. Если закрыть консоль — изменения пропадут). После активации:
- `where python` покажет путь к окружению
- `sys.executable` в Python выведет текущий интерпретатор

##### Переменные окружения
Python учитывает переменные, которые влияют на его работу:
- **`PYTHONPATH`** — добавляет каталоги в `sys.path` (где Python ищет модули)    
- **`VIRTUAL_ENV`** — указывает на активное виртуальное окружение

##### Некоторые библиотеки
- `NumPy` - для работы с массивами, матрицами и векторами, для линала, преобразования матриц и так далее
- `SciPy` - это расширение `NumPy` (может решать СЛАУ)
- `Matplotlib` - для визуализации матриц

### Модульность

#### Определения
- **Модуль** - это обычный `.py` файл, который можно импортировать (например `utils.py`)
- `__init__.py` — это специальный файл, который делает папку настоящим Python-модулем
- **Пакет** - это папка, которая содержит **`__init__.py`** файл и (обычно) другие модули или подпакеты. Пакет можно импортировать как модуль
- `__pycache__` — это служебная папка, которую Python создаёт, чтобы хранить скомпилированные версии `.py` файлов — то есть `.pyc` файлы. Эти `.pyc` файлы содержат сериализованное байткод-представление Python-кода. Позволяют ускорить запуск программы, потому что Python не нужно каждый раз заново интерпретировать исходный `.py` файл

#### Как Python понимает, откуда импортировать?
- Python ищет модули по путям, которые лежат в переменной `sys.path`
- Когда ты запускаешь скрипт, Python:
	1. Добавляет папку текущего файла в `sys.path` (он считает, что это корень проекта)
	2. Ищет модули/пакеты в этой папке и выше
	3. Идёт по списку путей в `sys.path`
- То есть Python ищет файлы относительно корня проекта (директории с файлом, который сейчас запускается)
- Нельзя писать что-то типа `from ..db import actions`, если ты не внутри явного пакета с вложенными модулями

#### Что происходит при импорте функции из файла в Python
1. При первом импорте:
	- Весь файл (модуль) выполняется полностью сверху вниз 
	- Все глобальные переменные, функции и классы в модуле инициализируются
	- Результат импорта кешируется в `sys.modules` (повторный импорт не вызывает выполнение кода снова)
2. При повторном импорте:
	- Python не выполняет код модуля заново, а использует кешированную версию из первого импорта
	- Если вы явно перезагрузите модуль (например, через `importlib.reload()`), код выполнится снова

### Интересные вопросы

#### Как передаются аргументы в функцию?

Аргументы всегда передаются в функцию по ссылке на объект, но поведение зависит от типа объекта. 

Объекты бывают:
1. **Неизменяемые** (при присвоении нового значения, объект пересоздаётся)
	- Числа (`int`, `float`)
	- Логические значения (`bool`)
	- Строки (`str`)
	- Кортежи (`tuple`)
	- Замороженные множества (`frozenset`)
2. **Изменяемые**
	- Списки (`list`)
	- Множества (`set`)
	- Словари (`dict`)
	- Пользовательские объекты (экземпляры классов)

#### Как переопределяются операторы в Python?

В Python переопределение операторов (например, `[]`, `>`, `+`) осуществляется с помощью **магических методов** (или dunder methods, от "double underscore"). Например:
- `__getitem__` — для оператора `[]`
- `__setitem__` — для присваивания через `[]`
- `__gt__` — для оператора `>`
- `__and__` — для оператора `&`

### Типы данных

#### Особенности
- Python — это высокоуровневый язык с динамической типизацией
- Все переменные в Python являются ссылками на объекты, которые хранятся в куче
- Все типы данных (классы) организованы в иерархию. Базовым классом для всех объектов является `object`
- В Python стек используется только для управления вызовами функций (хранение локальных переменных и адресов возврата). Однако сами данные (объекты) всегда хранятся в куче

#### Оптимизации
- Интернирование: Python кэширует небольшие целые числа и короткие строки, чтобы избежать создания дубликатов объектов
- Неизменяемость: Базовые типы, такие как `int`, `float`, `str`, являются неизменяемыми. Это позволяет Python эффективно управлять памятью, так как объекты этих типов не могут быть изменены после создания
- Мелкие объекты: Python использует специальные механизмы для управления памятью мелких объектов, чтобы минимизировать накладные расходы на выделение и освобождение памяти

### Flask

#### Контекст

##### Какие бывают контексты во Flask?
1. *Контекст приложения (Application Context)*  
    Содержит:
    - `current_app` — ссылка на объект `Flask`
    - `g` — глобальное хранилище для запроса (один на запрос)
2. *Контекст запроса (Request Context)*  
    Содержит:
    - `request` — текущий HTTP-запрос
    - `session` — данные пользовательской сессии

##### Особенности
- Но в момент времени на потоке Flask может быть активен только один контекст запроса и один контекст приложения
- Контекст запроса всегда создаёт контекст приложения, если тот ещё не активен
- Flask — это веб-сервер. Он обрабатывает много запросов одновременно, каждый в своём потоке (или async-контексте). Чтобы разные запросы не мешали друг другу, Flask использует `thread-local` (способ хранения данных отдельно для каждого потока) для хранения "глобальных" переменных
- "прокси"-объекты - это обёртки, которые выглядят как обычные переменные, но на самом деле делегируют доступ к значению, хранящемуся в thread-local. Например, когда ты обращаешься к `current_app`, он вызывает `lambda`, чтобы достать актуальное значение из локального стека текущего потока. Условно: `current_app -> get_app_for_this_thread()`. Это даёт удобство "глобальных" переменных, но без потерь потокобезопасности
- Каждый запрос обрабатывается в своём потоке

##### Почему нужен именно стек
- Возможны вложенные контексты (`with app.app_context():` внутри запроса или теста)
- Flask должен знать, какой контекст сейчас активен — он просто смотрит на `stack.top`
- Когда `pop()` вызывается, всё возвращается к предыдущему состоянию

### Корутины

Корутина — это специальная функция, которая:
- объявляется с `async def`
- может приостанавливать своё выполнение с помощью `await`
- возвращает объект-корутину, а не результат

Пример:
```python
import asyncio

async def say_hello():
    print("Hello")
    await asyncio.sleep(1)
    print("World")

```

Как они работают:
- `async def` создает корутину (не запускается сразу)
- `await` — оператор, который приостанавливает выполнение, пока не завершится другая корутина
- всё это выполняется в однопоточном event loop-е, управляемом `asyncio`

### Генераторы

**Генераторы** — это функции или объекты, которые «лениво» возвращают последовательность значений, по одному за раз, при каждом вызове `next()`. Они позволяют экономить память и эффективно обрабатывать большие объёмы данных

Генераторы — это функции, которые используют ключевое слово `yield` вместо `return`. Когда вызывается `yield`, функция приостанавливается и сохраняет своё состояние. При следующем `next()` выполнение продолжается с того места, где остановилось

|Обычные функции|Генератор-функции|
|---|---|
|`return` завершает функцию|`yield` приостанавливает|
|Возвращают результат сразу|Возвращают итератор|
|Занимают память под весь результат|Выдают по одному элементу|

Пример: генератор вместо списка
```python
# список: сразу в памяти
squares = [x*x for x in range(1_000_000)]

# генератор: ленивая генерация
def gen_squares():
    for x in range(1_000_000):
        yield x * x

squares_gen = gen_squares()

```

