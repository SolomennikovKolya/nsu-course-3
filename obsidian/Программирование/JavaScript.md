
### JavaScript

**JavaScript (JS)** — это высокоуровневый, интерпретируемый язык программирования, который делает веб-страницы интерактивными. Без JS страницы были бы статичными

#### Основные возможности
1. Обновление контента без перезагрузки страницы
2. Работа с DOM (Document Object Model). JS может:
	- Находить элементы на странице (`getElementById`, `querySelector`)
	- Менять их стили, атрибуты, содержимое
	- Добавлять или удалять элементы
3. Отправка запросов (например библиотека Axios)
4. Хранение данных на клиенте
	- LocalStorage/SessionStorage — сохранение данных в браузере
	- Cookies
5. Обработка событий (действия пользователя)

#### Как браузер обрабатывает JavaScript

##### Загрузка JavaScript в браузере

JS может быть подключён к HTML двумя способами:
- Встроенный JS (inline) — блок `<script>` в HTML
- Внешний JS — загрузка из файла `<script src="script.js"></script>`. Чтобы получить файл браузер делает HTTP-запрос к серверу

##### Когда браузер исполняет JS?

Зависит от способа подключения:
1. *Синхронный:
	- `<script src="script.js"></script>`
	- Что происходит:
		1. Браузер парсит HTML до тега `<script>`
		2. Приостанавливает парсинг HTML, загружает и выполняет JS
		3. После выполнения продолжает парсинг HTML
	- Минус: Если файл `script.js` большой или загружается медленно — страница «зависает»
2. *Асинхронный*:
	- `<script async src="script.js"></script>`
	- Что происходит:
		1. Браузер параллельно парсит HTML и загружает JS
		2. Как только JS загружен — немедленно выполняется (даже если HTML ещё не распарсен)
	- Минус: Порядок выполнения не гарантирован. Если есть несколько `async`-скриптов, они могут выполниться в произвольном порядке
3. *Отложенный*:
	- `<script defer src="script.js"></script>`
	- Что происходит:
		1. Браузер параллельно парсит HTML и загружает JS
		2. JS выполняется только после полного парсинга HTML, перед событием `DOMContentLoaded`
	- Плюс: Порядок скриптов сохраняется. Идеально для зависимых библиотек (например, jQuery + плагины)

##### Этапы выполнения JS

После загрузки браузер проходит несколько шагов:
1. Парсинг кода
	- Движок JS (V8 в Chrome, SpiderMonkey в Firefox) преобразует текст скрипта в *Abstract Syntax Tree (AST)*
	- Проверяет синтаксис (если ошибка — выполнение прерывается
2. Компиляция в байт-код
	- Современные движки (V8) используют *JIT-компиляцию* (Just-In-Time):
	    - «Горячий» код (часто выполняемый) компилируется в оптимизированный машинный код
	    - Остальной код интерпретируется построчно
3. Исполнение кода
	- Код выполняется в *Call Stack* (стеке вызовов)
	- Для асинхронных операций (например, `setTimeout`, `fetch`) используется *Event Loop*

![[Pasted image 20250330104748.png]]

### Node.js

**Node.js** (нода) — это среда выполнения JavaScript на стороне сервера (до Node.js JavaScript работал только в браузере). Теперь можно писать и фронтенд (React, Vue), и бэкенд на одном языке. Также Node.js удобен для разработки

Включает в себя:
1. Сам Node.js (исполняемая среда JavaScript)
	- Движок V8 (от Google) — компилирует и выполняет JS-код
	- Стандартные модули (fs, http, path и др.) для работы с файлами, сетью, ОС
	- Цикл событий (Event Loop) — основа асинхронного ввода-вывода
2. NPM (Node Package Manager)
	- Менеджер пакетов для загрузки библиотек (например, express, react)
	- Локальное хранилище node_modules — папка с зависимостями проекта
	- Глобальные пакеты (если установлены через `npm install -g`)
3. Дополнительные инструменты
	- NPX — утилита для запуска пакетов без глобальной установки (например, npx create-react-app)
	- Corepack (в новых версиях) — менеджер для альтернативных пакетных менеджеров (Yarn, pnpm)

### React

**React** — это популярная JavaScript-библиотека для создания пользовательских интерфейсов. Она используется для построения динамических, быстрых и интерактивных веб-приложений

#### Основные концепции
1. *Компонентный подход*: UI разбивается на переиспользуемые компоненты (как Lego-блоки)
2. *Virtual DOM*: React создает виртуальную копию DOM и обновляет только изменившиеся части реального DOM, что ускоряет работу приложения
3. *Однонаправленный поток данных*: Данные передаются от родительских компонентов к дочерним через props (свойства)
4. *Хуки (Hooks)*: Позволяют использовать состояние и другие возможности React в функциональных компонентах

#### Как работает React
1. *Инициализация*:
	- `npx create-react-app my-app` - Создание проекта
	- `cd my-app`
	- `npm start` - Запуск dev-сервера
2. *Рендеринг*: React встраивает компоненты в HTML через корневой элемент (обычно `<div id="root">`)
3. *Обновление UI*: При изменении состояния (`state` или `props`) React пересчитывает Virtual DOM и обновляет только нужные части интерфейса

#### Зачем нужен React, если есть чистый JavaScript + CSS

React (и другие фреймворки) решают проблемы, которые сложно или трудоёмко реализовать на чистом JS:

1. *Сложность управления DOM*
    - В больших приложениях ручное обновление DOM (через `document.getElementById()`, `innerHTML`) становится запутанным и медленным
    - React автоматически обновляет только нужные части интерфейса через Virtual DOM
2. *Переиспользование кода*
    - Компоненты React можно использовать многократно (например, кнопки, карточки товаров)
    - В чистом JS приходится копировать HTML/CSS/JS или использовать шаблонизаторы
3. *Работа с состоянием (state)*
    - React предоставляет удобные инструменты (хуки `useState`, `useEffect`), чтобы синхронизировать данные и интерфейс
    - На чистом JS нужно вручную отслеживать изменения и обновлять UI
4. *Оптимизация производительности*
    - React минимизирует количество операций с DOM, что ускоряет рендеринг
    - В чистом JS оптимизация требует сложного кода (например, debounce/throttle для событий)
5. *Инструменты для масштабирования*
    - React-экосистема включает:
        - Роутинг (React Router)
        - Управление состоянием (Redux, MobX)
        - Готовые UI-библиотеки (Material-UI, Ant Design)

#### Сравнение React с другими фреймворками и библиотеками

| Название    | Тип        | Язык  | Плюсы                                                 | Минусы                                     | Когда выбирать?                                              |
| ----------- | ---------- | ----- | ----------------------------------------------------- | ------------------------------------------ | ------------------------------------------------------------ |
| **React**   | Библиотека | JS/TS | Гибкость, Virtual DOM, большое сообщество             | Нет встроенного роутинга/state-менеджмента | SPA, сложные интерфейсы, мобильная разработка (React Native) |
| **Vue**     | Фреймворк  | JS/TS | Простота, встроенный роутинг, двустороннее связывание | Меньше вакансий, чем у React               | Быстрый старт, небольшие проекты                             |
| **Angular** | Фреймворк  | TS    | Полный набор инструментов (MVC, DI, RxJS)             | Высокий порог входа, сложность             | Корпоративные приложения, долгосрочные проекты               |
| **Svelte**  | Компилятор | JS/TS | Нет Virtual DOM, высокая скорость                     | Молодая экосистема                         | Простые приложения, где важна производительность             |
| **SolidJS** | Библиотека | JS/TS | Реактивность как в Vue, но без Virtual DOM            | Мало готовых компонентов                   | Проекты с упором на скорость                                 |
| **Preact**  | Библиотека | JS    | Аналог React (всего 3 КБ), совместим с React API      | Ограниченная функциональность              | Мини-проекты, где важен размер бандла                        |
| **Next.js** | Фреймворк  | JS/TS | SSR/SSG для React, встроенный роутинг                 | Требует настройки                          | SEO-оптимизированные сайты, интернет-магазины                |
| **Nuxt.js** | Фреймворк  | JS/TS | SSR/SSG для Vue                                       | Меньше плагинов, чем у Next                | Vue-проекты с SSR                                            |
| **Remix**   | Фреймворк  | JS/TS | Упрощённая работа с данными (на основе React Router)  | Менее гибкий, чем Next                     | Веб-приложения с быстрой загрузкой                           |

![[Pasted image 20250330122127.png]]

#### Реактивность

**Реактивность** — это парадигма программирования, при которой интерфейс или данные автоматически обновляются при изменении их состояния. Другими словами, система "реагирует" на изменения и синхронизирует все зависимые части приложения без явных указаний разработчика

Типы реактивности:
1. *Push-модель* (Vue, MobX)
    - Система "толкает" изменения в зависимости при обновлении данных
2. *Pull-модель* (React)
    - Компонент "забирает" новые данные при перерисовке (через `useState`/`useEffect`)

#### Virtual DOM

**Virtual DOM (VDOM)** — это легковесная копия реального DOM, которую React использует для оптимизации обновлений интерфейса.

Вот почему он важен:
1. *Производительность*
    Прямое изменение реального DOM — медленная операция (из-за перерасчёта стилей, макета и перерисовки). VDOM позволяет минимизировать количество операций с реальным DOM
2. *Сравнение изменений (Diffing Algorithm)*  
    React сравнивает предыдущий и новый VDOM, чтобы найти минимальный набор изменений (а не перерисовывает весь DOM)
3. *Абстракция от браузерных особенностей*  
    VDOM работает одинаково во всех браузерах, что упрощает кроссплатформенную разработку

Прямые манипуляции с DOM приводят к:
- *Избыточным обновлениям*: Если 10 компонентов меняют DOM, браузер выполнит 10 перерасчётов макета
- *Замедлению*: Частые DOM-операции «подвешивают» интерфейс

С VDOM: React собирает все изменения в VDOM, затем применяет их одним пакетом (batch update)

### SPA

**SPA** (Single Page Application) — это веб-приложение, которое загружает одну HTML-страницу и динамически обновляет её содержимое без полной перезагрузки страницы

#### Принцип работы
- Первый раз загружается пустая оболочка (`index.html`) и JavaScript-приложение
- Дальше весь контент подгружается через AJAX или fetch/XHR, без перехода на новые страницы
- Навигация имитируется с помощью history API (`pushState`, `popState`)

##### Пояснение index.html
Когда пользователь заходит на SPA-сайт, сервер отдаёт единственный HTML-файл (обычно `index.html`). Это по сути "контейнер", а всё, что видит пользователь — отрисовывается через JavaScript. Файл выглядит очень просто — в нём почти нет контента:
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>My SPA</title>
</head>
<body>
  <div id="root"></div> <!-- вот сюда вставится интерфейс -->
  <script src="/main.js"></script> <!-- запуск JS-приложения -->
</body>
</html>

```

##### Пояснение JavaScript-приложения
Файл `main.js` (или `bundle.js`, `app.js`) — это скомпилированный JavaScript-код (например, React/Vue-код), который:
1. Запускается в браузере
2. Находит `#root` или другой контейнер в HTML
3. Программно создаёт всё содержимое страницы (кнопки, таблицы, меню и т.д.)
4. Управляет маршрутизацией и загрузкой данных

##### Пример "живого" процесса
1. Пользователь заходит на сайт `example.com`
2. Сервер отдаёт index.html
3. Браузер загружает скрипты (`main.js`, CSS и т.п.)
4. JS код создает интерфейс и вставляет его в `<div id="root">`
5. Пользователь кликает по разделам — страница не перезагружается, всё меняется через JS

##### Пример архитектуры SPA + React
```
my-spa/
├── public/
│   └── index.html
├── src/
│   ├── App.js
│   ├── Home.js
│   ├── About.js
│   └── index.js
├── package.json
```

##### AJAX
AJAX (Asynchronous JavaScript and XML) — это технология, позволяющая выполнять асинхронные запросы к серверу из браузера без перезагрузки страницы. Она используется, чтобы динамически загружать или отправлять данные — например, обновить список сообщений, отправить форму или получить информацию для выпадающего меню

##### History API
History API — это встроенный интерфейс в браузерах, позволяющий управлять историей переходов пользователя (вкладкой браузера) через JavaScript без перезагрузки страницы. Он часто используется в SPA, чтобы менять URL-адрес в адресной строке, имитируя переход между страницами, при этом фактически не перезагружая страницу. Основные методы History API:

| Метод                                     | Назначение                                    |
| ----------------------------------------- | --------------------------------------------- |
| `history.pushState(state, title, url)`    | Добавляет новую запись в историю и меняет URL |
| `history.replaceState(state, title, url)` | Заменяет текущую запись в истории             |
| `window.onpopstate`                       | Обработчик события при переходе назад/вперед  |

#### SEO

**SEO** (Search Engine Optimization) — это оптимизация сайта под поисковые системы, чтобы:
- сайт был лучше индексирован (Google, Яндекс и т.д.)
- выше ранжировался в результатах поиска
- привлекал больше органического трафика

Проблема SPA и SEO: Поисковым роботам сложно "увидеть" содержимое SPA, так как:
- контент подгружается динамически через JS
- бот может не выполнять JS вообще (или делать это ограниченно)

Решения:
1. SSR (Server-Side Rendering) — например, Next.js (React) или Nuxt (Vue) рендерят страницы на сервере
2. Prerendering / Static Site Generation (SSG) — рендерим всё заранее в HTML-файлы
3. Dynamic Rendering — сервер выдает обычную SPA людям, но статичный HTML ботам
4. Meta-теги и Open Graph — помогают соцсетям и поисковикам лучше отображать ссылку

### Vite

**Vite** — это современный инструмент сборки фронтенда, альтернатива Create React App (CRA), который работает намного быстрее за счёт использования ES-модулей и ускоренной разработки (dev server на Vite стартует практически мгновенно)

Что делает Vite:
- Быстрая сборка и запуск dev-сервера    
- Мгновенный HMR (обновление компонентов без перезагрузки)
- Поддержка React, Vue, Svelte и других фреймворков
- Возможность использовать TypeScript, SCSS, Tailwind и т.д.


