
### JavaScript

**JavaScript (JS)** — это высокоуровневый, интерпретируемый язык программирования, который делает веб-страницы интерактивными. Без JS страницы были бы статичными. [Очень годный учебник по JavaScript](https://learn.javascript.ru)

#### Основные возможности
1. Обновление контента без перезагрузки страницы
2. Работа с DOM (Document Object Model). JS может:
	- Находить элементы на странице (`getElementById`, `querySelector`)
	- Менять их стили, атрибуты, содержимое
	- Добавлять или удалять элементы
3. Отправка запросов (например библиотека Axios)
4. Хранение данных на клиенте
	- LocalStorage/SessionStorage — сохранение данных в браузере
	- Cookies
5. Обработка событий (действия пользователя)

#### Особенности
- Может выполняться в браузере (клиентская логика) и на сервере через Node.js
- Интерпретируемый, но поддерживает JIT компилироваться для ускорения
- Сильно динамически типизированный
- Поддерживает функции первого класса, замыкания, объекты, классы, async/await
- Используется с HTML/CSS для создания SPA, PWA, и обычных сайтов
- Всё в JS — объекты (как в Python)
- JS как и Java интерпретируется в байт код и выполняется движком (например, V8 в Chrome, SpiderMonkey в Firefox)
- Возможности JavaScript сильно зависят от окружения, в котором он работает. Например, Node.js поддерживает функции чтения/записи произвольных файлов, выполнения сетевых запросов и т.д.

#### Как выполняется JavaScript

##### Загрузка JavaScript в браузере
JS может быть подключён к HTML несколькими способами:
- Встроенный JS (inline) — блок `<script> ... </script>` в HTML
- Внешний JS — загрузка из файла `<script src="script.js"></script>`. Чтобы получить файл браузер делает HTTP-запрос к серверу

##### Атрибуты подключения скриптов
Они влияют на то, когда браузер будет исполняет JS
1. `<script src="script.js"></script>` - Синхронный (без атрибутов):
	- Браузер парсит HTML до тега `<script>`
	- Приостанавливает парсинг HTML, загружает и выполняет JS
	- После выполнения продолжает парсинг HTML
	- Минус: Если файл `script.js` большой или загружается медленно — страница «зависает»
2. `<script async src="script.js"></script>` - Асинхронный (async):
	- Браузер параллельно парсит HTML и загружает JS
	- Как только JS загружен — немедленно выполняется (даже если HTML ещё не распарсен)
	- Минус: Порядок выполнения не гарантирован. Если есть несколько async скриптов, они могут выполниться в произвольном порядке
3. `<script defer src="script.js"></script>` - Отложенный (defer):
	- Браузер параллельно парсит HTML и загружает JS
	- JS выполняется только после полного парсинга HTML, перед событием `DOMContentLoaded`
	- Плюс: Порядок скриптов сохраняется. Идеально для зависимых библиотек (например, jQuery + плагины)

##### Этапы выполнения JS
После загрузки движок выполняет несколько шагов:
1. Парсинг кода: Движок JS проверяет синтаксис (если ошибка — выполнение прерывается) и преобразует текст скрипта в AST (Abstract Syntax Tree)
2. Компиляция в байт-код (промежуточный формат, который быстро исполняется)
3. JIT-компиляция (Just-In-Time): Если код исполняется часто, движок оптимизирует его в машинный код (нативный код CPU)
4. Исполнение кода: Код выполняется в Call Stack (стеке вызовов). Для асинхронных операций (например, `setTimeout`, `fetch`) используется Event Loop

#### Языки над JavaScript
Некоторые языки, которые транспилируются (конвертируются) в JavaScript:
- [CoffeeScript](https://coffeescript.org/) добавляет «синтаксический сахар» для JavaScript. Он вводит более короткий синтаксис, который позволяет писать чистый и лаконичный код. Обычно такое нравится Ruby-программистам
- [TypeScript](https://www.typescriptlang.org/) концентрируется на добавлении «строгой типизации» для упрощения разработки и поддержки больших и сложных систем. Разработан Microsoft
- [Flow](https://flow.org/) тоже добавляет типизацию, но иначе. Разработан Facebook
- [Dart](https://www.dartlang.org/) стоит особняком, потому что имеет собственный движок, работающий вне браузера (например, в мобильных приложениях). Первоначально был предложен Google, как замена JavaScript, но на данный момент необходима его транспиляция для запуска так же, как для вышеперечисленных языков
- [Brython](https://brython.info/) транспилирует Python в JavaScript, что позволяет писать приложения на чистом Python без JavaScript

### Node.js

**Node.js** (нода) — это среда выполнения JavaScript на стороне сервера (до Node.js JavaScript работал только в браузере). Также с помощью неё можно писать и фронтенд (React, Vue), и бэкенд на одном языке. Node.js удобен для разработки

Включает в себя:
1. Сам Node.js (исполняемая среда JavaScript)
	- Движок V8 (от Google) — компилирует и выполняет JS-код
	- Стандартные модули (fs, http, path и др.) для работы с файлами, сетью, ОС
	- Цикл событий (Event Loop) — основа асинхронного ввода-вывода
2. NPM (Node Package Manager)
	- Менеджер пакетов для загрузки библиотек (например, express, react)
	- Локальное хранилище node_modules — папка с зависимостями проекта
	- Глобальные пакеты (если установлены через `npm install -g`)
3. Дополнительные инструменты
	- NPX — утилита для запуска пакетов без глобальной установки (например, npx create-react-app)
	- Corepack (в новых версиях) — менеджер для альтернативных пакетных менеджеров (Yarn, pnpm)

#### NPM

##### package.json

*package.json* - это описание frontend-проекта, которое используется `npm` или `yarn` для управления зависимостями, скриптами, настройками сборки и пр. Основные поля:

| Поле                | Описание                                                    |
| ------------------- | ----------------------------------------------------------- |
| `"name"`            | Название проекта                                            |
| `"version"`         | Версия                                                      |
| `"scripts"`         | Сценарии (команды), которые можно запускать через `npm run` |
| `"dependencies"`    | Пакеты, нужные в продакшене (React, axios и т.д.)           |
| `"devDependencies"` | Пакеты только для разработки (Vite, тесты, ESLint и т.д.)   |

Скрипты:
- `npm run dev` - Запускает Vite dev-сервер
- `npm run build` - Создаёт production-сборку в папке dist/
- `npm run preview`  - Запускает локальный сервер для предпросмотра билда

##### Команды
- `npm install`
	- Читает `package.json`, определяет зависимости проекта (например: `react`, `vite`)
	- Скачивает все указанные библиотеки и их зависимости с [npmjs.com](https://www.npmjs.com/)
	- Создаёт папку `node_modules/` и помещает туда все библиотеки
	- Создаёт/обновляет `package-lock.json`, чтобы зафиксировать точные версии установленных пакетов, чтобы гарантировать одинаковое окружение у всех разработчиков
- `npm install <название пакета>` - npm автоматически:
	- Скачивает пакеты
	- Добавляет их в `dependencies` секцию `package.json`
	- Обновляет `package-lock.json`
	- Сохраняет их в `node_modules/`

### React

**React** — это популярная JavaScript-библиотека для создания пользовательских интерфейсов. Она используется для построения динамических, быстрых и интерактивных веб-приложений

#### Основные концепции
1. *Компонентный подход*: UI разбивается на переиспользуемые компоненты (как Lego-блоки)
2. *Virtual DOM*: React создает виртуальную копию DOM и обновляет только изменившиеся части реального DOM, что ускоряет работу приложения
3. *Однонаправленный поток данных*: Данные передаются от родительских компонентов к дочерним через props (свойства)
4. *Хуки (Hooks)*: Позволяют использовать состояние и другие возможности React в функциональных компонентах

#### Как работает React
1. *Инициализация*:
	- `npx create-react-app my-app` - Создание проекта
	- `cd my-app`
	- `npm start` - Запуск dev-сервера
2. *Рендеринг*: React встраивает компоненты в HTML через корневой элемент (обычно `<div id="root">`)
3. *Обновление UI*: При изменении состояния (`state` или `props`) React пересчитывает Virtual DOM и обновляет только нужные части интерфейса

#### Зачем нужен React, если есть чистый JavaScript + CSS

React (и другие фреймворки) решают проблемы, которые сложно или трудоёмко реализовать на чистом JS:

1. *Сложность управления DOM*
    - В больших приложениях ручное обновление DOM (через `document.getElementById()`, `innerHTML`) становится запутанным и медленным
    - React автоматически обновляет только нужные части интерфейса через Virtual DOM
2. *Переиспользование кода*
    - Компоненты React можно использовать многократно (например, кнопки, карточки товаров)
    - В чистом JS приходится копировать HTML/CSS/JS или использовать шаблонизаторы
3. *Работа с состоянием (state)*
    - React предоставляет удобные инструменты (хуки `useState`, `useEffect`), чтобы синхронизировать данные и интерфейс
    - На чистом JS нужно вручную отслеживать изменения и обновлять UI
4. *Оптимизация производительности*
    - React минимизирует количество операций с DOM, что ускоряет рендеринг
    - В чистом JS оптимизация требует сложного кода (например, debounce/throttle для событий)
5. *Инструменты для масштабирования*
    - React-экосистема включает:
        - Роутинг (React Router)
        - Управление состоянием (Redux, MobX)
        - Готовые UI-библиотеки (Material-UI, Ant Design)

#### Сравнение React с другими фреймворками и библиотеками

| Название    | Тип        | Язык  | Плюсы                                                 | Минусы                                     | Когда выбирать?                                              |
| ----------- | ---------- | ----- | ----------------------------------------------------- | ------------------------------------------ | ------------------------------------------------------------ |
| **React**   | Библиотека | JS/TS | Гибкость, Virtual DOM, большое сообщество             | Нет встроенного роутинга/state-менеджмента | SPA, сложные интерфейсы, мобильная разработка (React Native) |
| **Vue**     | Фреймворк  | JS/TS | Простота, встроенный роутинг, двустороннее связывание | Меньше вакансий, чем у React               | Быстрый старт, небольшие проекты                             |
| **Angular** | Фреймворк  | TS    | Полный набор инструментов (MVC, DI, RxJS)             | Высокий порог входа, сложность             | Корпоративные приложения, долгосрочные проекты               |
| **Svelte**  | Компилятор | JS/TS | Нет Virtual DOM, высокая скорость                     | Молодая экосистема                         | Простые приложения, где важна производительность             |
| **SolidJS** | Библиотека | JS/TS | Реактивность как в Vue, но без Virtual DOM            | Мало готовых компонентов                   | Проекты с упором на скорость                                 |
| **Preact**  | Библиотека | JS    | Аналог React (всего 3 КБ), совместим с React API      | Ограниченная функциональность              | Мини-проекты, где важен размер бандла                        |
| **Next.js** | Фреймворк  | JS/TS | SSR/SSG для React, встроенный роутинг                 | Требует настройки                          | SEO-оптимизированные сайты, интернет-магазины                |
| **Nuxt.js** | Фреймворк  | JS/TS | SSR/SSG для Vue                                       | Меньше плагинов, чем у Next                | Vue-проекты с SSR                                            |
| **Remix**   | Фреймворк  | JS/TS | Упрощённая работа с данными (на основе React Router)  | Менее гибкий, чем Next                     | Веб-приложения с быстрой загрузкой                           |

![[Pasted image 20250330122127.png]]

#### Реактивность

**Реактивность** — это парадигма программирования, при которой интерфейс или данные автоматически обновляются при изменении их состояния. Другими словами, система "реагирует" на изменения и синхронизирует все зависимые части приложения без явных указаний разработчика

Типы реактивности:
1. *Push-модель* (Vue, MobX)
    - Система "толкает" изменения в зависимости при обновлении данных
2. *Pull-модель* (React)
    - Компонент "забирает" новые данные при перерисовке (через `useState`/`useEffect`)

#### Virtual DOM

**Virtual DOM (VDOM)** — это легковесная копия реального DOM, которую React использует для оптимизации обновлений интерфейса.

Вот почему он важен:
1. *Производительность*
    Прямое изменение реального DOM — медленная операция (из-за перерасчёта стилей, макета и перерисовки). VDOM позволяет минимизировать количество операций с реальным DOM
2. *Сравнение изменений (Diffing Algorithm)*  
    React сравнивает предыдущий и новый VDOM, чтобы найти минимальный набор изменений (а не перерисовывает весь DOM)
3. *Абстракция от браузерных особенностей*  
    VDOM работает одинаково во всех браузерах, что упрощает кроссплатформенную разработку

Прямые манипуляции с DOM приводят к:
- *Избыточным обновлениям*: Если 10 компонентов меняют DOM, браузер выполнит 10 перерасчётов макета
- *Замедлению*: Частые DOM-операции «подвешивают» интерфейс

С VDOM: React собирает все изменения в VDOM, затем применяет их одним пакетом (batch update)

### SPA

**SPA** (Single Page Application) — это веб-приложение, которое загружает одну HTML-страницу и динамически обновляет её содержимое без полной перезагрузки страницы

#### Принцип работы
- Первый раз загружается пустая оболочка (`index.html`) и JavaScript-приложение
- Дальше весь контент подгружается через AJAX или fetch/XHR, без перехода на новые страницы
- Навигация имитируется с помощью history API (`pushState`, `popState`)

##### Пояснение index.html
Когда пользователь заходит на SPA-сайт, сервер отдаёт единственный HTML-файл (обычно `index.html`). Это по сути "контейнер", а всё, что видит пользователь — отрисовывается через JavaScript. Файл выглядит очень просто — в нём почти нет контента:
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>My SPA</title>
</head>
<body>
  <div id="root"></div> <!-- вот сюда вставится интерфейс -->
  <script src="/main.js"></script> <!-- запуск JS-приложения -->
</body>
</html>

```

##### Пояснение JavaScript-приложения
Файл `main.js` (или `bundle.js`, `app.js`) — это скомпилированный JavaScript-код (например, React/Vue-код), который:
1. Запускается в браузере
2. Находит `#root` или другой контейнер в HTML
3. Программно создаёт всё содержимое страницы (кнопки, таблицы, меню и т.д.)
4. Управляет маршрутизацией и загрузкой данных

##### Пример "живого" процесса
1. Пользователь заходит на сайт `example.com`
2. Сервер отдаёт index.html
3. Браузер загружает скрипты (`main.js`, CSS и т.п.)
4. JS код создает интерфейс и вставляет его в `<div id="root">`
5. Пользователь кликает по разделам — страница не перезагружается, всё меняется через JS

##### Пример архитектуры SPA + React
```
my-spa/
├── public/
│   └── index.html
├── src/
│   ├── App.js
│   ├── Home.js
│   ├── About.js
│   └── index.js
├── package.json
```

##### AJAX
AJAX (Asynchronous JavaScript and XML) — это технология, позволяющая выполнять асинхронные запросы к серверу из браузера без перезагрузки страницы. Она используется, чтобы динамически загружать или отправлять данные — например, обновить список сообщений, отправить форму или получить информацию для выпадающего меню

##### History API
History API — это встроенный интерфейс в браузерах, позволяющий управлять историей переходов пользователя (вкладкой браузера) через JavaScript без перезагрузки страницы. Он часто используется в SPA, чтобы менять URL-адрес в адресной строке, имитируя переход между страницами, при этом фактически не перезагружая страницу. Основные методы History API:

| Метод                                     | Назначение                                    |
| ----------------------------------------- | --------------------------------------------- |
| `history.pushState(state, title, url)`    | Добавляет новую запись в историю и меняет URL |
| `history.replaceState(state, title, url)` | Заменяет текущую запись в истории             |
| `window.onpopstate`                       | Обработчик события при переходе назад/вперед  |

#### SEO

**SEO** (Search Engine Optimization) — это оптимизация сайта под поисковые системы, чтобы:
- сайт был лучше индексирован (Google, Яндекс и т.д.)
- выше ранжировался в результатах поиска
- привлекал больше органического трафика

Проблема SPA и SEO: Поисковым роботам сложно "увидеть" содержимое SPA, так как:
- контент подгружается динамически через JS
- бот может не выполнять JS вообще (или делать это ограниченно)

Решения:
1. SSR (Server-Side Rendering) — например, Next.js (React) или Nuxt (Vue) рендерят страницы на сервере
2. Prerendering / Static Site Generation (SSG) — рендерим всё заранее в HTML-файлы
3. Dynamic Rendering — сервер выдает обычную SPA людям, но статичный HTML ботам
4. Meta-теги и Open Graph — помогают соцсетям и поисковикам лучше отображать ссылку

### Vite

**Vite** — это современный инструмент сборки фронтенда, альтернатива Create React App (CRA), который работает намного быстрее за счёт использования ES-модулей и ускоренной разработки (dev server на Vite стартует практически мгновенно)

Что делает Vite:
- Быстрая сборка и запуск dev-сервера    
- Мгновенный HMR (обновление компонентов без перезагрузки)
- Поддержка React, Vue, Svelte и других фреймворков
- Возможность использовать TypeScript, SCSS, Tailwind и т.д.

#### Логика сервера на фронте

##### Зачем фронтенду свой сервер
Фронтенд-сервер (например, Vite Dev Server) нужен не как API, а чтобы:
- обслуживать HTML, JS, CSS, изображения
- обеспечить live reload / HMR (автообновление при изменениях в коде)
- проксировать запросы к бэкенду (чтобы обойти CORS при dev-разработке);
- имитировать поведение "настоящего продакшена", где frontend тоже отдается с сервера

##### Когда ты запускаешь npm run dev
- Vite поднимает локальный HTTP-сервер на `http://localhost:5173`
- Этот сервер:
    - отдает `index.html`
    - компилирует `JSX`/`React`-код на лету
    - обновляет страницу при изменениях (HMR)
    - может проксировать API-запросы на Flask (через `vite.config.js`)

##### Когда ты заходишь на http://localhost:5173 в браузере
- Браузер делает HTTP-запрос `GET /`
- Vite отдаёт `index.html`
- Внутри `index.html` подключается `main.jsx` (чтобы его подгрузить, браузер делает ещё 1 запрос), где монтируется React-приложение
- React-роутер внутри (например `react-router-dom`) уже сам отображает нужную страницу
 
##### Что будет в продакшене
Когда проект готов:
- `npm run build` создаёт папку `dist/` со статикой
- Эта статика может:
    - либо отдаваться Nginx’ом
    - либо быть встроена в Flask через `send_from_directory`
    - либо деплоиться на CDN (если фронт полностью отделён)

### ESLint

**ESLint** — это инструмент, который:
- Находит ошибки в коде до запуска
- Следит за стилем (отступы, кавычки, лишние импорты и пр.)
- Помогает писать единообразный и читаемый код
- Часто используется в React-проектах

`eslint.config.js` — это конфигурационный файл для ESLint — линтера JavaScript/TypeScript-кода

