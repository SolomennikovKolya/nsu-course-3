
### Команды

Работа с репозиторием:
- `git init` — создаёт новый Git-репозиторий в текущей папке
- `git clone <url>` — копирует удалённый репозиторий на локальную машину
Отслеживание изменений:
- `git status` — показывает текущий статус файлов (изменённые, неотслеживаемые и т.п.)
- `git add <файл>` — добавляет файл в индекс (подготовка к коммиту)
- `git add .` — добавляет все изменения в индекс
- `git commit -m "сообщение"` — сохраняет изменения с комментарием в истории проекта
Работа с историей:
- `git log` — показывает историю коммитов
- `git diff` — показывает различия между текущими и зафиксированными файлами
Отмена и возврат:
- `git checkout -- <файл>` — отменяет изменения в файле (возврат к последнему коммиту)
- `git restore <файл>` — то же, что и выше (новая альтернатива `checkout`)
- `git reset <файл>` — убирает файл из индекса (до коммита)
- `git reset --hard` — откатывает состояние рабочей папки и индекса к последнему коммиту (осторожно, безвозвратно)
Ветки:
- `git branch` — показывает список веток
- `git branch <имя>` — создаёт новую ветку
- `git checkout <ветка>` — переключается на указанную ветку
- `git switch <ветка>` — современная альтернатива `checkout` для веток
- `git merge <ветка>` — сливает указанную ветку в текущую
Удалённые репозитории:
- `git remote -v` — показывает список удалённых репозиториев
- `git fetch` — получает изменения с удалённого репозитория (без слияния)
- `git pull` — получает изменения и сливает их в текущую ветку
- `git push` — отправляет локальные коммиты в удалённый репозиторий
Другое:
- `git stash` — временно сохраняет незакоммиченные изменения
- `git stash pop` — возвращает сохранённые изменения из стэша

### Области хранения данных

#### Локальный репозиторий

Это ваш локальный проект, который находится на вашем компьютере

1. *Рабочая директория* (Working Directory):
	- Это текущее состояние файлов в вашем проекте
	- Здесь вы вносите изменения в файлы
	- Изменения в рабочей директории не отслеживаются Git, пока вы не добавите их в индекс (staging area)
2. *Индекс* (Staging Area)
	- Это промежуточная область, где вы готовите изменения для коммита
	- Вы добавляете файлы в индекс с помощью команды `git add`
	- Только изменения, добавленные в индекс, будут включены в следующий коммит
3. *Локальный репозиторий* (Local Repository)
	- Это база данных Git, которая хранит все коммиты, ветки, теги и историю изменений
	- Данные хранятся в скрытой папке `.git` в корне вашего проекта
	- Когда вы выполняете `git commit`, изменения из индекса сохраняются в локальном репозитории

#### Удаленный репозиторий

Это репозиторий, который находится на сервере (например, на GitHub). Он используется для совместной работы и синхронизации изменений между разработчиками

1. *Основной удаленный репозиторий*
	- Это централизованное хранилище, куда все разработчики отправляют свои изменения
	- Обычно называется `origin` (по умолчанию)
2. *Ветки на удаленном репозитории*
	- Удаленный репозиторий содержит ветки (например, `main`, `develop`), которые могут быть синхронизированы с локальными ветками
3. *Pull Requests*
	- На GitHub Pull Requests используются для предложения изменений из одной ветки в другую (например, из `feature-branch` в `main`)
	- PR не являются частью Git, но активно используются в GitHub для код-ревью и интеграции изменений

#### Дополнительные области хранения

1. *stash* (Временное хранилище)
	- Stash позволяет временно сохранить изменения, которые еще не готовы для коммита
	- Полезно, если вам нужно переключиться на другую ветку, но вы не хотите коммитить текущие изменения
2. *Reflog* (Журнал ссылок)
	- Reflog хранит историю всех изменений указателей (например, `HEAD`, веток, тегов)
	- Полезно для восстановления удаленных веток или отмены ошибочных операций
3. *Теги* (Tags)
	- Теги используются для отметки важных моментов в истории (например, релизов)
	- Они хранятся как в локальном, так и в удаленном репозитории

### SSH

#### Подключение через SSH
1. Проверьте наличие SSH-ключа 
	- `ls -al ~/.ssh`
	- Вы должны увидеть файлы с именами `id_rsa` и `id_rsa.pub`
	- Если их нет, вам нужно создать SSH-ключ.
2. Создайте SSH-ключ
	- `ssh-keygen -t ed25519 -C "your_email@example.com"`
	- Укажите название `id_rsa`
	- После создания ключа появятся файлы `id_rsa` и `id_rsa.pub`
	- Можно переместить ключи в `~/.ssh` чтобы не потерять их
		- `mv id_rsa ~/.ssh/id_rsa`
		- `mv id_rsa.pub ~/.ssh/id_rsa.pub`
3. Добавьте SSH-ключ в агент SSH
	- Чтобы активировать ключ, добавьте его в SSH-агент:
	- `eval "$(ssh-agent -s)" ssh-add ~/.ssh/id_rsa
	- `ssh-add ~/.ssh/id_rsa`
4. Скопируйте публичный SSH-ключ и добавьте его в GitHub
	- `cat ~/.ssh/id_rsa.pub`
	- Перейдите в настройки GitHub SSH and GPG keys и добавьте ключ
5. Проверьте подключение
	- `ssh -T git@github.com`

#### Клонирование репозитория
1. Настройка git:
	- `git config --global user.name "Ваше Имя"` - сохранение вашего имени в переменных гита
	- `git config --global user.email "ваш.email@пример.com"` - сохранение почты
	- `git config --list` - проверка настроек

#### SSH-агент

`ssh-agent` — это менеджер ключей для SSH. Он хранит ваши ключи и сертификаты в памяти, незашифрованные и готовые к использованию `ssh`. Это избавляет вас от необходимости вводить пароль каждый раз, когда вы подключаетесь к серверу. Он работает в фоновом режиме в вашей системе, отдельно от `ssh`, и обычно запускается при первом запуске `ssh`

#### Как используются ключи 

Пара ключей SSH используется только для аутентификации во время первоначального соединения. Она не используется для шифрования и дешифрования трафика  
  
Проверка ключа пользователя во время SSH-соединения, с точки зрения сервера:  
- Клиент предоставляет серверу публичный ключ
- Сервер генерирует и отправляет короткое случайное сообщение, прося клиента подписать его с помощью приватного ключа
- Клиент просит агента SSH подписать сообщение и пересылает результат обратно на сервер
- Сервер проверяет подпись, используя публичный ключ клиента
- Теперь у сервера есть доказательство того, что клиент владеет приватным ключом

Позже в процессе соединения генерируется набор новых, эфемерных и симметричных ключей, которые используются для шифрования трафика сеанса SSH. Эти ключи могут даже не длиться весь сеанс; событие «rekey» происходит через регулярные промежутки времени

