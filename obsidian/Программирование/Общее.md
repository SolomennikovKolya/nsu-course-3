
### Принципы ООП

1. **Инкапсуляция**
	- Суть: Сокрытие внутренней реализации объекта и предоставление строго определённого интерфейса для взаимодействия с ним
	- Зачем: Чтобы защитить данные объекта от несанкционированного доступа и упростить использование объекта, скрыв сложность его внутренней логики
2. **Наследование**
	- Суть: Возможность создания новых классов на основе существующих, с целью повторного использования кода и создания иерархии классов
	- Зачем: Чтобы избежать дублирования кода и организовать логическую структуру программы
3. **Полиморфизм**
	- Суть: Возможность объектов с одинаковым интерфейсом иметь разную реализацию
	- Зачем: Чтобы обеспечить гибкость и расширяемость программы, позволяя работать с разными типами объектов через единый интерфейс
4. **Абстракция**
	- Суть: Выделение основных характеристик объекта, игнорируя несущественные детали
	- Зачем: Чтобы упростить работу с сложными системами, фокусируясь на ключевых аспектах

### SOLID

1. **Single Responsibility Principle (Принцип единственной ответственности)**
	- Суть: Каждый класс должен иметь только одну причину для изменения, то есть выполнять только одну задачу
	- Зачем: Чтобы упростить поддержку и тестирование кода, а также избежать сложных зависимостей
	- Пример: Класс User должен отвечать только за данные пользователя, а не за логику отправки email
2. **Open/Closed Principle (Принцип открытости/закрытости)**
	- Суть: Программные сущности (классы, модули, функции) должны быть открыты для расширения, но закрыты для модификации
	- Зачем: Чтобы можно было добавлять новую функциональность, не изменяя существующий код
	- Пример: Использование интерфейсов или абстрактных классов для добавления новых типов без изменения старого кода
3. **Liskov Substitution Principle (Принцип подстановки Барбары Лисков)**
	- Суть: Объекты в программе должны быть заменяемы экземплярами их подтипов без изменения правильности работы программы
	- Зачем: Чтобы обеспечить корректную работу наследования и полиморфизма
	- Пример: Если у вас есть класс Bird, то его подкласс Penguin не должен нарушать ожидаемое поведение (например, пингвины не летают, поэтому метод fly() не должен быть в этом классе)
4. **Interface Segregation Principle (Принцип разделения интерфейса)**
	- Суть: Клиенты не должны зависеть от интерфейсов, которые они не используют. Лучше создавать узкоспециализированные интерфейсы, чем один общий
	- Зачем: Чтобы избежать "раздутых" интерфейсов и ненужных зависимостей
	- Пример: Вместо одного интерфейса Printer, который включает методы print(), scan() и fax(), лучше создать отдельные интерфейсы для каждой функции
5. **Dependency Inversion Principle (Принцип инверсии зависимостей)**
	- Суть: Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций
	- Зачем: Чтобы уменьшить связанность между компонентами и упростить тестирование и замену модулей
	- Пример: Вместо того чтобы класс UserService напрямую зависел от класса MySQLDatabase, он должен зависеть от абстракции (интерфейса) Database
