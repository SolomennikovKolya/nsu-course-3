
### Полезности
- [Maven](https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core/2.17.1)
- [Oracle Docs](https://docs.oracle.com/en/java/javase/22/docs/api/index.html)
- [Intellij IDEA shortcuts](https://resources.jetbrains.com/storage/products/intellij-idea/docs/IntelliJIDEA_ReferenceCard.pdf)

Удобнейший просмотр структуры проекта:
- `Ctrl+N` — поиск классов
- `Ctrl+Shift+N` — поиск файлов
- `Ctrl+Alt+Shift+U` — диаграмма зависимостей классов
- Вкладка Structure — показывает поля, методы текущего файла
- Вкладка Project — видишь пакеты, иерархию, зависимости

Плагин: [PlantUML](https://plugins.jetbrains.com/plugin/7017-plantuml-integration) - Позволяет генерировать диаграммы классов и связей

### Пакеты

**Пакет (package)** — это пространство имен, и подпакеты не входят в родительский пакет. Например, если класс `Class1` находится в пакете `com.example`, а класс `Class2` находится в подпакете `com.example.subpackage`, то они не считаются находящимися в одном пакете

### Уровни доступа

В Java существует 4 уровня доступа для классов, методов и полей, которые определяют, откуда можно к ним обращаться. Управление доступом осуществляется с помощью модификаторов:
1. `public` (доступ везде): Виден всем классам, даже из других пакетов
2. `protected`: Виден в том же пакете и в подклассах, даже если они в другом пакете
3. `package-private` (default, без модификатора): Виден только в своём пакете
4. `private` (только внутри класса): Виден только в пределах своего класса

| Модификатор                 | Класс | Пакет | Подкласс (в другом пакете) | Внешний код |
| --------------------------- | ----- | ----- | -------------------------- | ----------- |
| `public`                    | Да    | Да    | Да                         | Да          |
| `protected`                 | Да    | Да    | Да                         | Нет         |
| `package-private` (default) | Да    | Да    | Нет                        | Нет         |
| `private`                   | Да    | Нет   | Нет                        | Нет         |
#### Особенности
- Для классов можно использовать только `public` или `package-private` (без модификатора)
	- `public class A {}` - виден везде
	- `class B {}` - виден только в пакете
- Локальные переменные в методах не могут иметь модификаторы доступа

### Аллокация

**Аллокация** (выделение) памяти в Java происходит только под контролем JVM (Java Virtual Machine)

Модель памяти в куче: разделение на поколения:
1. *Young Generation (Молодое поколение)*:
    - Это область памяти, где создаются новые объекты. Она состоит из трёх частей: одного Eden Space и двух Survivor Spaces
    - Когда объект создаётся, он попадает в Eden Space. Когда происходит сбор мусора (Minor GC), живые объекты перемещаются в один из Survivor Space
    - Для ускорения работы JVM использует простую технику аллокации памяти в молодом поколении — bump-the-pointer allocation. Вся память в Eden Space является сплошным блоком, и для выделения нового объекта достаточно сдвинуть указатель на новое свободное место в памяти (аналогично тому, как происходит аллокация на стеке)
2. *Old Generation (Старшее поколение)*:
    - Когда объекты становятся "старше" (например, после нескольких циклов сборки мусора в Young Generation), они перемещаются в старшее поколение
    - Это область, где хранятся объекты с долгим временем жизни. Сбор мусора в старшем поколении происходит реже, и он может быть более дорогим по времени выполнения, чем в молодом поколении (Major GC)
Другие регионы памяти:
3. *Metaspace*:
	- На куче хранятся только данные объекта (поля), а метаданные (имя, супер-класс, реализуемые интерфейсы, описание полей и методов класса, виртуальные таблицы (vtable), ссылки на байт-код методов (Bytecode references), символьные пулы (String Pool))

### Maven

Когда вы собираете проект через Maven (используя `pom.xml`), зависимости автоматически загружаются и управляются системой. В файле `pom.xml` вы указываете нужные библиотеки в блоке `<dependencies>`. Maven по координатам (`groupId`, `artifactId`, `version`) находит библиотеку в репозиториях:
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>5.3.10</version>
    </dependency>
</dependencies>
```

Новые зависимости добавляются вручную в `<dependencies>`

Где взять координаты зависимости (`groupId`, `artifactId`, `version`)?
1. Зайдите на [mvnrepository.com](https://mvnrepository.com/)
2. Введите название библиотеки (например, `lombok`, `gson`, `spring-boot-starter-web`)
3. Выберите нужную версию → скопируйте блок `<dependency>`

Где хранятся зависимости?
По умолчанию Maven скачивает все зависимости в локальную папку на вашем компьютере:
- Windows: `C:\Users\<ваш_пользователь>\.m2\repository`
- Linux/Mac: `~/.m2/repository`

Как Maven разрешает зависимости?
1. Проверяет локальный кэш (`~/.m2/repository`)
    - Если библиотека уже есть, использует её
    - Если нет — скачивает из удалённого репозитория  
2. Следует за транзитивными зависимостями (если `A` зависит от `B`, а `B` зависит от `C`, Maven скачает и `B`, и `C`)
3. Учитывает `<scope>` (например, `test`-зависимости не попадут в финальный `.war`/`.jar`)

### Spring

**Spring** — это мощный и широко используемый Java-фреймворк для создания корпоративных приложений. Он предоставляет гибкую инфраструктуру для разработки, настройки и управления компонентами приложения

#### Основные возможности Spring
1. *Внедрение зависимостей (DI, Dependency Injection)*
	- Автоматически создаёт объекты и передаёт их туда, где они нужны
	- Пример: `@Autowired`, `@Component`, `@Service`, `@Repository`, `@Controller`
	- Зачем: меньше ручной работы и связности между классами
2. *Управление жизненным циклом объектов (IoC контейнер)*
	- Хранит все созданные объекты (бины) в себе
	- Умеет их запускать, завершать, и пересоздавать при необходимости
	- Зачем: контроль, масштабируемость, модульность
3. *Создание веб-приложений (Spring MVC)*
	- Упрощает написание HTTP API
	- Аннотации типа `@RestController`, `@RequestMapping`, `@GetMapping`, и т. д.
	- Зачем: быстро делать REST API и сайты
4. *Работа с базой данных (Spring Data JPA, JDBC)*
	- Легко подключать БД и писать запросы
	- Автоматически реализует методы репозиториев
	- Зачем: писать минимум SQL-кода, а иногда — вообще не писать
5. *Безопасность (Spring Security)*
	- Аутентификация (вход в систему), авторизация (права доступа)
	- Интеграция с JWT, OAuth2, сессиями и т. п.
	- Зачем: защита API, управление пользователями и ролями
6. *AOP (Aspect-Oriented Programming)*
	- Позволяет подключать доп. поведение "снаружи": логгирование, транзакции, безопасность
	- Пример: `@Transactional`, `@Before`, `@After`
	- Зачем: отделить техническую логику от основной
7. *Обработка событий (Application Events)*
	- Поддержка событий внутри приложения
	- Пример: пользователь зарегистрировался → отправить письмо
	- Зачем: слабосвязанное взаимодействие между частями приложения
8. *Работа с очередями и интеграциями (Spring Integration, Spring Kafka и др.)*
	- Подключение к брокерам сообщений, очередям (RabbitMQ, Kafka)
	- Реакция на внешние события
	- Зачем: микросервисы, распределённые системы
9. *Кэширование (Spring Cache)*
	- Позволяет сохранять часто используемые данные в памяти
	- Пример: `@Cacheable`, `@CacheEvict`
	- Зачем: ускорение работы, снижение нагрузки
10. *Реактивное программирование (Spring WebFlux)*
	- Асинхронная и неблокирующая обработка запросов
	- Использует `Mono`, `Flux` (из Project Reactor)
	- Зачем: высокая производительность при большом количестве пользователей
11. *Тестирование (Spring Test)*
	- Удобные средства для unit и integration тестов
	- Аннотации: `@SpringBootTest`, `@MockBean`, `@DataJpaTest`
	- Зачем: легко и быстро писать автотесты для всей логики

#### Определения

**Бин** — это просто объект, который управляется Spring-ом. Ты мог бы создать объект сам через `new`, но Spring делает это сам и кладёт в свой контейнер (IoC-контейнер), чтобы потом по запросу отдавать куда надо
- ApplicationContext - специальный контейнер для всех бинов
- Типы бин-жизни (scopes):
	- `singleton` (по умолчанию) — один объект на всё приложение
	- `prototype` — новый объект при каждом запросе
	- `request` — один на HTTP-запрос (для веба)
	- `session` — один на сессию

**IoC** (Inversion of Control / инверсия управления). Обычно ты сам контролируешь, когда и что создать, а при IoC, этот контроль передаётся внешней системе — например, Spring

**DI** (Dependency Injection / внедрение зависимостей) - это конкретный способ реализации IoC. Вместо того, чтобы создавать зависимости внутри класса, ты получаешь их извне — через конструктор, поле или метод

#### Spring работает на этапе запуска (рантайма)
1. Spring сканирует классы, находит аннотации
2. Создает нужные объекты (бины)
3. Если надо — оборачивает их в прокси-объекты, чтобы добавить нужное поведение
4. Подставляет зависимости туда, где ты указал `@Autowired`, `@Inject`, и т.п.

#### Spring Boot

**Spring Boot** — это фреймворк на базе Spring, который упрощает создание производственных (production-ready) Java-приложений, особенно веб-приложений и REST API. Его основная цель — автоматическая настройка и минимум конфигурации, чтобы разработчик мог сосредоточиться на логике приложения

Простыми словами:
- Spring — это гибкий, но сложный фреймворк, где ты сам всё подключаешь, настраиваешь, и пишешь тонну конфигурации
- Spring Boot — это удобная оболочка над Spring, которая:
    - Автоматически настраивает всё за тебя
    - Включает нужные зависимости
    - Даёт встроенный сервер
    - Позволяет запустить веб-приложение буквально за 1 файл с `main()`

|                      | Spring (Core)                           | Spring Boot                                  |
| -------------------- | --------------------------------------- | -------------------------------------------- |
| ⚙️ Настройка         | Много ручной настройки                  | Почти всё автоматически                      |
| 🧱 Архитектура       | Набор модулей, которые ты собираешь сам | Готовая коробка: «всё включено»              |
| 🛠️ Запуск           | Надо настраивать сервер, конфиги и т.п. | Встроенный сервер, запускается одной строкой |
| 🧾 Конфиги           | XML, Java config, много ручной работы   | Почти всё через `application.properties`     |
| 🚀 Быстрый старт     | Медленно, нужно много знать             | Быстро — можно запустить за 5 минут          |
| 📦 Зависимости       | Сам выбираешь, сам подключаешь          | Автоматическое подключение через "starter'ы" |
| 📡 Web сервер        | Нужно подключить Tomcat/Jetty вручную   | Встроен (обычно Tomcat)                      |
| 👶 Подходит новичкам | Нет — много настроек и терминов         | Да — минимально нужных знаний на старте      |

#### Tomcat

**Apache Tomcat** — это веб-сервер и сервлет-контейнер, написанный на Java

Что он делает:
1. Слушает HTTP-запросы (напр. `localhost:8080`)
2. Обрабатывает их с помощью сервлетов (специальных Java-классов)
3. Отдаёт ответы (HTML, JSON и т.д.)

Простыми словами:
- Tomcat — это как Nginx/Apache, но для Java-приложений
- Он запускает твоё Java-приложение и делает его доступным через HTTP

### Интересные вопросы

#### Почему объекты на куче в Java работают быстро?
1. *Аллокаторы памяти*: В Java для аллокации объектов используются оптимизированные аллокаторы, которые работают быстрее, чем простая работа с кучей. Например, когда создаются объекты, они вначале помещаются в младшее поколение, где аллокация памяти может быть выполнена за один шаг (bump-the-pointer allocation), так как память выделяется в компактном непрерывном блоке
2. *Escape Analysis*: Этот механизм позволяет Java оптимизировать использование памяти, выполняя stack allocation вместо heap allocation в тех случаях, когда анализ показывает, что объект не "уходит" за пределы метода или потока. Например, если объект не передается за пределы метода, компилятор может разместить его в стеке, а не в куче
3. *Представление объектов в памяти*: JVM использует компактные и оптимизированные структуры данных для управления объектами. Например, полные метаданные объекта (например, информация о классе и монитор для синхронизации) хранятся в компактной форме, а поля объектов могут быть выровнены и оптимизированы для эффективного доступа
