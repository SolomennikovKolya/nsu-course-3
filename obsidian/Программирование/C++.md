
### Полезности
- [Руководство по C++](https://metanit.com/cpp/tutorial/)
- [build-your-own-x](https://github.com/Teslow/build-your-x?tab=readme-ov-file)

### Подключение библиотек

#### Статические библиотеки

**Статические библиотеки** (с расширением `.lib` на Windows и `.a` на Linux и macOS) компилируются и добавляются непосредственно в итоговый исполняемый файл. Таким образом, весь необходимый код библиотеки «встраивается» в приложение

##### Подключение библиотеки:
1. Компиляция статической библиотеки
    - `gcc -c mylib.c -o mylib.o` сначала надо создать объектные файлы
    - `ar rcs libmylib.a mylib.o` затем добавить их к архиву (`.lib` или `.a` файл)
2. Подключение в коде
	- `#include "mylib.h"` - в исполняемом коде
3. Сборка с подключением библиотеки
    - На Linux и macOS указываем файл библиотеки через флаг `-l` и путь через `-L`
        `g++ main.cpp -L/path/to/library -lmylib -o myapp`
    - На Windows обычно указывается полный путь к `.lib` файлу в настройках компилятора (в Visual Studio) или аналогичным образом через командную строку
        `cl main.cpp /link /LIBPATH:C:\path\to\library mylib.lib`

#### Динамические библиотеки

**Динамические библиотеки** (с расширением `.dll` на Windows, `.so` на Linux и `.dylib` на macOS) загружаются в память во время выполнения программы. Это уменьшает размер исполняемого файла и позволяет обновлять библиотеку без перекомпиляции основного кода

##### Подключение библиотеки:
1. Компиляция динамической библиотеки
    `g++ -fPIC -shared mylib.cpp -o libmylib.so`
2. Подключение в коде
    `#include "mylib.h"`
3. Сборка с подключением библиотеки
    - В Linux и macOS укажите путь к библиотеке с флагом `-L` и саму библиотеку с `-l`.
        `g++ main.cpp -L/path/to/library -lmylib -o myapp`
4. Запуск программы с динамической библиотекой
    - На Linux добавьте путь к библиотеке в переменную окружения `LD_LIBRARY_PATH` или разместите библиотеку в стандартном пути `/usr/lib` или `/usr/local/lib`
        `export LD_LIBRARY_PATH=/path/to/library:$LD_LIBRARY_PATH ./myapp`
    - На macOS используйте `DYLD_LIBRARY_PATH` или `install_name_tool` для установки пути к библиотеке
        `export DYLD_LIBRARY_PATH=/path/to/library:$DYLD_LIBRARY_PATH ./myapp`
    - На Windows: добавьте путь к `.dll` в `PATH` или поместите `.dll` в ту же директорию, где находится исполняемый файл приложения

#### Стандартные библиотеки

1. Динамическое подключение (`libc` на Linux или `msvcrt.dll` на Windows) позволяет:
	- **Сократить размер исполняемого файла**: Код стандартной библиотеки загружается отдельно, и нет необходимости включать его в каждый исполняемый файл
	- **Обновлять библиотеку отдельно**: Обновления и исправления безопасности в библиотеке сразу доступны для всех программ, использующих её динамически
	- Этот способ подключения используется по стандарту
	- Компилятор неявно линкует программу с libc

2. Статическое подключение (`libc.a` на Linux) позволяет:
	- **Программы, которые должны работать без зависимостей**: Например, для встроенных систем, где может не быть динамического загрузчика или где каждая зависимость должна быть включена в исполняемый файл
	- **Обеспечение совместимости**: Если нужно гарантировать, что программа использует определённую версию стандартной библиотеки, её можно связать статически, чтобы избежать проблем с несовместимостью при запуске на другой системе

Стандартная библиотека C++ это **`libstdc++`** на Linux или **`msvcprt.lib`** на Windows (не является частью libc)

### Сборка

#### Варианты сборки
1. Тыкнуть кнопочку в IDE (неявно используется система сборки)
2. Вручную в терминале
3. Через make файлы (с помощью них можно автоматизировать рутинные задачи)
4. Через системы сбирки (например MSBuild, CMake)

#### Кросплатформенное приложение на c++
1. *Использование кроссплатформенных библиотек* (обеспечивает унифицированный доступ к системе и часто применяемым функциям). Примеры: Qt, Boost, SDL, SFML
2. *Использование CMake для сборки* позволяет писать один CMake-файл, который будет адаптирован для Windows, macOS и Linux. А также автоматически генерировать файлы сборки для разных IDE (Visual Studio, Xcode) и систем сборки (make, Ninja)
3. *Поддержка зависимости от ОС и адаптация к платформам*. Использование препроцессорных директив `#ifdef`, чтобы разделить части кода в зависимости от платформы. Использование платформенных макросов: `#ifdef _WIN32`, `#ifdef __linux__`, `#ifdef __APPLE__` и другие
4. *Контейнеризация и виртуализация*. Для тестирования кроссплатформенных приложений удобно использовать контейнеризацию и виртуализацию. Например, Docker позволит вам запускать приложение в Linux-контейнерах, а виртуальные машины, такие как VirtualBox или VMware, могут использоваться для запуска Windows и macOS-сред

#### Make

##### Специальные конструкции
- `OBJECTS = $(SOURCES:.c=.o)` - создаёт список объектов (`OBJECTS`) на основе списка исходников (`SOURCES`). Это специальная форма замены суффиксов, которая позволяет преобразовать список файлов с расширением `.c` в соответствующие файлы с расширением `.o`
- `$(CC) -o $@ $^ $(LDFLAGS)`

##### Автоматические переменные
- `$@` - ссылается на имя цели, которая будет создана. Например, если целью является `main`, то `-o $@` будет означать `-o main`
- `$^` - ссылается на все зависимости (или предшествующие файлы) для данной цели. Например, если цель зависит от `file1.o file2.o`, то `$^` будет равен `file1.o file2.o`
- `$<` — представляет первую зависимость в текущем рецепте

#### Cmake

##### Минимальный CMakeLists.txt для сборки программы
```cmake
# Указываем минимальную версию CMake
cmake_minimum_required(VERSION 3.10)
# Задаем имя проекта
project(MyProject)
# Указываем стандарт C
set(CMAKE_C_STANDARD 99)
# Указываем исходный файл
set(SOURCES main.c)
# Создаем исполняемый файл из исходного файла
add_executable(MyExecutable ${SOURCES})
```

##### Как использовать
1. Надо поместить `CMakeLists.txt` в корневую директорию проекта
2. Создание папки для сборки: `mkdir build && cd build`
3. Генерация файлов сборки: `cmake ..`
4. Сборка проекта: `make` либо `cmake --build .`
5. Запуск программы: `./MyExecutable`

##### Работа с Cmake в VS Code
1. Установите расширения:
    - CMake Tools
    - C/C++ (от Microsoft)
2. Настройка CMake:
    - Создайте файл `CMakeLists.txt` в корневом каталоге вашего проекта
3. Настройка конфигурации CMake:
    - Откройте палитру команд (`Ctrl+Shift+P`) и введите `CMake: Configure`. Выберите нужный генератор, например, `Ninja` или `Unix Makefiles`
    - После этого CMake создаст необходимые файлы для сборки вашего проекта (make файлы и конфиги)
4. Сборка проекта:
    - Откройте палитру команд и выполните команду `CMake: Build`. Это создаст исполняемый файл в каталоге сборки (обычно `build`)
5. Запуск программы:
    - Для выполнения вашей программы можно создать конфигурацию запуска. Для этого создайте файл `.vscode/launch.json` в вашем проекте и запишите нужные настройки
6. shortcuts:
	- `F7` - build
	- `shift + F5` - build + debug
	- `F5` - build + debug

###### Пример launch.json
```json 
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug",
      "type": "cppdbg",
      "request": "launch",
      "program": "${workspaceFolder}/build/my_executable",
      "args": [],
      "stopAtEntry": false,
      "cwd": "${workspaceFolder}",
      "environment": [],
      "externalConsole": false,
      "MIMode": "gdb",
      "setupCommands": [
        {
          "description": "Enable pretty-printing for gdb",
          "text": "-enable-pretty-printing",
          "ignoreFailures": true
        }
      ],
      "preLaunchTask": "build",
    }
  ]
}
```

### Связывание

#### Виды связывании
- **Внешнее связывание (External linkage)**:
    - Переменные и функции с внешним связыванием доступны из других файлов, которые включают соответствующие заголовочные файлы
    - По умолчанию внешнее связывание имеют глобальные переменные и функции
    - Пример:
	    - `int globalVar;`
	    - `void func() {}`
	- Чтобы явно указать, что переменная или функция определена в другом файле можно использовать ключевое слово `extern`
- **Внутреннее связывание (Internal linkage)**:
    - Переменные и функции с внутренним связыванием доступны только в пределах одного файла, в котором они определены
    - Это достигается с помощью ключевого слова `static`
    - Пример:
        - `static int localVar;`
        - `static void localFunc() {}`
- **Отсутствие связывания (No linkage)**:
    - Локальные переменные, объявленные внутри функции, имеют отсутствие связывания. Они доступны только в пределах данной функции
    - Пример:
        - `void func() { int localVar; }`

#### Дополнительные свойства static для переменных
1. *Продолжительность жизни*
	- Переменные, объявленные как `static`, сохраняют своё значение между вызовами функций. Это означает, что они существуют в течение всей жизни программы, а не только во время выполнения функции, в отличие от обычных локальных переменных
2. *Область видимости*
	- Для глобальных переменных: Статическая переменная, объявленная на глобальном уровне, будет доступна только внутри файла, где она была объявлена. Она не видна в других файлах, даже если они подключены через `#include`. Это предотвращает доступ к ней извне, улучшая модульность
	- Для локальных переменных: Статическая переменная внутри функции будет иметь область видимости только в пределах этой функции, но при этом её значение сохраняется между вызовами
3. *Инициализация*
	- Переменные, объявленные static, инициализируются только 1 раз, даже если функция с инициацией вызывается много раз
	- Напрмер `void f() { static int var = 0; }` присваивает var = 0 только при первом запуске `f()`

#### Замечание!

Если функция не объявлена как `static`, она по умолчанию имеет ВНЕШНЕЕ СВЯЗЫВАНИЕ. Если другой файл знает сигнатуру функции (то есть её имя, возвращаемый тип и параметры), он может объявить прототип функции и затем вызывать её, даже если функция определена в другом исходном файле. Например:
```c
// Файл func.c
void myFunction() {     
	// Реализация 
}
```
```c
// Файл main.c
void myFunction(); // Объявление прототипа вручную
int main() {
	myFunction(); // Вызываем myFunction из func.c
	return 0;
}
```

### Volatile

Ключевое слово `volatile` в C и C++ указывает компилятору, что значение переменной может изменяться в любой момент времени не по ходу выполнения программы (например, за счет другого потока, оборудования или операционной системы). Оно говорит компилятору:
4. Не оптимизировать доступ к этой переменной — компилятор не должен кэшировать значение переменной в регистре, а должен всегда считывать её значение из памяти.
5. Каждый доступ к переменной должен выполняться напрямую из оперативной памяти, даже если до этого её значение было считано ранее.

Использование `volatile` важно, например, когда переменные могут быть изменены:
- **Аппаратурой** (например, регистры оборудования).
- **Обработчиками сигналов** (например, обработчики прерываний, изменяющие переменные в ответ на события).
- **Другими потоками** (например, переменные, используемые в многопоточности, хотя в таких случаях часто требуется и дополнительная синхронизация, например с помощью `mutex`).

#### Пример использования
```c
volatile int flag = 0;

void wait_for_flag() {
    while (flag == 0) {
        // Ждем, пока flag станет ненулевым
    }
    // Код продолжает выполнение после изменения flag
}

```

#### Замечание
- volatile не решает проблему гонки ресурсов в многопоточных программах.
- Использование volatile не делает операции над переменной атомарными.

### Завершение программы 

|Функция|Описание|
|---|---|
|`exit()`|Завершает программу, вызывает функции завершения (например, зарегистрированные через `atexit`).|
|`_Exit()`|Немедленно завершает процесс без выполнения функций завершения.|
|`abort()`|Немедленно завершает программу, генерируя сигнал `SIGABRT` и создавая дамп ядра.|
|`return` в `main`|Завершает выполнение программы, возвращая код выхода.|

### Стандартные контейнеры

| Контейнер      | Доступ                          | Вставка в конец   | Вставка в середину      | Вставка в начало | Удаление (по значению) | Удаление по итератору | Поиск          |
| -------------- | ------------------------------- | ----------------- | ----------------------- | ---------------- | ---------------------- | --------------------- | -------------- |
| vector         | `O(1)`                          | `O(1)` (амортиз.) | `O(n)`                  | `O(n)`           | `O(n)`                 | `O(n)`                | `O(n)`         |
| array          | `O(1)`                          | `N/A`             | `N/A`                   | `N/A`            | `N/A`                  | `N/A`                 | `O(n)`         |
| deque          | `O(1)`                          | `O(1)`            | `O(n)`                  | `O(1)`           | `O(n)`                 | `O(n)`                | `O(n)`         |
| list           | `O(n)`                          | `O(1)`            | `O(1)` (через итератор) | `O(1)`           | `O(n)`                 | `O(1)`                | `O(n)`         |
| forward_list   | `O(n)`                          | `O(1)`            | `O(n)`                  | `O(1)`           | `O(n)`                 | `O(1)`                | `O(n)`         |
| set / multiset | `O(log n)`                      | `O(log n)`        | `N/A`                   | `N/A`            | `O(log n)`             | `O(log n)`            | `O(log n)`     |
| unordered_set  | `O(1)` (сред.) / `O(n)` (худш.) | `O(1)` (сред.)    | `N/A`                   | `N/A`            | `O(1)` (сред.)         | `O(1)` (сред.)        | `O(1)` (сред.) |
| map / multimap | `O(log n)`                      | `O(log n)`        | `N/A`                   | `N/A`            | `O(log n)`             | `O(log n)`            | `O(log n)`     |
| unordered_map  | `O(1)` (сред.) / `O(n)` (худш.) | `O(1)` (сред.)    | `N/A`                   | `N/A`            | `O(1)` (сред.)         | `O(1)` (сред.)        | `O(1)` (сред.) |
| stack          | `O(1)`                          | `O(1)` (`push()`) | `N/A`                   | `N/A`            | `O(1)` (`pop()`)       | `N/A`                 | `O(n)`         |
| queue          | `O(1)`                          | `O(1)` (`push()`) | `N/A`                   | `O(1)`           | `O(1)` (`pop()`)       | `N/A`                 | `O(n)`         |
| priority_queue | `O(1)` (доступ к макс.)         | `O(log n)`        | `N/A`                   | `N/A`            | `O(n)`                 | `O(log n)` (`pop()`)  | `O(n)`         |

#### Разбор контейнеров
- `std::vector` → Лучший для случайного доступа и динамического массива. Вставка в конец дешевая, но дорогая в середину или начало
- `std::array` → Фиксированный массив, быстрее всех, но размер неизменяемый
- `std::deque` → Быстрая вставка в начало и конец, но медленный доступ к элементам
- `std::list` / `std::forward_list` → Двусвязный и однонаправленный списки. Хороши для частых вставок/удалений в середину, но медленный доступ
- `std::set` / `std::multiset` → Отсортированное дерево. Все операции `O(log n)`, но нет случайного доступа
- `std::unordered_set` → Хэш-таблица, быстрые `O(1)` операции, но без порядка элементов
- `std::map` / `std::multimap` → Отсортированное дерево, `O(log n)` на доступ, вставку и удаление
- `std::unordered_map` → Хэш-таблица, `O(1)` операции, но возможны коллизии (`O(n)` в худшем случае)
- `std::stack` / `std::queue` / `std::priority_queue` → Специализированные структуры, работающие через `vector` или `deque`

### Деревья

#### Типы деревьев
1. **Бинарное дерево (Binary Tree)**:
    - Каждый узел имеет не более двух дочерних узлов (левый и правый)
    - Примеры использования: бинарные деревья поиска, кучи, синтаксические деревья
2. **Бинарное дерево поиска (Binary Search Tree, BST)**:
    - Частный случай бинарного дерева, где для каждого узла:
        - Все элементы в левом поддереве меньше значения узла
        - Все элементы в правом поддереве больше значения узла
    - Используется для эффективного поиска, вставки и удаления элементов
3. **Сбалансированное дерево (Balanced Tree)**:
    - Дерево, в котором высота левого и правого поддеревьев каждого узла отличается не более чем на 1
    - Примеры: AVL-дерево, красно-чёрное дерево
4. **Дерево выражений (Expression Tree)**:
    - Используется для представления математических выражений, где листья — это операнды, а внутренние узлы — операторы
5. **Дерево отрезков (Segment Tree)**:
    - Используется для выполнения запросов на диапазоне (например, поиск минимума, суммы на отрезке) за логарифмическое время
6. **Префиксное дерево (Trie)**:
	- Используется для эффективного хранения и поиска строк
    - Каждый узел представляет собой символ, а путь от корня до листа — строку
    - Применяется в автодополнении, поиске слов в словаре
7. **Дерево Фенвика (Fenwick Tree)**:
    - Используется для вычисления prefix sums (сумм на префиксах) и обновления элементов за O(log N)
8. **B-дерево (B-Tree)**:
    - Используется в базах данных и файловых системах для хранения больших объёмов данных
    - Каждый узел может содержать множество ключей и иметь много дочерних узлов

### Управление памятью для классов

В C++ *объекты можно безопасно возвращать из функции, даже если они создаются на стеке*, благодаря **RVO (Return Value Optimization)** и **перемещающему семантизму**

#### Return Value Optimization

Если возвращается локальная переменная, компилятор *создаёт объект сразу в месте вызова*, без копирования. Замечание: RVO работает даже без `move` или `&&`

```c++
MyClass createObject() {
	return MyClass();
}
```

#### Перемещение вместо копирования

Если RVO не применился, вызывается *перемещающий конструктор* (`MyClass(MyClass&&)`), а не копирующий

```c++
class MyClass {
public:
	MyClass() { 
		std::cout << "Constructor\n";
	}
	MyClass(const MyClass&) { 
		std::cout << "Copy Constructor\n"; 
	}
	MyClass(MyClass&&) noexcept { 
		std::cout << "Move Constructor\n";
	}
};

MyClass createObject() {
	MyClass obj;
	return std::move(obj);
}
```

### Явные преобразования типов

| Cast                               | Где использовать              | Безопасность | Когда применять?                   |
| ---------------------------------- | ----------------------------- | ------------ | ---------------------------------- |
| `(type)expr`                       | Примитивные типы              | ❌ Опасный    | `int → double`, `char → int`       |
| **`static_cast<type>(expr)`**      | Проверяемые приведения        | ✅ Безопасный | `double → int`, `Base* → Derived*` |
| **`reinterpret_cast<type>(expr)`** | Низкоуровневые приведения     | ❌ Опасный    | `void* → int*`, сериализация       |
| **`const_cast<type>(expr)`**       | Убирает `const`               | ⚠ Опасный    | Удаление `const` из указателя      |
| **`dynamic_cast<type>(expr)`**     | Приведение в иерархии классов | ✅ Безопасный | Проверка типа `Base* → Derived*`   |

#### C-style cast

Старый способ преобразования типов из C

##### Когда использовать  
- Только для примитивных типов (например, `double → int`)

##### Почему не рекомендуется
- Опасен, потому что не проверяет безопасность преобразования
- Неявно комбинирует все типы cast-ов (`static_cast`, `reinterpret_cast`, `const_cast`)
- Плохо читается в больших программах

```c++
double x = 3.14;
int y = (int)x;  // C-style cast
```

#### Статическое преобразование `static_cast<type>(expr)`

Безопасное и проверяемое преобразование типов  

##### Когда использовать  
- Преобразования между числовыми типами
- Приведения между указателями на родительский (base) и дочерний (derived) классы
- Преобразования `void*` в другой указатель

```c++
// Числовые преобразования
double x = 3.14; 
int y = static_cast<int>(x); // Ок, отбрасывает дробную часть

// Преобразование указателей (безопасное)
class Base {};
class Derived : public Base {};
Derived d;
Base* basePtr = &d;  
Derived* derivedPtr = static_cast<Derived*>(basePtr);
```


#### Реинтерпритация `reinterpret_cast<type>(expr)`

Низкоуровневое приведение типа (небезопасное)  

##### Когда использовать
- Только для низкоуровневого кода (например, работа с памятью, драйверами, сериализацией
- Приведения между указателями несовместимых типов
- Превращения указателя в int и обратно

##### Почему опасно
- Может привести к неопределённому поведению, если типы несовместимы
- Нарушает строгую типизацию C++


```c++
// Преобразование между указателями
int a = 42;
void* ptr = &a;
int* intPtr = reinterpret_cast<int*>(ptr);  // Ок, но опасно!

// Указатель в `int` и обратно
int* p = new int(10);
uintptr_t addr = reinterpret_cast<uintptr_t>(p);  // Указатель → число
int* q = reinterpret_cast<int*>(addr);  // Число → указатель

```

#### Модификация констант `const_cast<type>(expr)`

Убирает или добавляет `const` у объекта. Используется, если нужно изменить `const`-объект, но не работает с `const`-объектами в `ROM` (постоянной памяти)

##### Когда использовать  
- Если функция требует `non-const` указатель, но изменение не планируется

##### Почему опасно
- Если объект реально `const`, изменение может привести к неопределённому поведению (UB)

```c++
// Удаление `const` (опасно)
void modify(int* p) {
    *p = 100;  // Меняем значение
}
const int num = 42;
modify(const_cast<int*>(&num));  // ОПАСНО, UB если num в read-only памяти!

// Используется в методах классов
class Example {
public:
    void print() const {
        const_cast<Example*>(this)->modify();  // Убираем const внутри const-метода
    }
    void modify() { /* Изменяем объект */ }
};
```


#### Динимическое преобразование `dynamic_cast<type>(expr)`

Безопасное приведение указателей в иерархии классов. Используется только с полиморфными классами (`Base` с виртуальными функциями)

##### Когда использовать
- Когда нужно проверить тип во время выполнения

```c++
// Преобразование родительского класса в дочерний (безопасно)
class Base { public: virtual ~Base() {} };
class Derived : public Base {};

Base* b = new Derived();
Derived* d = dynamic_cast<Derived*>(b);

if (d) {
    std::cout << "Преобразование успешно!" << std::endl;
} else {
    std::cout << "Ошибка: b не является Derived" << std::endl;
}
```

### Умные указатели

**Умные указатели** в C++ — это объекты, которые управляют временем жизни других объектов, автоматически освобождая память, когда объект больше не нужен. Умные указатели помогают избежать проблем с утечками памяти и ошибками с доступом к освобождённой памяти (например, ошибки "висячих указателей").

### **Типы умных указателей**

1. **`std::unique_ptr`**
    
    - **Назначение**: Управляет объектом, которому предоставляется уникальный доступ. Один `unique_ptr` может владеть объектом, но не может быть скопирован или передан другому объекту. Этот указатель автоматически уничтожает объект, на который он указывает, когда выходит из области видимости.
    - **Основные операции**:
        - Перемещение: объект может быть перемещён в другой `unique_ptr` с помощью оператора `std::move()`.
        - Доступ к объекту: через операторы `*` и `->`.
    - **Когда использовать**: Используется, когда нужно обеспечить, чтобы объект был создан и уничтожен только одним указателем, избегая копирования.
    
    Пример:
    
    cpp
    
    КопироватьРедактировать
    
    `#include <memory>  void example() {     std::unique_ptr<int> ptr1 = std::make_unique<int>(10);     // std::unique_ptr<int> ptr2 = ptr1; // Ошибка: нельзя копировать unique_ptr     std::unique_ptr<int> ptr2 = std::move(ptr1); // Перемещение ptr1 в ptr2 } // ptr2 автоматически удаляет объект, когда выходит из области видимости`
    
2. **`std::shared_ptr`**
    
    - **Назначение**: Умный указатель, который позволяет нескольким объектам совместно владеть одним и тем же объектом. Счётчик ссылок отслеживает количество `shared_ptr`, которые ссылаются на объект, и объект уничтожается, когда счётчик ссылок становится равным нулю.
    - **Основные операции**:
        - Копирование: `shared_ptr` можно копировать, и все копии будут совместно владеть объектом.
        - Доступ к объекту: через операторы `*` и `->`.
        - Счётчик ссылок: количество ссылок отслеживается автоматически, и объект удаляется, когда ссылки на него больше не существуют.
    - **Когда использовать**: Используется, когда объект должен быть доступен нескольким владельцам и уничтожаться только тогда, когда все они перестают ссылаться на объект.
    
    Пример:
    
    cpp
    
    КопироватьРедактировать
    
    `#include <memory> #include <iostream>  void example() {     std::shared_ptr<int> ptr1 = std::make_shared<int>(20);     std::shared_ptr<int> ptr2 = ptr1; // ptr1 и ptr2 совместно владеют объектом     std::cout << *ptr1 << std::endl; // 20 } // Объект будет удалён, когда ptr1 и ptr2 выйдут из области видимости`
    
3. **`std::weak_ptr`**
    
    - **Назначение**: Используется в связке с `std::shared_ptr` для предотвращения **циклических ссылок** (когда два или более объекта ссылаются друг на друга через `shared_ptr`).
    - **Основные операции**:
        - `weak_ptr` не увеличивает счётчик ссылок и не владеет объектом, поэтому он не препятствует удалению объекта.
        - Для получения доступа к объекту, на который ссылается `weak_ptr`, используется метод `lock()`, который возвращает `shared_ptr` или `nullptr`, если объект был уничтожен.
    - **Когда использовать**: Когда нужно создать ссылку на объект, но не препятствовать его удалению, например, в случаях циклических зависимостей.
    
    Пример:
    
    cpp
    
    КопироватьРедактировать
    
    `#include <memory> #include <iostream>  void example() {     std::shared_ptr<int> ptr1 = std::make_shared<int>(30);     std::weak_ptr<int> weakPtr = ptr1; // weak_ptr не увеличивает счётчик ссылок          if (auto lockedPtr = weakPtr.lock()) { // Попытка получить shared_ptr         std::cout << *lockedPtr << std::endl; // 30     } else {         std::cout << "Object has been deleted" << std::endl;     } } // Объект будет удалён, когда ptr1 выйдет из области видимости`
    

### **Преимущества умных указателей**

4. **Автоматическое управление памятью**: Умные указатели автоматически освобождают память, предотвращая утечки памяти, которые могут возникнуть при ручном управлении памятью с использованием `new` и `delete`.
    
5. **Безопасность**: Умные указатели делают код более безопасным, исключая ошибки, такие как использование висячих указателей, двойное освобождение памяти и утечки.
    
6. **Удобство работы с динамическими данными**: Умные указатели позволяют легко управлять динамически выделенной памятью, особенно в сложных структурах данных и многозадачных приложениях.
    
7. **Поддержка исключений**: Умные указатели правильно работают при выбрасывании исключений, автоматически освобождая память в случае выхода из области видимости, что делает их удобными для безопасной работы с исключениями.
    

### **Когда использовать каждый тип умного указателя?**

8. **`unique_ptr`**:
    
    - Когда требуется уникальное владение объектом, и объект не должен быть скопирован.
    - Например, в случае работы с ресурсами, которые должны быть освобождены только один раз (например, файлы, сетевые соединения).
9. **`shared_ptr`**:
    
    - Когда объект должен иметь несколько владельцев, и нужно отслеживать количество ссылок на объект.
    - Например, в случае работы с общими данными, которые могут быть использованы несколькими частями программы.
10. **`weak_ptr`**:
    
    - Когда нужно избежать циклических зависимостей, например, в случае графов или деревьев, где элементы могут ссылаться друг на друга, но не должны препятствовать удалению объектов.

