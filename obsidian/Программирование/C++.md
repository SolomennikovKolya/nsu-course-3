
### Полезности
- [Руководство по C++](https://metanit.com/cpp/tutorial/)

### Подключение библиотек

#### Статические библиотеки

**Статические библиотеки** (с расширением `.lib` на Windows и `.a` на Linux и macOS) компилируются и добавляются непосредственно в итоговый исполняемый файл. Таким образом, весь необходимый код библиотеки «встраивается» в приложение.

Подключение библиотеки:
1. Компиляция статической библиотеки
    - `gcc -c mylib.c -o mylib.o` сначала надо создать объектные файлы
    - `ar rcs libmylib.a mylib.o` затем добавить их к архиву (`.lib` или `.a` файл)
2. Подключение в коде
	- `#include "mylib.h"` - в исполняемом коде
3. Сборка с подключением библиотеки
    - На Linux и macOS указываем файл библиотеки через флаг `-l` и путь через `-L`
        `g++ main.cpp -L/path/to/library -lmylib -o myapp`
    - На Windows обычно указывается полный путь к `.lib` файлу в настройках компилятора (в Visual Studio) или аналогичным образом через командную строку
        `cl main.cpp /link /LIBPATH:C:\path\to\library mylib.lib`

#### Динамические библиотеки

**Динамические библиотеки** (с расширением `.dll` на Windows, `.so` на Linux и `.dylib` на macOS) загружаются в память во время выполнения программы. Это уменьшает размер исполняемого файла и позволяет обновлять библиотеку без перекомпиляции основного кода.

Подключение библиотеки:
1. Компиляция динамической библиотеки
    `g++ -fPIC -shared mylib.cpp -o libmylib.so`
2. Подключение в коде
    `#include "mylib.h"`
3. Сборка с подключением библиотеки
    - В Linux и macOS укажите путь к библиотеке с флагом `-L` и саму библиотеку с `-l`.
        `g++ main.cpp -L/path/to/library -lmylib -o myapp`
4. Запуск программы с динамической библиотекой
    - На Linux добавьте путь к библиотеке в переменную окружения `LD_LIBRARY_PATH` или разместите библиотеку в стандартном пути `/usr/lib` или `/usr/local/lib`
        `export LD_LIBRARY_PATH=/path/to/library:$LD_LIBRARY_PATH ./myapp`
    - На macOS используйте `DYLD_LIBRARY_PATH` или `install_name_tool` для установки пути к библиотеке
        `export DYLD_LIBRARY_PATH=/path/to/library:$DYLD_LIBRARY_PATH ./myapp`
    - На Windows: добавьте путь к `.dll` в `PATH` или поместите `.dll` в ту же директорию, где находится исполняемый файл приложения.

### Стандартные библиотеки

1. Динамическое подключение (`libc` на Linux или `msvcrt.dll` на Windows) позволяет:
	- **Сократить размер исполняемого файла**: Код стандартной библиотеки загружается отдельно, и нет необходимости включать его в каждый исполняемый файл.
	- **Обновлять библиотеку отдельно**: Обновления и исправления безопасности в библиотеке сразу доступны для всех программ, использующих её динамически.
	- Этот способ подключения используется по стандарту
	- Компилятор неявно линкует программу с libc

2. Статическое подключение (`libc.a` на Linux) позволяет:
	- **Программы, которые должны работать без зависимостей**: Например, для встроенных систем, где может не быть динамического загрузчика или где каждая зависимость должна быть включена в исполняемый файл.
	- **Обеспечение совместимости**: Если нужно гарантировать, что программа использует определённую версию стандартной библиотеки, её можно связать статически, чтобы избежать проблем с несовместимостью при запуске на другой системе.

Стандартная библиотека C++ это **`libstdc++`** на Linux или **`msvcprt.lib`** на Windows (не является частью libc)

### Сборка

Варианты сборки:
1. Тыкнуть кнопочку в IDE (неявно используется система сборки)
2. Вручную в терминале
3. Через make файлы (с помощью них можно автоматизировать рутинные задачи)
4. Через системы сбирки (например MSBuild, CMake)

#### Как написать кросплатформенное приложение на c++?
1. Использование кроссплатформенных библиотек (обеспечивает унифицированный доступ к системе и часто применяемым функциям)
	- **Qt**: Один из самых популярных кроссплатформенных фреймворков для C++. Qt предоставляет удобный и мощный API для создания GUI, работы с файлами, сетью и другими системными компонентами.
	- **Boost**: Набор библиотек, которые расширяют стандартный C++. В Boost есть библиотеки для работы с файловой системой, многопоточности, сетевых подключений, которые работают на Windows, macOS и Linux.
	- **SDL** (Simple DirectMedia Layer): Используется в основном для разработки мультимедийных и игровых приложений, предоставляет простой интерфейс для работы с графикой, звуком и вводом.
	- **SFML** (Simple and Fast Multimedia Library): Простая в использовании библиотека для разработки мультимедийных приложений и игр, поддерживает графику, звук, ввод с клавиатуры и мыши, работу с сетью.
2. Использование CMake для сборки
	- Позволяет писать один CMake-файл, который будет адаптирован для Windows, macOS и Linux.
	- А также автоматически генерировать файлы сборки для разных IDE (Visual Studio, Xcode) и систем сборки (make, Ninja).
3. Поддержка зависимости от ОС и адаптация к платформам
	- Использование препроцессорных директив `#ifdef`, чтобы разделить части кода в зависимости от платформы.
	- Использование платформенных макросов: `#ifdef _WIN32`, `#ifdef __linux__`, `#ifdef __APPLE__` и другие.
4. Контейнеризация и виртуализация для тестирования
	- Для тестирования кроссплатформенных приложений удобно использовать контейнеризацию и виртуализацию. Например, Docker позволит вам запускать приложение в Linux-контейнерах, а виртуальные машины, такие как VirtualBox или VMware, могут использоваться для запуска Windows и macOS-сред.

### Make

Специальные конструкции:
- `OBJECTS = $(SOURCES:.c=.o)` - создаёт список объектов (`OBJECTS`) на основе списка исходников (`SOURCES`). Это специальная форма замены суффиксов, которая позволяет преобразовать список файлов с расширением `.c` в соответствующие файлы с расширением `.o`
- `$(CC) -o $@ $^ $(LDFLAGS)`

Автоматические переменные:
- `$@` - ссылается на имя цели, которая будет создана. Например, если целью является `main`, то `-o $@` будет означать `-o main`
- `$^` - ссылается на все зависимости (или предшествующие файлы) для данной цели. Например, если цель зависит от `file1.o file2.o`, то `$^` будет равен `file1.o file2.o`
- `$<` — представляет первую зависимость в текущем рецепте.

### Cmake

Минимальный CMakeLists.txt для сборки программы:
```cmake
# Указываем минимальную версию CMake
cmake_minimum_required(VERSION 3.10)

# Задаем имя проекта
project(MyProject)

# Указываем стандарт C
set(CMAKE_C_STANDARD 99)

# Указываем исходный файл
set(SOURCES main.c)

# Создаем исполняемый файл из исходного файла
add_executable(MyExecutable ${SOURCES})
```
#### Как использовать
1. Поместите `CMakeLists.txt` в корневую директорию проекта (там же где и `main.c`)
2. Создайте папку для сборки (например, `build`) и перейдите в неё:
    - `mkdir build && cd build`
3. Выполните команду CMake для генерации файлов сборки:
    - `cmake ..`
4. Соберите проект с помощью:
    - `make`
    - Либо `cmake --build .`
1. После успешной сборки вы можете выполнить вашу программу:
    - `./MyExecutable`

#### Удобная работа с Cmake в VS Code
1. Установите расширения:
    - CMake Tools:
    - C/C++ (от Microsoft):
2. Настройка CMake:
    - Создайте файл `CMakeLists.txt` в корневом каталоге вашего проекта
3. Настройка конфигурации CMake:
    - Откройте палитру команд (`Ctrl+Shift+P`) и введите `CMake: Configure`. Выберите нужный генератор, например, `Ninja` или `Unix Makefiles`.
    - После этого CMake создаст необходимые файлы для сборки вашего проекта (make файлы и конфиги).
4. Сборка проекта:
    - Откройте палитру команд и выполните команду `CMake: Build`. Это создаст исполняемый файл в каталоге сборки (обычно `build`).
5. Запуск программы:
    - Для выполнения вашей программы можно создать конфигурацию запуска. Для этого создайте файл `.vscode/launch.json` в вашем проекте и добавьте следующее:
```json 
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug",
      "type": "cppdbg",
      "request": "launch",
      "program": "${workspaceFolder}/build/my_executable", // Замените на путь к вашему исполняемому файлу
      "args": [],
      "stopAtEntry": false,
      "cwd": "${workspaceFolder}",
      "environment": [],
      "externalConsole": false,
      "MIMode": "gdb",
      "setupCommands": [
        {
          "description": "Enable pretty-printing for gdb",
          "text": "-enable-pretty-printing",
          "ignoreFailures": true
        }
      ],
      "preLaunchTask": "build",
    }
  ]
}

```
6. shortcuts:
	- `F7` - build
	- `shift + F5` - build + debug
	- `F5` - build + debug

### Связывание

#### Виды связывании

- **Внешнее связывание (External linkage)**:
    - Переменные и функции с внешним связыванием доступны из других файлов, которые включают соответствующие заголовочные файлы.
    - По умолчанию внешнее связывание имеют глобальные переменные и функции.
    - Пример:
	    - `int globalVar;`
	    - `void func() {}`
	- Чтобы явно указать, что переменная или функция определена в другом файле можно использовать ключевое слово `extern`.
        
- **Внутреннее связывание (Internal linkage)**:
    - Переменные и функции с внутренним связыванием доступны только в пределах одного файла, в котором они определены.
    - Это достигается с помощью ключевого слова `static`.
    - Пример:
        - `static int localVar;`
        - `static void localFunc() {}`
        
- **Отсутствие связывания (No linkage)**:
    - Локальные переменные, объявленные внутри функции, имеют отсутствие связывания. Они доступны только в пределах данной функции.
    - Пример:
        - `void func() { int localVar; }`

#### Дополнительные свойства static для переменных
1. Продолжительность жизни:
	- Переменные, объявленные как `static`, сохраняют своё значение между вызовами функций. Это означает, что они существуют в течение всей жизни программы, а не только во время выполнения функции, в отличие от обычных локальных переменных.
2. Область видимости
	- Для глобальных переменных: Статическая переменная, объявленная на глобальном уровне, будет доступна только внутри файла, где она была объявлена. Она не видна в других файлах, даже если они подключены через `#include`. Это предотвращает доступ к ней извне, улучшая модульность.
	- Для локальных переменных: Статическая переменная внутри функции будет иметь область видимости только в пределах этой функции, но при этом её значение сохраняется между вызовами.
3. Инициализация
	- Переменные, объявленные static, инициализируются только 1 раз, даже если функция с инициацией вызывается много раз. 
	- Напрмер `void f() { static int var = 0; }` присваивает var = 0 только при первом запуске `f()`

#### Замечание!

Если функция не объявлена как `static`, она по умолчанию имеет ВНЕШНЕЕ СВЯЗЫВАНИЕ. Если другой файл знает сигнатуру функции (то есть её имя, возвращаемый тип и параметры), он может объявить прототип функции и затем вызывать её, даже если функция определена в другом исходном файле. Например:
```c
// Файл func.c
void myFunction() {     
	// Реализация 
}
```
```c
// Файл main.c
void myFunction(); // Объявление прототипа вручную
int main() {
	myFunction(); // Вызываем myFunction из func.c
	return 0;
}
```

### Volatile

Ключевое слово `volatile` в C и C++ указывает компилятору, что значение переменной может изменяться в любой момент времени не по ходу выполнения программы (например, за счет другого потока, оборудования или операционной системы). Оно говорит компилятору:
1. Не оптимизировать доступ к этой переменной — компилятор не должен кэшировать значение переменной в регистре, а должен всегда считывать её значение из памяти.
2. Каждый доступ к переменной должен выполняться напрямую из оперативной памяти, даже если до этого её значение было считано ранее.

Использование `volatile` важно, например, когда переменные могут быть изменены:
- **Аппаратурой** (например, регистры оборудования).
- **Обработчиками сигналов** (например, обработчики прерываний, изменяющие переменные в ответ на события).
- **Другими потоками** (например, переменные, используемые в многопоточности, хотя в таких случаях часто требуется и дополнительная синхронизация, например с помощью `mutex`).

#### Пример использования
```c
volatile int flag = 0;

void wait_for_flag() {
    while (flag == 0) {
        // Ждем, пока flag станет ненулевым
    }
    // Код продолжает выполнение после изменения flag
}

```

#### Замечание
- volatile не решает проблему гонки ресурсов в многопоточных программах.
- Использование volatile не делает операции над переменной атомарными.

### Завершение программы 

|Функция|Описание|
|---|---|
|`exit()`|Завершает программу, вызывает функции завершения (например, зарегистрированные через `atexit`).|
|`_Exit()`|Немедленно завершает процесс без выполнения функций завершения.|
|`abort()`|Немедленно завершает программу, генерируя сигнал `SIGABRT` и создавая дамп ядра.|
|`return` в `main`|Завершает выполнение программы, возвращая код выхода.|
