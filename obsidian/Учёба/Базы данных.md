
### Полезности
- [Медия](https://www.nsumedia.ru/main_potok/third_course/fifth_semester/database)
- [Задания для проектов](https://docs.google.com/document/d/1UsIZY0JJKGaf0pqvZArv--NHtj9nrNa_/edit)
- [Описание проектов](https://docs.google.com/document/d/1VpRXyO9DVSKPxkdWEFubtaxEDkcxUzhv/edit)
- [Гугл-диск с материалами](https://drive.google.com/drive/folders/13y5gWCIQTiyg-9LlVB826phQJemk4dTV)
- [Гугл-диск лектора](https://drive.google.com/drive/folders/1aPrGo1XBiQedhvnALgVJL1Erz4aqQlRv)
- [БД, на которых тренироваться select запросы писать (логин: HR, пароль: HR)](http://84.237.50.81:8080/apex)
- [Интерактивный онлайн курс по SQL](https://sql-academy.org/ru)
- [Памятка/шпаргалка по SQL](https://habr.com/ru/articles/564390/)
- [Тесты от Караваева](http://ccfit.nsu.ru/~karavaev/)
- [Расписанные криты](https://docs.google.com/document/d/1wpYo1Z2Vdf6UEKxLWsjwzJg4qk71Tb_jR1LjvUL-M18/edit#heading=h.i4i47456z4u5)
- [Расписанные вопросы](https://docs.google.com/document/d/1YILTbuNEWH9YXQSVyxSdrL5twPLrPT-aOZzGKwQjSg0/edit)
- [Расписанные вопросы 2.0](https://docs.google.com/document/d/1XeZhV_EnHm8ttQPun7HxFKFl_9IcIPk4-iXFopq-w-U/edit)
- [localhost](http://localhost)
- [Гуглмит семинары](https://meet.google.com/izu-obbf-vyr)

### Тесты

#### Тренировочные тесты
- [Тесты 1 & 2](https://docs.google.com/forms/d/e/1FAIpQLSftTzNRV76ZmXtdrQcRH9CDDsvL3789nO-YcFQZ0MhIaWmeig/viewform)
- [Тесты 1 & 2 доп.](https://docs.google.com/forms/d/e/1FAIpQLSdOIDxjT-jBs8ms8jPF2t5TVnlvuvgrA137GieY4cQuSgU6HQ/viewform)
- [Тест 3](https://docs.google.com/forms/d/e/1FAIpQLSfrfL_1Pk5vMY-Xk0UJIyaph_xV5IvN--E5IXnkQEJVAEoE6w/viewform)
- [Тест 4](https://docs.google.com/forms/d/e/1FAIpQLSfvjvK4Eeg-Cxr-HtwlL0t3g58F2wXI7zBabbPTFi_bkudU2g/viewform)
- [Тест 5](https://docs.google.com/forms/d/e/1FAIpQLSf0JYrE9lZy7EQw51SIfq96A59VI_ruyvLPFE0Sc0n8dX_T-Q/viewform)
- [Тест 6](https://docs.google.com/forms/d/e/1FAIpQLSeiuzk8FTSroiivdO3dwtNPw4KQ9_1C9aRqJ4DVL3-RqhixOg/viewform)

#### Решённые тесты
- Тест 1
- [Тест 2](http://ccfit.nsu.ru/~karavaev/test2_2019.html)
- [Тест 3](http://ccfit.nsu.ru/~karavaev/test3_2019.html)
- [Тест 4](http://ccfit.nsu.ru/~karavaev/test4_2020.html)
- [Тест 5](http://ccfit.nsu.ru/~karavaev/test5_2020.html)
- [Тест 6](http://ccfit.nsu.ru/~karavaev/test6_2020.html)

### Практика

#### Что делать

Семестр 5:
1. Проект (сделать сайт для взаимодействия с БД)
2. КР по SQL (написать 3 select-а за 45 минут)
3. КР по SQL 2 (создание, удаление, заполнение БД)

Семестр 6:
1. Мини тест на 5 минут (остаточные знания по SQL)
2. Проект - приложение баз данных

#### Проект (сем 5)

Требования:
- Домашняя страница - index.html или index.php
- Должно быть связанное гипертекстовое пространство без тупиков (без необходимости пользования стрелочками)
- Кнопка для включения, которая делает следующее: если нет базы данных, то она создаёт и развёртывает, если база есть, то она далжна например пересоздаваться. Всё должно нормально работать вне зависимости от того, была создана база или нет
- Должна быть возможность указать адрес сервер, а также имя пользователя и пароль (для подключения к БД)
- Должны быть разные роли с разными возможностями
- Должны быть сортировки, фильтрации
- Интерфейс связанный, груглый, законченный
- Отчёт - в формате ворд. На всякий случай - записать видео демонстрацию
- Сдавать заархивированную папку, названную по фамилии и группе. Не должно быть поддиректорий. Нельзя - русские буквы. Не стоит закидывать отчёт и видео демонстрацию в архив (ножет не разархивироваться), лучше прикреплять отдельно

#### КР по SQL

Промпт для GPT:
```
У меня есть следующая схема базы данных:
Все таблицы: EMPLOYEES, JOBS, DEPARTMENTS, LOCATIONS, COUNTRIES, REGIONS, JOB_HISTORY.
Описание таблиц:
Колонки таблицы EMPLOYEES: EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, PHONE_NUMBER, HIRE_DATE, JOB_ID, SALARY, COMMISSION_PCT, MANAGER_ID, DEPARTMENT_ID.
Колонки таблицы JOBS: JOB_ID, JOB_TITLE, MIN_SALARY, MAX_SALARY.
Колонки таблицы DEPARTMENTS: DEPARTMENT_ID, DEPARTMENT_NAME, MANAGER_ID, LOCATION_ID.
Колонки таблицы LOCATIONS: LOCATION_ID, STREET_ADDRESS, POSTAL_CODE, CITY, STATE_PROVINCE, COUNTRY_ID.
Колонки таблицы COUNTRIES: COUNTRY_ID, COUNTRY_NAME, REGION_ID.
Колонки таблицы REGIONS: REGION_ID, REGION_NAME.
Колонки таблицы JOB_HISTORY: EMPLOYEE_ID, START_DATE, END_DATE, JOB_ID, DEPARTMENT_ID.
Напиши SQL запрос чтобы решить следующее задание:
<ЗАДАНИЕ>
```

#### КР по SQL 2

Команды:
- `mysql -u username -p` - подключиться к mysql через консоль. Вместо username - имя пользователя (обычно root). Потом надо вбить пароль
- `SOURCE путь_к_файлу/script.sql;` - выполнить sql скрипт

#### Проект (сем 6)

Цель - сделать приложение баз данных

Оценка - баллы. Очень желательно набрать побольше баллов по проекту, чтобы на экзамене не задушнили. Баллы ставятся за:
- Промежуточные этапы (первичное построение системы, интерфейсы, авторизация...) - примерно половина баллов
- Переосмысление и финальная сдача всего проекта - ещё половина баллов

Требования:
- Надо самому придумать приложение либо взять один из предложенных вариантов. Предложенные варианты задачи не идеален, поэтому надо доработать и прорабоать её, чтобы была система богатая на разные взаимодействия
- Схема должна содержать как минимум 6 сущностей с атрибутами разных типов. Некоторые сущности должны находиться в отношении категоризации
- Должна быть роль администратор и ещё как минимум 2 другие роли. Для каждой роли - свой интерфейс
- То, что имеет смысл переносить на сервер, переносим на сервер
- Желательно показать навык владения механизмом транзакций
- Система безопасности (для каждой роли - свои права)

### Команды

#### Старый стек технологий (Apache + PHP + MySQL)
- Далее описана работа с БД, установленной по [этому гайду](https://hackware.ru/?p=21)
- Директории:
	- `C:\Server\data\DB\data\<название схемы>\<название таблицы>` - расположение данных БД
	- `C:\Server\data\htdocs` - расположение веб-страниц
- Команды
	- `httpd.exe -k start` - запуск Apache веб-сервера
	- `net start mysql` - запуск MySQL
	- `netstat -aon | findstr :80` - проверить, что Apache запущен (если он на порту 80)
	- `netstat -aon | findstr :3306` - проверить, что MySQL запущен (если он на порту 3306)
	- `services.msc` - убедиться, что службы `Apache2.4` и `MySQL` запускаются автоматически (если настроена автозагрузка)

#### Нормальный стек технологий (Python + JavaScript + MySQL + Docker)
- `mysql --version` - проверить, установлен ли MuSQL
- `net start | find "MySQL"` - проверить, запущен ли MySQL
- `net start MySQL80` - запустить службу MySQL
- `net stop MySQL80` - остановить MySQL
- `mysql -u root -p` - проверить подключение к серверу

### Инструменты

**MS Access** (Microsoft Access) - СУБД (система управления базами данных). Она предоставляет возможность создания и управления реляционными базами данных и интегрирует удобный пользовательский интерфейс для работы с базами данных.
- Хорошо подходит для небольших и средних приложений баз данных
- MS Access можно использовать как базу данных для приложений

**SQL** (Structured Query Language) — это язык структурированных запросов, используемый для управления и взаимодействия с реляционными базами данных. 
- SQL является стандартным языком для выполнения операций над базами данных, таких как создание, модификация и извлечение данных
- Пример: `SELECT * FROM employees WHERE age > 30;`

**Apache HTTP Server** (Apache Web Server) - веб-сервер, предназначенный для обслуживания веб-сайтов и веб-приложений. Поддерживает динамический контента через языки программирования, такие как PHP, Python, Perl.
- `htdocs` - Это корневая директория веб-сервера Apache, установленного вместе с MAMP. Любые файлы, размещенные в этой директории, становятся доступными для просмотра через браузер по URL, например, `http://localhost/yourfile.php`. Но не обязательно все вэб страницы размещать именно в htdocs (наприимер Apache и так знает, где искать phpMyAdmin)
- Если в папке `htdocs` находится файл с именем **`index.html`** (или **`index.php`**), сервер автоматически откроет и отобразит этот файл, когда вы перейдете по адресу `http://localhost`.

**PHP** - серверный язык программирования, который отвечает за бэкенд.
- Хорошо подходит для подходит для веб-разработки
- Интеграция с базами данных

**MySQL** — система управления базами данных (СУБД).

**phpMyAdmin** — инструмент для управления базами данных через веб-интерфейс. 

**Antares** - SQL клиент (ПО, которое позволяет пользователям подключаться к СУБД и выполнять SQL-запросы). Это графический интерфейс для работы с СУБД

**MAMP** (Macintosh, Apache, MySQL, PHP) — это набор программного обеспечения, который позволяет легко развернуть локальный сервер для разработки веб-приложений на компьютере. Основное предназначение MAMP — создание локальной среды разработки, где можно разрабатывать, тестировать и запускать веб-приложения без необходимости подключения к удалённому серверу.

#### Схема работы:
- БД - хранит данные
- СУБД (например MySql) - система, чтобы управлять БД
- Интерфейс (например phpMyAdmin или Antares) - чтобы удобно работать с СУБД (а не вручную через SQL запросы). phpMyAdmin — это веб-приложение, которое использует элементы управления в браузере. Чтобы веб-приложение работало нужен веб-сервер. Другой GUI - это Antares, и для него не нужен веб-браузер, так как он работает через свой GUI. 
- Веб-сервер (например Apache) - нужен для обработки запросов от браузера. Он может обрабатывать PHP код и отправлять HTML файлы обратно браузеру, которые он в свою очередь может отобразить.
- PHP - для реализации логики работы сайта.

### Базовые определения

**Данные** - это совокупность сведений (информация), представленная в формализованном виде, пригодном для передачи, интерпретации или обработки с участием человека или автоматическими средствами.
- Например: книги, картинки, ДНК и т.д.
- Данные - фиксированные сведения о событиях и явлениях, которые хранятся на определенных носителях

**Информация** – любой  вид знаний о предметах, фактах, понятиях и т. д. проблемной области, которыми обмениваются пользователи информационной системы.
- Например, данные 36,8 могут означать и температуру и размер некоторого объекта
- Информация появляется в результате обработки данных при решении конкретных задач

**Предметная область** - часть реального мира, для которой создается информационная система.

**База данных** (БД) - набор связанных данных.

**Система управления базой данных** (СУБД или Database Management System) - пакет программ, обеспечивающих средства создания и манипулирования базой данных на ЭВМ.

**Система базы данных** (Database System) - пакет программ СУБД вместе с данными. Иногда в систему базы данных включают и приложения.

### Схемы

**Схема (schema)** — это структурное описание базы данных (скелет базы данных). В MySQL схема является синонимом базы данных. У каждой базы данных есть владелец, который по умолчанию — это пользователь, создавший базу данных.
В большинстве СУБД, таких как MySQL, PostgreSQL, MariaDB, и других, схема включает в себя:
- **Таблицы**: Основные структуры для хранения данных.
- **Столбцы**: Определяют типы данных в каждой таблице.
- **Ключи**: Первичные и внешние ключи, которые помогают управлять связями между таблицами.
- **Ограничения**: Например, уникальные или NOT NULL ограничения на столбцы.
- **Индексы**: Для ускорения поиска данных.
- **Представления (views)**: Виртуальные таблицы, которые хранятся как результаты SQL-запросов.
- **Функции и процедуры**: Для автоматизации и выполнения задач.

Отличия схемы и отношения:
- Схема это формальное описание структуры таблицы (она не содержит данных)
- Отношение является динамическим элементом, который содержит реальные данные.

### Системные БД

| База данных              | Описание                                                                                            | Назначение                                                                        | реальная / виртуальная |
| ------------------------ | --------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- | ---------------------- |
| **`information_schema`** | Метаданные обо всех объектах баз данных (таблицы, столбцы, индексы и т.д.).                         | Получение информации о структуре баз данных, их объектах и конфигурации.          | виртуальная            |
| **`mysql`**              | Системная база данных MySQL, содержащая пользователей, права доступа и конфигурации.                | Управление пользователями, правами и настройками MySQL.                           | реальная               |
| **`performance_schema`** | Метрики производительности MySQL, данные о событиях, запросах и потоках.                            | Мониторинг производительности и диагностика узких мест.                           | реальная               |
| **`sys`**                | Агрегированные данные о производительности на основе `performance_schema` с упрощённым интерфейсом. | Упрощённый мониторинг производительности и состояния системы для администраторов. | виртуальная            |
Это системные базы данных, которые содержат метаданные о самой системе

**Словарь данных** — это специальная структура, которая хранит метаданные о базе данных, т.е. информацию о её структуре, таблицах, атрибутах, типах данных, ограничениях, ключах, отношениях между таблицами и других элементах схемы БД. Это своего рода "справочник" для системы управления базами данных (СУБД), который помогает ей управлять данными и обеспечивать целостность и безопасность. В mysql словарь это `information_schema`

### Ключи

**Первичный ключ** (primary key) — это одно или несколько полей (столбцов) в таблице базы данных, которые уникально идентифицируют каждую запись (строку) в этой таблице.

**Внешний ключ** (foreign key) — это поле (или набор полей) в таблице базы данных, которое ссылается на первичный ключ (или уникальный ключ) в другой таблице. Внешний ключ служит для создания связи между двумя таблицами в реляционной базе данных, поддерживая целостность данных.

#### Рекомендации
- Каждое отношение (таблица) должна содержать первичный ключ для обеспечения уникальности и идентификации
- Для связи отношений надо использовать первичные и внешние ключи для обеспечения целостности данных

### Индексы

|Тип индекса|Описание|Уникальные значения|Может содержать `NULL`|Основное применение|
|---|---|---|---|---|
|**PRIMARY**|Первичный ключ|Да|Нет|Уникальная идентификация записей|
|**INDEX**|Обычный индекс|Нет|Да|Оптимизация поиска и сортировки|
|**UNIQUE**|Уникальный индекс|Да|Да, но только один `NULL`|Гарантия уникальности значений|
|**FULLTEXT**|Полнотекстовый индекс|Нет|Да|Поиск по текстовым данным|
Индексы обеспечивают быстрый поиск и сортировку за счёт того, что для каждого индекса создаётся отдельная структура данных (Б-дерево или хэш-таблица), которая хранит в узлах само значение индекса и ссылку на соответствующую строку в таблице
- С индексом - скорость O(logN)
- Без индекса - скорость O(N)

В случае **кластерных индексов** (clustered index), данные в самой таблице физически хранятся в отсортированном порядке на основании значения ключа. В таблице может быть только один кластерный индекс, поскольку он определяет физический порядок данных.

### Целостность

**Целостность базы данных** — это свойство базы данных, которое гарантирует корректность, достоверность и согласованность данных в ней. Целостность базы данных достигается за счет использования определенных ограничений и правил, которые накладываются на данные, чтобы избежать ошибок, дубликатов, нарушений связей и других несоответствий. Эти ограничения обеспечивают, что данные остаются точными и логически правильными в любой момент времени.

#### Основные типы целостности данных:
1. **Целостность сущностей (Entity Integrity)** - Гарантирует, что каждая запись в таблице уникально идентифицируется с помощью первичного ключа (Primary Key).
2. **Целостность ссылок (Referential Integrity)** - Поддерживает правильность связей между таблицами, особенно когда одна таблица ссылается на другую с помощью внешних ключей (Foreign Keys). Целостность ссылок гарантирует, что каждая ссылка (внешний ключ) в одной таблице имеет соответствующее значение в другой таблице.
3. **Целостность доменов (Domain Integrity)** - Гарантирует, что значения в поле соответствуют допустимому диапазону или типу данных. Это достигается за счет определения типов данных для полей, а также возможного использования ограничений (constraints) и проверок (check constraints).
4. **Целостность данных на уровне приложения (Application Integrity)** - Это дополнительный уровень целостности, который может быть реализован на уровне бизнес-логики в приложении, работающем с базой данных. Целостность данных может проверяться приложением, чтобы гарантировать корректность операций, которые не всегда можно контролировать через SQL-запросы или схемы базы данных.

#### Как обеспечивается целостность:
1. **Ограничения (Constraints)**: Это правила, которые накладываются на поля и таблицы. К ним относятся:
    - PRIMARY KEY — для целостности сущностей.
    - FOREIGN KEY — для поддержания ссылочной целостности.
    - UNIQUE — для обеспечения уникальности значений.
    - CHECK — для проверки доменных значений.
    - NOT NULL — для предотвращения появления `NULL` в обязательных полях.
2. **Триггеры (Triggers)**: Это специальные процедуры, которые автоматически выполняются при добавлении, обновлении или удалении данных, чтобы гарантировать соблюдение правил целостности.
3. **Хранимые процедуры (Stored Procedures)**: Процедуры могут использоваться для проверки и соблюдения бизнес-правил на уровне базы данных.

### SQL

**SQL** (Structured Query Language / язык структурированных запросов) — это специализированный язык для взаимодействия с реляционными базами данных. Он используется для управления данными, их обработки, а также для создания, изменения и администрирования баз данных

#### Особенности
- *Декларативность*: Пользователь указывает, что сделать, а не как это сделать
- *SQL не является истинно реляционным языком*
	- Допущение строк-дубликатов в таблицах и результатах выборок
	- Поддержка NULL, создающая фактически многозначную логику
	- Возможность ссылок на столбцы по номерам (в реляционной модели столбцы должны быть равноправны)
	- Допущение столбцов без имени, дублирующихся имён столбцов
- *Стандартизация*: SQL разработан и стандартизирован международными организациями. Это обеспечивает его универсальность, хотя разные базы данных добавляют свои расширения и изменения, из за чего появляются диалекты языка, специфичные для каждой конкретной СУБД
- При выполнении любой SQL-команды в любой RDBMS (Relational Database Management System) система определяет наилучший способ выполнения запроса, а движок SQL определяет способ интерпретации задачи
- Использование верхнего регистра в названиях команд SQL — это всего лишь соглашение, большинство СУБД нечувствительны к регистру

#### Интересные детали

##### Структура SQL и его подмножества
1. *DDL* (Data Definition Language): Отвечает за создание и изменение структуры объектов базы данных (таблицы, индексы и т.д.)
2. *DML* (Data Manipulation Language): Отвечает за операции с данными внутри таблиц
3. *DCL* (Data Control Language): Используется для управления доступом к данным (назначение прав и ролей)
3. *TCL* (Transaction Control Language): Управляет транзакциями в базе данных, обеспечивая целостность данных при выполнении групп операций

##### Структура БД
- *Данные* содержатся в *таблицах*
- *Таблицы* сгруппированы в *схемы*
- *Схемы* располагаются в *каталогах*
- *Каталоги* могут быть сгруппированы в *кластеры*

##### Уровни стандартизации SQL
1. *Основной уровень*: Это минимальный набор функций, который должна поддерживать каждая совместимая СУБД
2. *Дополнительные уровни*: Они определяют расширенные возможности SQL, которые могут быть поддержаны не всеми СУБД
3. *Типовые профили SQL*: Стандарт описывает профили совместимости, которые определяют, какие функции обязательны для разных уровней
4. *Диалекты SQL*: Несмотря на стандарты, разные СУБД добавляют свои собственные расширения, что приводит к созданию диалектов SQL

##### Способы работы с SQL
- *Интерактивный SQL*: Пользователь напрямую формирует запросы в консоли или интерфейсе SQL-клиента. Используется для выполнения разовых операций, анализа данных или отладки запросов
- *Программный SQL*: Формирование запроса на языке SQL в прикладной программе
	- *Статический SQL*: Запросы заранее известны и жестко прописаны в коде программы
	- *Динамический SQL*: Запросы формируются на этапе выполнения программы в зависимости от условий
	- *Интерфейсы вызова подпрограмм*: Использование специальных библиотек или функций для работы с SQL внутри программы

##### Способы встраивания в языками программирования
- *Embedded SQL*: SQL-запросы включаются непосредственно в код программы
- *Dynamic SQL*: Запросы формируются и выполняются в процессе выполнения программы
- *API*: Программы используют библиотеки API для взаимодействия с базой данных
	- API ориентирован на конкретную СУБД
	- API межплатформенный (универсальный способ подключения к различным СУБД)
- *Object-Relational Mapper*: Инструмент, который абстрагирует работу с базой данных, представляя строки таблиц как объекты языка программирования

##### Права доступа 

**Владелец схемы** — это пользователь или роль, которая изначально создала эту схему. 
- Владелец автоматически получает полный доступ ко всем объектам, находящимся в схеме, и может управлять доступом других пользователей (команды `GRANT` и `REVOKE`), чтобы они смогли читать или изменять данные в схемах
- Назначение владельца зависит от СУБД (в MySQL схема принадлежит пользователю, который создал базу данных)

Большинство СУБД позволяют настроить детализированные права доступа на уровне:
1. *Схемы* — доступ ко всем таблицам и объектам в схеме
2. *Таблицы* — доступ только к конкретной таблице
3. *Колонок* — доступ только к отдельным колонкам в таблице (в некоторых СУБД)
4. *Операций* — разрешение определенных операций

##### Сеансы и пользователи

**SQL-агент** - субъект, который выдаёт SQL-команды. SQL-агент обеспечивает автоматизацию заданий, но не является посредником для подключения пользователей к базе данных (пользователи подключаются напрямую к СУБД)

**Authorization ID** — это идентификатор авторизации, который используется в СУБД для определения прав доступа пользователя или роли к различным объектам базы данных (например, схемам, таблицам, представлениям, процедурам)
- СУБД использует Authorization ID для проверки того, какие действия пользователь может выполнять
- Authorization ID активен на протяжении всей сессии работы с базой данных
- Обычно определяется во время аутентификации, когда пользователь вводит свои учетные данные
- В системах с поддержкой ролей Authorization ID может быть связано с несколькими ролями, каждая из которых предоставляет дополнительные права

##### SQLCODE

Переменная **`SQLCODE`** — это системная переменная, используемая в реляционных базах данных, для хранения кода состояния последней выполненной SQL-операции. Используется для обработки ошибок в приложениях или процедурах, работающих с базой данных

Примеры значений:
1. Положительные значения - означают успешное выполнение запроса, но с предупреждением. Например:
    - `+100`: Указатель на то, что запрос не вернул ни одной строки (в DB2 и других системах это означает `NO DATA FOUND`)
2. Нулевое значение - указывает, что SQL-операция выполнена успешно.
    - `0`: Успех без предупреждений.
3. Отрицательные значения - указывают на ошибку выполнения SQL-запроса. Например:
    - `-803`: Нарушение уникального ограничения (дублирование значения)
    - `-104`: Синтаксическая ошибка в SQL-запросе
    - `-911`: Транзакция прервана из-за deadlock

#### Команды

##### Инструкции из DML
- SELECT – «поиск» данных в БД
- INSERT – добавление строк в таблицу БД
- DELETE – удаление строк из таблицы БД
- UPDATE – изменение строк в таблице БД

Особенности SELECT:
- Может просто выводить числа, строки и т.д. (`SELECT "Hello world"`)
- `*` - всё из таблицы (`SELECT * FROM Trip`)
- Вывод определённых столбцов (`SELECT town_from, town_to FROM Trip`)
- `AS` - замена названия столбца в ответе (`SELECT town_from, town_to AS t FROM Trip`)

Порядок выполнения инструкций для:
`SELECT столбцы FROM таблица [WHERE условия_фильтрации] [GROUP BY столбцы_группировки] [HAVING условия_для_групп] [ORDER BY столбцы_сортировки];`
1. Выполняется раздел FROM
2. Выполняется раздел WHERE
3. Выполняется раздел GROUP BY
4. Выполняется раздел HAVING
5. Выполняются определения в разделе SELECT
6. Выполняются операторы UNION/INTERCEPT/EXCEPT
7. Выполняется раздел ORDER BY

##### Инструкции из DDL
- `CREATE` - создание новых объектов в базе данных (таблицы, индексы, представления)
- `ALTER` - изменение существующей структуры базы данных или объектов (добавления, изменения или удаления столбцов в таблице)
- `DROP` - удаление объектов базы данных (таблицы, индексы, БД). При этом все данные, связанные с этим объектом, удаляются
- `TRUNCATE` - удаляет все строки из таблицы, но не удаляет саму таблицу. Это более быстрый способ очистки таблицы, чем использование команды `DELETE`, так как не фиксируются изменения для каждой строки

##### Инструкции из DCL
- `GRANT`
- `REVOKE`

##### Инструкции из TCL
- `COMMIT`
- `ROLLBACK`
- `SAVEPOINT`

##### Операторы

**Оператор** — это ключевое слово или символ, которые, в основном, используются в инструкциях `WHERE` для выполнения каких-либо операций. Они используются как для определения условий, так и для объединения нескольких условий в инструкции

Классификация:
- *Арифметические операторы*: `+`, `-`, `*`, `/`, `%`
- *Операторы сравнения*: `=`, `!=`, `<>`, `>`, `<`, `>=`, `<=`, `!<`, `!>`
- *Логические операторы*: 
	- `AND` - Объединяет условия (все условия должны совпадать)
		- Пример: `SELECT * FROM employees WHERE salary > 500 AND department_id = 3;`
	- `OR` - Комбинирует условия (одно из условий должно совпадать)
	- `NOT` - Инвертирует смысл других логических операторов
	- `IS NULL` - Определяет, является ли значение нулевым
	- `IN` - Выполняет поиск значения в списке значений
		- Пример: `SELECT * FROM employees WHERE department_id IN (1, 2, 3);`
	- `ALL` - Сравнивает все значения
		- Пример: `SELECT * FROM products WHERE price > ALL (SELECT price FROM products WHERE category = 'Electronics');` - Запрос выберет все товары, цена которых больше цены всех товаров из категории "Electronics"
	- `ANY` - Сравнивает одно значение с другим, если последнее совпадает с условием
		- Пример: `SELECT * FROM products WHERE price > ANY (SELECT price FROM products WHERE category = 'Books');` - Запрос выберет все товары, цена которых больше хотя бы одного товара из категории "Books"
	- `BETWEEN` - Проверяет вхождение значения в диапазон
		- Пример: `SELECT * FROM orders WHERE order_date BETWEEN '2024-01-01' AND '2024-12-31';` - Запрос выберет все заказы, которые были сделаны в 2024 году
	- `EXISTS` - Определяет наличие строки, соответствующей определенному критерию
		- Пример: `SELECT * FROM customers c WHERE EXISTS ( SELECT 1 FROM orders o WHERE o.customer_id = c.customer_id );` - апрос выберет всех клиентов, у которых есть хотя бы один заказ
	- `LIKE` - Ищет строки, которые соответствуют заданному шаблону.  Используются символы: `%` — любой набор символов, `_` — один любой символ
		- Пример: `SELECT * FROM employees WHERE name LIKE 'A%';` - Запрос выберет всех сотрудников, чье имя начинается с буквы "A"
	- `UNIQUE` - Проверяет, что значение в подзапросе является уникальным
		- Пример: `SELECT name FROM employees WHERE UNIQUE (SELECT department_id FROM employees);` - Запрос выберет имена сотрудников, если их `department_id` является уникальным

##### Встроенные функции

[Встроенная функция](https://sql-academy.org/ru/handbook) – реализованный в СУБД кусок кода, с помощью которого можно выполнять преобразования строковых, числовых и других данных в запросах.
Функции можно применять не только над литералами, но и над значениями, взятыми из таблицы. При этом функция выполняет преобразования для каждой строки отдельно

Некоторые функции:
- `TRUNCATE(num, decimals)` - Возвращает число, округлённое до указанного количества знаков после запятой путем отбрасывания последующих цифр
- `CAST(12005.6 AS DECIMAL)` - Конвертирует значение в указанный тип данных
- `IF(condition, value_if_true, value_if_false)` - Возвращает значение, переданное 2-ым или 3-им аргументом, в зависимости от истинности условного выражения
- `IFNULL(value, alternative_value)` - Возвращает значение, переданное 1-ым аргументом, если оно не равно NULL. В противном случае, возвращает значение переданное вторым аргументом
- `ISNULL(value)` - Возвращает 1 или 0 в зависимости равно ли выражение NULL
- `WITH name_cte [(column_1 [, column_2 ] …)] AS (subquery)` - Выражение с WITH определяет временный набор данных, который доступен для ссылки на него в последующих запросах

### Транзакции

**Транзакции** в СУБД — это набор операций с данными, которые выполняются как единое целое, и обладают важными свойствами, известными как ACID. Транзакции обеспечивают корректность и надежность работы с данными, гарантируя, что данные не окажутся в несогласованном или повреждённом состоянии, даже в случае сбоев
#### Основные свойства транзакций (ACID):
1. **Атомарность (Atomicity)**:
    - Транзакция — это неделимая операция. Либо все операции внутри транзакции выполняются полностью, либо ни одна не выполняется
    - Пример: Если транзакция состоит из двух шагов (например, перевод денег с одного счёта на другой), то либо оба шага выполнены (списание и зачисление), либо ничего не произошло
2. **Согласованность (Consistency)**:
    - Транзакция переводит базу данных из одного согласованного состояния в другое. Это означает, что после завершения транзакции все ограничения целостности (например, внешние ключи, уникальные индексы) должны быть соблюдены
    - Пример: Если перевод денег происходит, то сумма на двух счетах должна быть правильно обновлена, а целостность базы данных не нарушена
3. **Изолированность (Isolation)**:
    - Операции разных транзакций изолированы друг от друга, т.е. параллельные транзакции не должны влиять друг на друга до тех пор, пока одна из них не завершится (в идеале). В реальности изоляция может быть разной в зависимости от уровня изоляции, что позволяет балансировать между производительностью и целостностью данных
    - Пример: Если два пользователя одновременно пытаются снять деньги с одного счёта, одна транзакция завершится первой, и вторая будет "видеть" уже обновлённое состояние счёта
4. **Долговечность (Durability)**:
    - После успешного завершения транзакции (т.е. после выполнения команды COMMIT) изменения данных сохраняются на постоянной основе, даже в случае сбоя системы
    - Пример: После успешного перевода денег данные об этом переводе сохраняются, даже если сразу после этого произойдёт сбой в системе

Пример транзакции в SQL:
```sql
START TRANSACTION;

UPDATE accounts
SET balance = balance - 100
WHERE account_id = 1;  -- Списание со счёта 1

UPDATE accounts
SET balance = balance + 100
WHERE account_id = 2;  -- Пополнение счёта 2

COMMIT;  -- Фиксация изменений
```

#### Ролбек (откат) транзакции:

Если в процессе выполнения транзакции что-то пошло не так (например, произошла ошибка или сбой), СУБД может выполнить **откат транзакции** до исходного состояния, чтобы избежать частичного применения изменений.

```sql
START TRANSACTION; 

UPDATE accounts 
SET balance = balance - 100 
WHERE account_id = 1; 

-- Произошла ошибка или сбой 
ROLLBACK; -- Откат всех изменений
```

#### Уровни изоляции транзакций:

СУБД может предоставлять разные уровни изоляции транзакций, которые контролируют, как параллельные транзакции влияют друг на друга. Основные уровни изоляции:
1. **Read Uncommitted**: Транзакция может видеть данные, которые ещё не были зафиксированы другой транзакцией. Это самый низкий уровень изоляции, который допускает "грязное чтение".
2. **Read Committed**: Транзакция может видеть только те изменения, которые были зафиксированы другими транзакциями. Это предотвращает "грязное чтение", но допускает повторяющееся чтение.
3. **Repeatable Read**: Транзакция видит данные, которые были на момент её начала, даже если другие транзакции изменяют данные после этого. Однако это не защищает от "фантомных чтений".
4. **Serializable**: Наивысший уровень изоляции, где транзакции выполняются так, как если бы они были последовательными (одна за другой). Это предотвращает все виды аномалий, но значительно снижает производительность.

#### Транзакции необходимы, когда:
- Данные критичны: Финансовые операции, учёт товара, обновление баланса счетов и т.д. — любые ошибки могут привести к серьёзным последствиям.
- Есть риск параллельного изменения данных: Если несколько пользователей могут одновременно менять одни и те же данные, транзакции с механизмом блокировок или изоляцией предотвращают конфликты и неконсистентные состояния данных.
- Необходимость поддержания согласованного состояния: Например, в системах с несколькими таблицами, связанными внешними ключами, изменения в одной таблице требуют синхронного обновления связанных записей.

#### Виды транзакций

1. **Однофазная транзакция:**    
    - Простая транзакция, которая выполняется в одном узле или системе.
    - Включает команды BEGIN (начало), COMMIT (фиксация), ROLLBACK (отмена).
    - Применяется в базах данных, где транзакция затрагивает только одну систему.

2. **Двухфазная транзакция** (2PC — Two-Phase Commit)
	- Это протокол управления транзакциями, который обеспечивает их целостность и согласованность при работе с несколькими системами или узлами (например, в распределённых базах данных). 
	- Этот протокол состоит из двух этапов:
		1. **Фаза голосования** (Prepare Phase):
		    - Координатор транзакции отправляет запросы всем участникам (узлам или системам), чтобы узнать, готовы ли они выполнить транзакцию.
		    - Каждый участник проверяет возможность успешного выполнения транзакции, например, блокируя необходимые ресурсы, и возвращает один из ответов:
		        - OK (готов): узел готов зафиксировать изменения.
		        - FAIL (отказ): узел не может выполнить транзакцию (например, из-за ошибки или конфликта ресурсов).
		2. **Фаза фиксации** (Commit Phase):
		    - Если все участники ответили "OK", координатор отправляет команду `COMMIT` (зафиксировать транзакцию).
		    - Если хотя бы один участник ответил "FAIL", координатор отправляет команду `ROLLBACK` (отменить транзакцию) всем узлам.
	- Двухфазная транзакция гарантирует, что:
		- Либо транзакция будет выполнена всеми узлами.
		- Либо транзакция будет отменена на всех узлах.

3. **Трёхфазная транзакция** (3PC — Three-Phase Commit):
    - Улучшение двухфазного протокола, предназначенное для уменьшения блокировок и повышения отказоустойчивости.
    - Добавляется промежуточная фаза между подготовкой и фиксацией:
        1. **PREPARE** — участники уведомляют координатора, что готовы принять решение.
        2. **COMMIT-READY** — участники получают от координатора готовность к фиксации.
        3. **COMMIT/ABORT** — окончательное выполнение или отмена.
    - Лучше подходит для распределённых систем с потенциальными сбоями.

4. **Частичная транзакция** (Nested Transaction):
    - Состоит из основной транзакции и нескольких вложенных.
    - Каждая вложенная транзакция может фиксироваться или откатываться независимо от основной.
    - Используется для выполнения сложных операций с разными уровнями независимости.

5. **Долговременная транзакция** (Long-Lived Transaction):
    - Транзакции, которые выполняются длительное время (например, несколько часов или дней).
    - Используются в системах, где ресурсы нельзя блокировать на продолжительный период.
    - Обычно разбиваются на этапы с промежуточным сохранением состояния.

6. **Транзакция с компенсацией:**
    - Если откат транзакции невозможен (например, в реальном мире — переводы денег, отправка сообщений), применяется компенсация.
    - Компенсирующая транзакция "обратным действием" устраняет изменения, сделанные первоначальной транзакцией.

Расписание множества транзакций называется **сериализуемым**, если результат выполнения расписания эквивалентен результату некоторого последовательного расписания этого множества транзакций.

#### Two-Phase Locking (2PL):
- Цель: Гарантия сериализуемости транзакций в многопользовательских системах.
- Применение: Используется внутри СУБД для управления конкурентным доступом к данным.
- Фазы:
    1. **Фаза роста** (Growing Phase):
        - Транзакция может только запрашивать блокировки на записи данных.
        - Никакие блокировки не снимаются.
    2. **Фаза сокращения** (Shrinking Phase):
        - Транзакция только снимает блокировки.
        - Новые блокировки больше не запрашиваются.
- Проблемы, которые решает: Обеспечивает сериализуемость (изолированное выполнение транзакций) и предотвращает конфликты между транзакциями.
- Пример использования: Упорядочивание операций в транзакциях для предотвращения состояний "грязного чтения" или "зависания".

### Блокировки

**Блокировки** (locks) — это механизм, который позволяет транзакциям безопасно и согласованно работать с данными в многопользовательских или многозадачных системах. Они предотвращают конфликты между транзакциями, такие как "грязное чтение", "неповторяющееся чтение" или "фантомы"

#### Виды блокировок

1. По уровню доступа:
	- **Эксклюзивная блокировка** (Exclusive Lock, X):
	    - Транзакция блокирует объект (запись, страницу, таблицу) для записи.
	    - Пока эксклюзивная блокировка активна, никакая другая транзакция не может получить доступ к данным (ни на запись, ни на чтение).
	    - Используется для операций изменения данных.
	- **Разделяемая блокировка** (Shared Lock, S):
	    - Транзакция блокирует объект для чтения.
	    - Несколько транзакций могут одновременно устанавливать разделяемые блокировки на один объект, но не могут вносить изменения (запрещена запись).
	    - Используется для операций чтения.

2. По уровню гранулярности (объект блокировки):
	- **На строку** (Row Lock):
	    - Блокируется отдельная запись в таблице. Позволяет другим транзакциям работать с другими записями.
	- **На страницу** (Page Lock):
	    - Блокируется физическая страница данных в памяти или на диске (несколько строк).
	    - Эффективнее на уровне ресурсов, но может вызывать больше конфликтов.
	- **На таблицу** (Table Lock):
	    - Блокируется вся таблица. Используется, если транзакция выполняет массовые изменения или требует полной блокировки для консистентности.
	- **На базу данных** (Database Lock):
	    - Блокируется вся база данных. Обычно применяется в административных операциях, таких как резервное копирование.

3. По совместимости:
	- **Совместимые блокировки:**
	    - Разделяемые блокировки допускают наложение (несколько транзакций могут одновременно читать данные).
	- **Несовместимые блокировки:**
	    - Эксклюзивная блокировка запрещает доступ другим транзакциям.

4. Специальные типы блокировок:
	- **Блокировка намерения** (Intent Lock):
	    - Указывает, что транзакция планирует установить блокировку более высокого уровня (например, блокировку строки в пределах страницы или таблицы).
	    - Предотвращает конфликт между операциями, которые работают на разных уровнях гранулярности.
	- **Блокировка на изменение** (Update Lock, U):
	    - Промежуточная блокировка, используемая для операций, которые могут обновить данные.
	    - Предотвращает "deadlock" (взаимную блокировку транзакций).
	- **Эскалируемая блокировка** (Escalation Lock):
	    - Если транзакция блокирует много строк или страниц, блокировка автоматически повышается до уровня таблицы или базы данных для оптимизации ресурсов.

5. По продолжительности:
	- **Короткоживущие блокировки** (Short-Term Lock):
	    - Снимаются сразу после выполнения операции (например, чтения строки).
	- **Долгоживущие блокировки** (Long-Term Lock):
	    - Действуют до конца транзакции (коммита или отката).

#### Блокировки применяются в системах с транзакциями для:
1. Обеспечения изоляции:
    - Реализация требований ACID, особенно принципа "I" — изоляции.
2. Предотвращения конфликтов:
    - Гарантия целостности данных при одновременном доступе.
3. Управления конкурентным доступом:
    - Обеспечение сериализуемости и корректного выполнения операций.

### Проектирование

#### Этапы логического проектирования
- Выделение понятий предметной области и описание информации, подлежащей моделированию
- Разработка семантической или информационно-логической (инфологической) модели предметной области без привязки к СУБД. Построение концептуальной модели предметной области
- Преобразование инфологической модели данных в модель данных конкретной СУБД. Чаще всего в реляционную модель

#### Схемы
- **Инфологическая модель** (Концептуальная схема)** — это самое общее представление данных, которое акцентируется на смысле и структуре данных с точки зрения предметной области, без учёта деталей реализации в СУБД. Она показывает, какие сущности, атрибуты и связи существуют, но не содержит подробностей о типах данных и ограничениях. ER-диаграмма — это пример инструмента, часто используемого для создания концептуальной схемы, где акцент делается на общих отношениях между сущностями.
- **Логическая схема** — это более детализированное представление базы данных. Она включает информацию о типах данных, связях между сущностями, ограничениях и ключах, но остаётся независимой от конкретной СУБД. Логическая схема учитывает правила нормализации и ограничения, что делает её готовой к преобразованию в физическую схему.
- **Физическая схема** — это представление данных с привязкой к конкретной СУБД. Она включает оптимизацию структуры с учётом ограничений и особенностей конкретной платформы, детализированные типы данных и особенности хранения данных.

**Модель сущность - связь** (ER-модель или же ER-диаграмма) - семантическая модель. Нужна для наглядного представления структуры данных перед её реализацией в реляционной базе данных. Основные компоненты ER-модели:
1. Сущности (Entities) - объект или элемент реального мира, который необходимо хранить в базе данных. Сущность не имеет определения операций. Сущности – это объекты или категории, которые имеют свои атрибуты и могут быть представлены как отдельные таблицы.
2. Атрибуты (Attributes) - характеристики или свойства сущностей. 
3. Связи (Relationships) - показывают, как сущности взаимодействуют друг с другом. Типы связей:
	- M:1 - сотрудник <-> отдел (M:1)
	- 1:1 - человек <-> паспорт (1:1)
	- M:N - студент <-> дисциплина (M:N)
4. Первичный ключ (Primary Key) - уникальный идентификатор сущности (идентифицирующий атрибут), который позволяет однозначно различать экземпляры сущностей в базе данных.

| ![[Pasted image 20241021170802.png]] | ![[Pasted image 20241021170850.png]] |
| ------------------------------------ | ------------------------------------ |
| ![[Pasted image 20241021171010.png]] | ![[Pasted image 20240929224740.png]] |

**Реляционная база данных** - это тип базы данных, который хранит и управляет данными с помощью таблиц и связей между ними.

**Диаграмма прецедентов** — это графическое представление взаимодействия пользователей  (актеров) с системой в рамках конкретного программного проекта. Она используется в методологии UML (Unified Modeling Language) для моделирования поведения системы и описания функциональности через так называемые "прецеденты использования" (use cases).

### Структура СУБД

![[Pasted image 20241021195027.png]]

1. **Компилятор запросов** (Query Compiler)
	- Задача: Преобразование SQL-запросов в план выполнения.
	- Анализирует SQL-запросы, отправленные пользователями, и переводит их в понятный для системы план действий. Этот процесс включает:
		- Синтаксический разбор: Проверка правильности структуры SQL-запроса.
		- Оптимизация запросов: Компилятор пытается найти самый эффективный способ выполнения запроса, например, выбирает правильные индексы или упрощает выражения.
		- Планирование выполнения: На основе оптимизации создается план выполнения, который описывает, как сервер должен искать, фильтровать, сортировать данные и взаимодействовать с дисковым хранилищем для выполнения запроса.
	- Пример: Компилятор запросов может решить, что для запроса с фильтрацией по индексу более эффективно воспользоваться индексом, чтобы быстрее найти нужные строки.

2. **Исполняющая машина** (Execution Engine)
	- Задача: Выполнение плана запроса.
	- Отвечает за непосредственное выполнение плана, созданного компилятором запросов. Она интерпретирует план выполнения во внутренние команды СУБД и выполняет их шаг за шагом. Основные задачи:
		- Получение данных из хранилища (запрашивает строки таблицы).
		- Выполнение операций фильтрации, сортировки, объединения и агрегации данных.
		- Формирование конечного результата для отправки пользователю.
	- Пример: Если план включает поиск по индексу, затем фильтрацию по условию и сортировку результата, исполняющая машина последовательно выполнит эти шаги.

3. **Менеджер ресурсов** (Resource Manager)
	- Задача: Управление системными ресурсами для обеспечения оптимальной работы СУБД.
	- Отвечает за распределение и контроль использования ресурсов системы, таких как процессорное время, память и дисковое пространство. Его задачи включают:
		- Управление потоками и процессами.
		- Контроль за использованием процессора и оперативной памяти.
		- Обеспечение многозадачности и приоритезации запросов, чтобы избежать конфликтов при доступе к общим ресурсам.
	- Менеджер ресурсов знает, в каких файлах находятся данные таблицы.
	- Запросы на получение данных транслируются в адреса страниц
	- В СУБД хранение данных реализуется через подсистему управления хранимыми данными (менеджер ресурсов), которая строится на файлах, обеспечивая более сложные и удобные для хранения структуры
	- Пример: Менеджер ресурсов может распределить время выполнения между несколькими запросами, чтобы каждый запрос мог быть обработан равномерно без блокировок.

4. **Менеджер буферов** (Buffer Manager)
	- Задача: Управление кэшированием данных в оперативной памяти.
	- Занимается управлением кэширования данных, которые загружаются из хранилища в оперативную память для более быстрого доступа. Задачи менеджера буферов включают:
		- Кэширование часто запрашиваемых данных, чтобы не обращаться к медленному дисковому хранилищу каждый раз.
		- Управление памятью: какие страницы данных хранить в памяти, а какие выгружать.
		- Поддержание целостности данных, особенно при одновременном доступе.
	- Ответственен за разбиение ОП на буферы – участки-страницы, куда помещается содержимое дисковых блоков
	- Пример: Если пользователи часто запрашивают одну и ту же таблицу, менеджер буферов может хранить её в памяти для ускорения доступа.

5. **Менеджер хранения данных** (Storage Manager)
	- Задача: Управление физическим хранением данных на диске.
	- Управляет размещением данных на дисках (вторичной памяти) и реализует обмен между диском и оперативной памятью.
	- Отвечает за взаимодействие с файловой системой или физическими устройствами для сохранения и извлечения данных. Его основные задачи:
		- Чтение и запись данных на дисковые устройства.
		- Управление файлами данных, индексами и системными файлами базы данных.
		- Обеспечение целостности данных при записи на диск и управлении транзакциями.
	- Пример: Менеджер хранения данных контролирует размещение данных на диске, чтобы минимизировать фрагментацию и ускорить доступ к данным.

6. **Менеджер транзакций** (Transaction Manager)
	- Отвечает за управление транзакциями в СУБД. Он контролирует, чтобы каждая транзакция выполнялась с соблюдением свойств ACID (атомарность, согласованность, изолированность, долговечность). Основные задачи менеджера транзакций:
		- Старт и завершение транзакций: Менеджер начинает транзакции и завершает их с помощью команд `COMMIT` (фиксация) или `ROLLBACK` (откат изменений).
		- Управление изолированностью транзакций: Определяет уровень изоляции транзакций и координирует параллельное выполнение транзакций, чтобы избежать конфликтов и нарушений целостности данных.
		- Решение конфликтов блокировок: Менеджер транзакций взаимодействует с механизмом блокировок, чтобы избежать ситуаций взаимной блокировки (deadlock) и обеспечить корректную работу параллельных транзакций.

7. **Менеджер протоколирования и восстановления** (Logging and Recovery Manager)
	- Обеспечивает долговечность данных и восстановление в случае сбоев. Его задачи:
		- Протоколирование (логирование): Менеджер записывает все изменения, сделанные в базе данных, в журнал транзакций (лог транзакций). Это позволяет восстановить состояние базы данных в случае сбоя, даже если транзакция ещё не была зафиксирована.
		    - Лог включает записи о начале транзакции, изменениях данных и завершении (коммит).
		- Восстановление данных: В случае сбоя менеджер восстановления использует журнал транзакций для отката незавершённых транзакций и применения зафиксированных транзакций.
		    - Восстановление может включать "откат" (undo) незавершённых транзакций и "применение" (redo) завершённых транзакций для сохранения их изменений.

8. **Планировщик заданий** (Scheduler)
	- Отвечает за распределение ресурсов между параллельными запросами и транзакциями, а также за управление выполнением заданий. Основные функции:
		- Управление параллелизмом: Планировщик решает, как различные задачи (например, запросы пользователей или фоновые задания) будут выполняться параллельно, и распределяет вычислительные ресурсы между ними.
		- Контроль за изоляцией: Он определяет, как одновременно выполняющиеся транзакции будут взаимодействовать друг с другом, чтобы избежать "грязного чтения" или других проблем, связанных с параллельным доступом к данным.
		- Приоритизация заданий: Планировщик может назначать приоритеты задачам в зависимости от их важности или временных ограничений, чтобы критические операции выполнялись быстрее.

9. **Таблицы блокировок** (Lock Tables)
	- Таблицы блокировок — это структуры данных, которые используются для управления блокировками, необходимыми для обеспечения корректного параллельного доступа к данным. Блокировки предотвращают одновременное изменение одних и тех же данных несколькими транзакциями.
	- Типы блокировок:
	    - **Exclusive lock** (исключительная блокировка): Запрещает доступ другим транзакциям к данным для чтения и записи.
	    - **Shared lock** (совместная блокировка): Разрешает другим транзакциям чтение, но не запись данных.
	- Управление взаимными блокировками (Deadlock detection): Таблицы блокировок помогают обнаруживать и разрешать ситуации, когда две транзакции блокируют друг друга.

10. **Буферы** (Buffer Manager)
	- Управляет кэшированием данных из базы данных в оперативной памяти. Это один из самых важных компонентов для повышения производительности СУБД, поскольку доступ к оперативной памяти гораздо быстрее, чем к дисковым данным.
		- Буферный пул (Buffer pool): Это область в оперативной памяти, где СУБД хранит страницы данных, которые активно используются. Когда данные читаются с диска, они помещаются в буфер, чтобы следующие запросы могли обращаться к ним без необходимости снова читать с диска.
		- Управление вытеснением данных: Менеджер буферов использует алгоритмы (например, LRU — Least Recently Used) для вытеснения старых страниц данных из буфера, когда требуется место для новых данных.
		- Обновление данных (Write-back caching): Иногда изменения в данных сохраняются сначала в буфер, а затем периодически записываются на диск.

### Нереляционные БД

#### NoSQL базы данных
NoSQL базы данных разработаны для работы с нереляционными структурами данных и предлагают более гибкую модель хранения данных. Они используются для работы с большими объемами данных, высокой скоростью обработки и горизонтального масштабирования.
Виды NoSQL баз данных:
- **Документо-ориентированные базы данных**:
    - Хранят данные в виде документов (например, JSON, BSON, XML).
    - Пример: **MongoDB**, **CouchDB**.
    - Применение: для работы с гибкими структурами данных, такими как веб-приложения, где структура данных может изменяться со временем.
- **Ключ-значение (Key-Value Store)**:
    - Простая модель данных, где каждая запись представляет собой пару "ключ-значение".
    - Пример: **Redis**, **Memcached**, **DynamoDB**.
    - Применение: для кэширования данных, сессий пользователей, быстрых операций поиска по ключу.
- **Колонночные базы данных (Column-Family Stores)**:
    - Данные хранятся по колонкам, что позволяет эффективно работать с большими объемами данных.
    - Пример: **Apache Cassandra**, **HBase**, **Bigtable**.
    - Применение: для аналитических задач и обработки больших объемов данных в распределённых системах.
- **Графовые базы данных (Graph Databases)**:
    - Хранят данные в виде графов, где узлы представляют сущности, а рёбра — связи между ними.
    - Пример: **Neo4j**, **Amazon Neptune**, **OrientDB**.
    - Применение: для моделирования сложных сетевых структур, таких как социальные сети, рекомендации, маршрутизация.

#### Time-Series базы данных
Эти базы данных оптимизированы для хранения и обработки данных временных рядов — данных, где важна временная метка (время, к которому относятся данные).
- Пример: **InfluxDB**, **Prometheus**, **TimescaleDB**.
- Применение: мониторинг систем, IoT-устройства, финансовые данные, аналитика.

#### NewSQL базы данных
NewSQL базы данных — это гибрид, который сочетает принципы реляционных баз данных с возможностями масштабирования NoSQL-систем. Они обеспечивают реляционную модель данных, но с высокой производительностью и масштабируемостью.
- Пример: **CockroachDB**, **Google Spanner**, **VoltDB**.
- Применение: для приложений, где требуется высокая консистентность данных, транзакции и горизонтальное масштабирование.

#### Объектно-ориентированные базы данных
Эти базы данных хранят данные в виде объектов, как в объектно-ориентированных языках программирования (например, Java, C++).
- Пример: **db4o**, **ObjectDB**.
- Применение: для приложений, где используется объектно-ориентированное программирование, и необходимо хранить объекты в базе данных без преобразований.

#### Гибридные базы данных
Гибридные базы данных сочетают в себе несколько подходов к хранению данных. Например, они могут поддерживать как реляционные структуры, так и нереляционные (документы, графы).
- Пример: **ArangoDB**, **Couchbase**.
- Применение: для приложений, где требуется работа с разными типами данных в одной базе данных.

#### Базы данных графов знаний
Эти базы данных фокусируются на хранении знаний в виде связанных фактов и отношений, что делает их особенно полезными для семантического поиска и искусственного интеллекта.
- Пример: **AllegroGraph**, **Stardog**, **Blazegraph**.
- Применение: семантические веб-приложения, онтологии, анализ данных с глубокими взаимосвязями.

#### Многомодельные базы данных
Эти базы данных могут поддерживать несколько типов данных одновременно, например, документы, графы и ключ-значение, что делает их универсальными и гибкими.
- Пример: **Couchbase**, **ArangoDB**, **MarkLogic**.
- Применение: для приложений с разными типами данных и разнообразными структурами.

#### Базы данных для обработки данных в памяти
Эти базы данных хранят данные в оперативной памяти, что обеспечивает очень высокую скорость чтения и записи. Они используются для приложений с высокими требованиями к производительности.
- Пример: **Redis**, **Memcached**, **SAP HANA**.
- Применение: кэширование, высокоскоростные вычисления, аналитика в реальном времени.

#### Базы данных на основе блокчейна
Этот тип баз данных использует технологию распределённого реестра, которая гарантирует неизменяемость и проверяемость данных.
- Пример: **BigchainDB**, **ChainDB**.
- Применение: для приложений с высоким уровнем безопасности и прозрачности, таких как криптовалюты, смарт-контракты.

#### Базы данных для распределённого хранения файлов
Эти базы данных позволяют распределённо хранить большие файлы, такие как документы, видео или изображения.
- Пример: **Hadoop HDFS**, **Google File System (GFS)**, **Amazon S3**.
- Применение: работа с большими объёмами неструктурированных данных.

#### Базы данных для геопространственных данных
Они специально разработаны для работы с географическими данными и поддерживают операции с координатами, расстояниями и геометрическими фигурами.
- Пример: **PostGIS (на основе PostgreSQL)**, **GeoMesa**.
- Применение: географические информационные системы (ГИС), приложения с картами и геолокацией.

#### Hierarchical и Network базы данных
Эти старые модели баз данных были популярны до появления реляционных СУБД. Они предоставляют древовидные или сетевые структуры для хранения данных.
- **Hierarchical DBMS**: данные организованы в древовидную структуру, где каждый узел имеет только одного родителя.
    - Пример: **IBM Information Management System (IMS)**.
- **Network DBMS**: данные организованы в виде сети, где каждый узел может иметь несколько родителей.
    - Пример: **Integrated Data Store (IDS)**.

### Реляционная модель данных

#### Аспекты модели
- Структуры данных
- Манипулирование данными
	- Реляционная алгебра
	- Реляционное исчисление
		- на кортежах
		- на доменах
- Целостность данных

#### Определения
- **Домены** - множества D1, D2, ..., Dn
	- Домен - это множество допустимых значений, которые может принимать атрибут (столбец) в таблице. 
	- Это набор значений, из которого выбираются данные для конкретного поля в базе данных. Домены помогают задавать тип данных и ограничения для значений в столбце.
	- Домен задается базовым типом и логическим выражением, определяющим элементы домена. Пример: Домен ИМЕНА может базироваться на строковом типе, но содержать только те строки, которые НЕ начинаются на  Ъ или Ь знак
- **Кортежи** {v1, v2, ..., vn} - элементы декартого произведения D1 x D2 x ... x Dn
	- Кортеж — это строка в таблице реляционной базы данных.
- **Отношение** - конечное подмножество декартого произведения  D1 x D2 x ... x Dn
	- Отношение – формальная структура, используемая для моделирования СУЩНОСТЕЙ и СВЯЗЕЙ
	- Отношение — это таблица в реляционной базе данных.
- **Схема отношения** - запись вида R(А1:D1, А2:D2, …, Аk:Dn)
	- R - имя отношения
	- Ai - имена атрибутов (все атрибуты Ai в схеме отношения различны)
	- Dj - имена доменов
	- Схема отношения — это структура, задающая таблицу, её атрибуты, типы данных и возможные ограничения.

- **Степень отношения** - число атрибутов в отношении
- **Кардинальное число** - число кортежей в отношении
- **Ключ отношения** - атрибут или множество атрибутов, однозначно определяющих кортеж в отношении.

![[Pasted image 20241027160149.png]]

#### Фундаментальные свойства отношений
- Отсутствие кортежей дубликатов
- Отсутствие упорядоченности кортежей
- Отсутствие упорядоченности атрибутов
- Атомарность значений атрибутов (значение не разделяется на более мелкие части)

**Реляционная база данных** - совокупность отношений, содержащих всю информацию, которая должна хранится в базе
- Модель данных в реляционных БД определена заранее и является строго типизированной
- Данные хранятся в таблицах, состоящих из столбцов и строк
- На пересечении каждого столбца и строчки допускается только одно значение
- Каждый столбец проименован и имеет определённый тип, которому следуют значения со всех строк в данном столбце
- Столбцы располагаются в определённом порядке, который определяется при создании таблицы
- В таблице может не быть ни одной строчки, но обязательно должен быть хотя бы один столбец
- Запросы к базе данных возвращают результат в виде таблиц

В реляционной БД таблицы взаимосвязаны и соотносятся друг с другом как **главные** и **подчиненные**. Связь главной и подчиненнной таблицы осуществляется через **первичный ключ** (primary key) главной таблицы и **внешний ключ** (foreign key) подчиненной таблицы.  
Внешний ключ это атрибут или набор атрибутов, который в главной таблице является первичным ключем.

### Реляционная алгебра

#### Операции реляционной алгебры:
- **Объединение**
	- Результат содержит все кортежи обеих таблиц, но дублирующиеся строки удаляются, так как в реляционной алгебре результатом операции является множество, а множества не содержат дубликатов.
	- Ограничение: отношения должны иметь одинаковый набор атрибутов
- **Пересечение**
	- Результатом операции пересечения будет отношение, состоящее из кортежей, полностью входящих в состав обоих отношений.
	- Ограничение: отношения должны иметь одинаковый набор атрибутов
- **Разность**
	- Результатом вычитания будет отношение, состоящее из кортежей, которые являются кортежами первого отношения и не являются кортежами второго отношения.
	- Ограничение: отношения должны иметь одинаковый набор атрибутов
- **Декартово произведение**
	- Умножение или декартово произведение является операцией, производимой над двумя отношениями, в результате которой мы получаем отношение со всеми доменами из двух начальных отношений. Кортежи в этих доменах будут представлять из себя все возможные сочетания кортежей из начальных отношений.
- **Выборка (селекция)**
	- Это операция, которая выделяет множество строк в таблице, удовлетворяющих заданным условиям. Условием может быть любое логическое выражение
- **Проекция**
	- Это операция, при которой из отношения выделяются атрибуты только из указанных доменов, то есть из таблицы выбираются только нужные столбцы, при этом, если получится несколько одинаковых кортежей, то в результирующем отношении остается только по одному экземпляру подобного кортежа.
- **Соединение (join)**
	- **Эквисоединение**
		- Операция соединения обратна операции проекции и создает новое отношение из двух уже существующих. Новое отношение получается конкатенацией кортежей первого и второго отношений, при этом конкатенации подвергаются отношения, в которых совпадают значения заданных атрибутов. Также для понятности можно представить соеднинение как результат двух операций. Сначала берется произведение исходных таблиц, а потом из полученного отношения мы делаем выборку с условием равенства атрибутов из одинаковых доменов.
		- Ограничение: Требует хотя бы одного совпадающего атрибута в обоих отношениях, по которому будет выполняться условие соединения.
	- **Натуральное соединение**
		- Натуральное соединение - как обычное соединение, но без дублирования одинаковых доменов.
	- **Left OUTER JOIN**
		- Возвращает все строки из левой таблицы (той, что указана первой в запросе) и соответствующие строки из правой таблицы. Если в правой таблице нет соответствующих записей, возвращаются NULL для её атрибутов.
	- **Right OUTER JOIN**
		- Возвращает все строки из правой таблицы и соответствующие строки из левой. Если в левой таблице нет подходящих значений, они заменяются на NULL.
	- **Full OUTER JOIN**
		- Объединяет результаты LEFT JOIN и RIGHT JOIN. Он возвращает все строки из обеих таблиц. Если нет совпадающих строк в любой из таблиц, то в соответствующих полях возвращаются NULL.
- **Деление**
	- Это операция, которая создаёт новое отношение, содержащее атрибуты первого отношения, отсутствующие во втором отношении, и кортежи первого отношения, которые совпали кортежами второго.
	- Ограничение: Деление требует, чтобы в первом отношении было все атрибуты второго отношения и, возможно, дополнительные атрибуты.
- **Декомпозиция**
	- Это процесс разбиения одной таблицы (отношения) на две или более связанных таблиц, которые содержат те же данные, но представляют их в более нормализованной форме.
	- **Бездефектная декомпозиция**: разбиение на таблицы так, что исходные данные можно восстановить при помощи операции соединения (`JOIN`) без потери информации.
	- **Зависимая декомпозиция**: разбиение, при котором можно потерять информацию о некоторых зависимостях, если нарушаются условия исходного отношения.

Замечание: результатом любой операции алгебры над отношениями является еще одно отношение, которое можно потом так же использовать в других операциях

![[Pasted image 20241027213251.png]]

### Реляционное исчисление

**Реляционное исчисление** — это декларативный подход, в котором запрос описывает желаемый результат, не указывая конкретно, как его получить. В исчислении запросы выражаются через логические выражения, описывающие условия, которым должны удовлетворять строки. В отличие от реляционной алгебры, реляционное исчисление не описывает конкретные шаги и операции, а указывает на условия, при которых строки попадут в результат.

Реляционное исчисление подразделяется на:
- **Кортежное исчисление (Tuple Relational Calculus, TRC)** — выражения строятся через переменные кортежей (строк).
	- Вид выражений реляционного исчисления кортежей: `{ t | φ (t) }`
		- t – переменная кортеж некоторой фиксированной длины
		- φ – формула, построенная из атомов и совокупности операторов
- **Доменно-ориентированное исчисление (Domain Relational Calculus, DRC)** — переменные представляют отдельные атрибуты, а не строки.
	- Выражения РИ на доменах имеют вид: `{ х1, х2, … , хk | φ (х1, х2, … , хk) }`
		- φ  – формула, построенная из атомов и совокупности операторов
		- х1, х2, … , хk – переменные, определенные  на доменах отношений, входящих в формулу

Реляционное исчисление на кортежах эквивалентно реляционной алгебре. Множество отношений, выразимых в реляционной алгебре, является в точности тем же самым, что и множество отношений, выразимых безопасными формулами реляционного исчисления на кортежах.

### Нормальные формы

**Функциональная зависимость**  — это отношение между двумя наборами атрибутов (полей) в таблице. Например: EmployeeID→EmployeeName, Department

**Аномалии** — это проблемы, которые могут возникнуть при вставке, обновлении или удалении данных в таблицах, особенно если они не нормализованы. Существует три основных типа аномалий:
1. **Аномалия вставки**: возникает, когда необходимо вставить данные, но для этого требуется информация, которая ещё не существует в базе данных.
2. **Аномалия обновления**: возникает, когда изменение данных в одном месте требует изменения их в нескольких местах, что может привести к несогласованности.
3. **Аномалия удаления**: возникает, когда удаление данных приводит к потере информации, которая может быть важной.

Чтобы избежать аномалий, таблицы базы данных можно нормализовать, что означает структурирование данных таким образом, чтобы:
- Каждый атрибут зависел только от ключа.
- Избежать дублирования данных.
- Разделить данные по смысловым категориям.

**Нормальная форма** — это набор правил, определяющих уровень структурированной организации данных в таблицах. Нормальные формы помогают минимизировать избыточность данных и избежать аномалий при вставке, обновлении и удалении записей.

#### Основные нормальные формы
1. **Первая нормальная форма (1NF)**:
    - Все атрибуты должны содержать атомарные (неделимые) значения.
    - Не должно быть повторений строк в таблице.
2. **Вторая нормальная форма (2NF)**:
    - Отношение находится в 1NF.
    - Все неключевые атрибуты должны зависеть от всего первичного ключа, а не только от его части (в случае составного ключа).
3. **Третья нормальная форма (3NF)**:
    - Отношение находится в  2NF.
    - Не должно быть транзитивных зависимостей (все неключевые атрибуты должны быть независимыми друг от друга)
4. **Бойс-Кодд нормальная форма (BCNF)** (частная форма третьей нормальной формы):
    - Отношение находится в  3NF.
    - Для каждой не тривиальной функциональной зависимости X→Y (где X — это множество атрибутов, а Y — атрибуты, зависимые от X), X должно быть суперклассом (или первичным ключом) для этой таблицы. Это означает, что каждая зависимость должна исходить от ключа. Суперкласс — это множество атрибутов, которое может служить для уникальной идентификации записей в таблице.
5. **Четвёртая нормальная форма (4NF)**:
    - Отношение находится в BCNF.
    - Устранение многозначных зависимостей, где один атрибут может зависеть от нескольких значений другого атрибута.
6. **Пятая нормальная форма (5NF)**:
    - Отношение находится в  4NF.
    - Все данные должны быть неделимыми, чтобы избежать аномалий при разделении таблиц на более мелкие.

### Триггеры

**Триггеры** — это специальные объекты в базе данных, которые автоматически выполняют заданные действия в ответ на определённые события, происходящие в таблице, такие как добавление, обновление или удаление строк

Триггеры запускаются автоматически при выполнении одной из операций на таблице:
- `INSERT` — вставка новых строк
- `UPDATE` — обновление существующих строк
- `DELETE` — удаление строк

Варианты сробатывания триггера:
- `BEFORE` - до выполнения операции
- `AFTER` - после неё

#### Применение триггеров
1. Логирование изменений — автоматическая запись всех изменений в отдельную таблицу
2. Поддержание целостности данных — например, проверка лимитов баланса перед снятием средств
3. Автоматическое обновление — например, обновление времени последнего изменения записи
4. Валидация данных — проверка значений перед вставкой или обновлением, чтобы предотвратить некорректные данные


### OLTP и OLAP

OLAP (Online Analytical Processing) и OLTP (Online Transaction Processing) — это два типа систем, которые используются для обработки данных, но они предназначены для разных задач и имеют различные характеристики

**OLTP-системы** предназначены для обработки большого количества коротких транзакций в реальном времени. Они оптимизированы для операций вставки, обновления и удаления данных, а также для выполнения простых запросов. Основная цель OLTP-систем — обеспечить быструю и эффективную обработку транзакций, поддерживая целостность данных

Примеры OLTP-систем:
1. Банковские системы для обработки транзакций (например, переводы между счетами)
2. Системы бронирования билетов (авиабилеты, железнодорожные билеты)
3. Интернет-магазины (обработка заказов, обновление информации о товарах)
4. Системы управления базами данных (СУБД), такие как MySQL, PostgreSQL, Oracle, которые используются для оперативной обработки транзакций

**OLAP-системы** предназначены для анализа больших объемов данных. Они оптимизированы для выполнения сложных запросов, которые включают агрегацию данных (например, суммирование, усреднение) и анализ исторических данных. OLAP-системы используются для поддержки принятия решений, бизнес-аналитики и отчетности

Примеры OLAP-систем:
1. Системы бизнес-аналитики (BI), такие как Microsoft Power BI, Tableau, QlikView
2. Хранилища данных (Data Warehouses), такие как Amazon Redshift, Google BigQuery, Snowflake
3. Многомерные базы данных, такие как Microsoft Analysis Services, Oracle Essbase

#### Основные различия между OLTP и OLAP
1. *Цель использования:*
    - OLTP: оперативная обработка транзакций
    - OLAP: анализ данных и поддержка принятия решений
2. *Тип запросов:*
    - OLTP: простые запросы, часто связанные с изменением данных (INSERT, UPDATE, DELETE)
    - OLAP: сложные запросы, часто включающие агрегацию и анализ больших объемов данных
3. *Скорость операций:*
    - OLTP: высокая скорость обработки транзакций
    - OLAP: более медленные операции, так как они работают с большими объемами данных
4. *Структура данных:*
    - OLTP: нормализованная структура данных (минимизация избыточности)
    - OLAP: денормализованная структура данных (оптимизация для анализа)
5. *Объем данных:*
    - OLTP: относительно небольшие объемы данных, актуальные на текущий момент
    - OLAP: большие объемы исторических данных

#### Замечания
- Некоторые СУБД изначально разрабатываются и оптимизируются для конкретного типа задач (OLTP или OLAP), а также есть и универсальные
- Можно использовать такой подход: Данные хранить в OLTP-системе, но периодически переносить их в OLAP-систему (хранилище данных) для анализа и отчетности. Это позволяет не перегружать OLTP-систему сложными аналитическими запросами


### ANSI-SPARC

**ANSI-SPARC (трехуровневая архитектура СУБД)** — это стандартная архитектура для систем управления базами данных (СУБД), предложенная в 1975 году американским Национальным институтом стандартов (ANSI) и группой SPARC (Standards Planning and Requirements Committee). Она разделяет систему базы данных на три уровня, чтобы обеспечить независимость данных, гибкость и упростить управление

Уровни:
1. *Внутренний уровень* (физическая схема) — описывает, как данные хранятся на физическом уровне (файлы, индексы, структуры хранения)
2. *Концептуальный уровень* (логическая схема) — описывает логическую структуру всей базы данных, включая таблицы, связи и ограничения
3. *Внешний уровень* (внешняя схема) — описывает, как данные видят конкретные пользователи или приложения

Каждый уровень представляет данные по-своему, и изменения на одном уровне не влияют на другие. Это позволяет:
- Упростить разработку и поддержку
- Обеспечить безопасность данных
- Сделать систему более гибкой и масштабируемой

#### Внешняя схема

**Внешняя схема базы данных** — это описание части базы данных, относящейся к конкретному пользователю или группе пользователей, скрывая при этом остальную часть базы данных. Это уровень архитектуры базы данных, который определяет, как данные представляются и взаимодействуют с конкретными пользователями или приложениями. 

Внешняя схема — это представление данных, адаптированное под нужды конкретного пользователя или группы пользователей. Она определяет:
- Какие таблицы, столбцы или данные доступны пользователю
- Как данные структурированы для конкретного приложения
- Какие ограничения или правила применяются к данным для данного пользователя

Внешняя схема может включать:
- Подмножество данных: Например, пользователь видит только те таблицы или столбцы, которые ему нужны для работы
- Виртуальные таблицы (представления, views): Например, вместо доступа к исходным таблицам пользователь работает с предопределенными представлениями
- Агрегированные данные: Например, пользователь видит итоговые отчеты, а не сырые данные

### Готовимся к тесту 4

#### B-дерево

**B-дерево** — это сбалансированное дерево поиска, где каждый узел содержит множество ключей и имеет более двух потомков

Ключевые параметры:
- Степень дерева (d): Максимальное количество потомков у узла
- Высота дерева (h): Количество уровней в дереве. От неё зависит число обращений к диску при поиске

Свойства:
1. Глубина всех листьев одинакова
2. Все узлы, кроме корня имеют как минимум (m/2)–1 ключей и максимум m-1 ключей  
3. Все внутренние узлы имеют минимум m/2 потомков  
4. Если корень – это узел не содержащий листьев, он должен иметь минимум 2 потомка  
5. Узел без листьев с n-1 ключами должен иметь n потомков
6. Все ключи в узле должны располагаться в порядке возрастания их значений

Пример B-дерева 4 порядка (оно содержит максимум 3 значения ключа и максимум 4 потомка для каждого узла):
![[Pasted image 20250325010252.png]]

С помощью B-дерева можно эффективно работать с данными на диске. Для этого создаётся 2 файла:
- *Основной файл* содержащий сами данные (записи), которые нужно хранить или искать. Записи группируются в блоки (страницы) для эффективного чтения с диска
- *Индексный файл* хранит структуру B-дерева для быстрого поиска записей в основном файле. Состоит из узлов B-дерева (блоков индексного файла), где каждый узел содержит: ключи (например, ID записей), указатели на дочерние узлы или блоки основного файла (они на последнем уровне; это минимальная единица чтения/записи на диске; содержат несколько записей)

![[Pasted image 20250325012547.png]]

#### Логические компоненты

**Логические компоненты вычислительной системы** — это программные или абстрактные механизмы, которые управляют физическими ресурсами (процессором, памятью, дисками) и предоставляют пользователю удобный интерфейс для работы. Они не являются физическими устройствами, а реализуются программно
- *Логические компоненты* — это программные абстракции или системы, которые работают поверх физических устройств
- *Физические компоненты* — "железо" (процессор, диски, память), которое выполняет вычисления и хранит данные

Правильные ответы:
1. Операционная система - программная платформа для управления ресурсами
2. Файловая система - логическая организация данных на носителе
3. Виртуальная память - абстракция памяти, расширяющая адресное пространство
4. Диспетчер логических томов - программный уровень управления дисковым пространством

Почему другие варианты не подходят:  
1. Процессор - физическое устройство (железо)  
2. Компилятор - инструмент разработки, не является системным компонентом  
3. СУБД - прикладное программное обеспечение, а не системный компонент

#### RAID

**RAID** (Redundant Array of Independent Disks) — это технология объединения нескольких физических дисков в один логический массив для повышения производительности, надёжности или обоих параметров одновременно

Основные цели RAID:
- Увеличение отказоустойчивости (резервирование данных при отказе диска)
- Повышение скорости (параллельная запись/чтение с нескольких дисков)
- Увеличение ёмкости (объединение дисков в единое пространство)

Типы (уровни) RAID:
- *RAID 0 (Striping — чередование)*
	- Как работает: Данные разбиваются на блоки и записываются на несколько дисков параллельно
	- Плюсы: Высокая скорость чтения/записи
	- Минусы: Нет отказоустойчивости — при отказе одного диска теряются все данные
	- Минимум дисков: 2
	- Пример использования: Видеомонтаж, кэширование
- *RAID 1 (Mirroring — зеркалирование)*
	- Как работает: Данные полностью дублируются на второй диск
	- Плюсы: Высокая надёжность — при отказе одного диска данные сохраняются на втором
	- Минусы: Вдвое меньше полезной ёмкости (из-за копирования)
	- Минимум дисков: 2
	- Пример: Серверы баз данных
- *RAID 5 (Чётность + чередование)*
	- Как работает: Данные и контрольные суммы (чётность) распределяются по всем дискам
	- Плюсы: Отказоустойчивость (потеря 1 диска не критична), хорошая скорость чтения
	- Минусы: Медленная запись (из-за расчёта чётности)
	- Минимум дисков: 3
	- Пример: Файловые хранилища
- *RAID 6 (Двойная чётность)*
	- Как работает: Как RAID 5, но с двумя контрольными суммами
	- Плюсы: Выдерживает отказ 2 дисков
	- Минусы: Ещё более медленная запись
	- Минимум дисков: 4
	- Пример: Медицинские архивы
- *RAID 10 (1+0 — зеркало + чередование)*
	- Как работает: Сначала зеркалирование (RAID 1), затем чередование (RAID 0)
	- Плюсы: Высокая скорость + отказоустойчивость
	- Минусы: Требует минимум 4 диска
	- Пример: Критичные системы (банки, СУБД)

Важные термины:
- *Чередование (Striping)* - разделение данных на блоки для записи на несколько дисков
- *Зеркалирование (Mirroring)* - полное копирование данных на второй диск
- *Чётность (Parity)* - контрольная сумма для восстановления данных при отказе диска

Как устроен RAID 10:
- Минимально требуется 4 диска (2 пары зеркал)
- Данные сначала разбиваются на блоки и чередуются (RAID 0), а затем каждый блок зеркалируется (RAID 1)
- Пример для 4 дисков:
	- Диски: `[A1, B1], [A2, B2]`
	- A1 и A2 — зеркальные копии (RAID 1)
	- B1 и B2 — зеркальные копии (RAID 1)
	- Данные чередуются между A и B (RAID 0)

Как устроен RAID 5:
1. Данные (Data)
    - Основная информация (файлы, базы данных и т.д.) разбивается на блоки и записывается на диски
    - Например, если массив состоит из 4 дисков, блоки данных (`D1`, `D2`, `D3`) распределяются по дискам 1, 2 и 3
2. Контрольная сумма (Parity)
    - Это специальный блок, вычисляемый по формуле XOR (исключающее ИЛИ) из данных других дисков
    - Parity позволяет восстановить данные при выходе одного диска из строя
    - В примере с 4 дисками: 
	    - Диск 1: `D1`
	    - Диск 2: `D2`
	    - Диск 3: `D3`
	    - Диск 4: `P1` (parity для `D1`, `D2`, `D3`)
3. Циклическое распределение
    - Parity не фиксируется на одном диске, а перемещается между дисками для равномерной нагрузки
4. Пример RAID 5 из 4 дисков:

|Диск 1|Диск 2|Диск 3|Диск 4|
|---|---|---|---|
|`D1`|`D2`|`D3`|`P1`|
|`D4`|`D5`|`P2`|`D6`|
|`D7`|`P3`|`D8`|`D9`|
|`P4`|`D10`|`D11`|`D12`|

- **`P1`** = `D1` XOR `D2` XOR `D3`
- **`P2`** = `D4` XOR `D5` XOR `D6`
- И так далее...

#### Оптимизация запросов

**Оптимизация запросов** — это процесс улучшения выполнения SQL-запросов для минимизации времени обработки и ресурсов

Основные этапы оптимизации запросов:
- *Преобразование запроса во внутреннюю форму*: SQL-запрос переводится в структурированное представление (например, синтаксическое дерево), с которым может работать оптимизатор
- *Преобразование в каноническую форму*: Запрос упрощается по стандартным правилам (удаление избыточных условий, приведение к единому формату)
- *Генерация планов вычисления запроса и выбор плана с наименьшими затратами*: Оптимизатор создает несколько вариантов выполнения запроса (например, с разными типами JOIN). Для каждого плана оцениваются «затраты» (время CPU, операции I/O, использование памяти). Выбирается план с минимальной стоимостью
- *Выбор потенциальных низкоуровневых процедур*: Оптимизатор решает, какие алгоритмы использовать для операций (сортировка, соединение, фильтрация)

Как это работает в СУБД:
1. *Парсинг запроса* → Перевод SQL в синтаксическое дерево
2. *Логическая оптимизация* → Упрощение условий (каноническая форма)
3. *Физическая оптимизация* → Генерация планов + выбор лучшего
4. *Исполнение* → Запуск низкоуровневых процедур (например, HashJoin)

Стратегиям оптимизации запросов:
- *Сортировка файлов перед операцией соединения*: Ускоряет работу алгоритмов соединения (например, merge-join)
- *Индексирование файлов перед операцией соединения*: Позволяет использовать быстрый доступ по индексу вместо полного сканирования таблиц
- *Выполнять операции селекции по возможности раньше*: Уменьшает объем обрабатываемых данных на ранних этапах (принцип "фильтруй как можно раньше")
- *Собирать в каскады селекции и проекции*: Позволяет комбинировать операции для уменьшения промежуточных результатов

#### Модель внешней памяти

**Модель внешней памяти** — это абстракция, описывающая, как данные организованы и обрабатываются при работе с медленными устройствами хранения (жёсткими дисками, SSD), где доступ к данным требует значительно больше времени, чем к оперативной памяти (RAM)

| Понятие    | Пример в PostgreSQL  | Пример в файловой системе |
| ---------- | -------------------- | ------------------------- |
| **Блок**   | `8 KB page`          | `4 KB cluster` (NTFS)     |
| **Запись** | Строка в таблице     | Запись в CSV-файле        |
| **Поле**   | Столбец `users.name` | Поле `"age"` в JSON       |
| **Файл**   | `base/16384/12345`   | `document.pdf`            |
| **Ключ**   | `PRIMARY KEY (id)`   | Уникальный ID в XML       |

#### Вторичный индекс

**Вторичный индекс** — это дополнительная структура данных, которая ускоряет поиск записей в таблице по значению определённого поля (не являющегося первичным ключом). В отличие от первичного индекса (который обычно уникален и соответствует физическому порядку записей), вторичный индекс:
- Создается для произвольных полей (например, `email`, `category_id`)
- Может содержать дубликаты (если поле не уникально)
- Не влияет на физическое расположение данных

Вторичный индекс обычно реализуется через:
- B-дерево (в большинстве СУБД: PostgreSQL, MySQL, Oracle)
- Хеш-таблицу (редко, только для точного поиска)
- Bitmap-индекс (для полей с малым числом уникальных значений)

#### Способы хранения записей с переменной длинной

Для хранения записей с переменной длиной (например, строки, JSON-данные) используются специальные методы, которые позволяют эффективно управлять памятью и обеспечивать быстрый доступ

1. *Метод зарезервированного пространства (Reserved Space)*
	- Как работает:  Для каждой записи выделяется фиксированный блок памяти (например, 256 байт). Если данные меньше, остаток заполняется пустыми значениями; если больше — сохраняется в дополнительном блоке
	- Плюсы: Простота реализации, быстрый доступ к началу записи
	- Минусы: Неэффективное использование памяти, если записи сильно различаются по размеру
	- Пример: Ранние версии СУБД (например, dBASE)
    
2. *Метод указателей (Pointer Method)*
	- Как работает: Данные хранятся в отдельных блоках, а в основной структуре (например, в заголовке файла) сохраняются указатели на их расположение
	- Плюсы: Гибкость, экономия памяти
	- Минусы: Дополнительные затраты на хранение указателей и потенциальные накладные расходы при доступе
	- Пример: Хранение больших текстовых полей в PostgreSQL (TOAST-технология)
    
3. *Комбинированный метод (Slotted Page)*
	- Как работает:
		- Блок памяти делится на две части: заголовок (содержит указатели и метаданные) и область данных
		- Записи размещаются в области данных, а в заголовке хранятся их смещения и длины
	- Плюсы: Баланс между скоростью доступа и эффективным использованием памяти
	- Минусы: Сложнее в реализации, чем метод зарезервированного пространства
	- Пример: Страницы в современных СУБД (MySQL InnoDB, SQL Server)

#### Методы повышения эффективности дисковых операций

Для ускорения работы с дисками (HDD/SSD) используются следующие методы из предложенного списка:
1. Использование нескольких дисковых устройств (RAID): Данные распределяются по нескольким дискам (чередование, зеркалирование)
2. Применение алгоритма лифта (Elevator Algorithm): Запросы к диску сортируются по физическому расположению данных (цилиндрам), чтобы минимизировать перемещение головки HDD
3. Создание зеркальных копий дисков (RAID 1): Данные дублируются на 2+ дисках. Ускорение чтения (можно читать с любого диска)
4. Предварительное считывание (Read-Ahead): Система заранее загружает в кэш блоки, которые, вероятно, понадобятся в ближайшее время
5. Группирование данных по цилиндрам диска (Cylinder Grouping): Связанные данные размещаются на одном цилиндре HDD, чтобы уменьшить перемещение головки

#### Разреженный индекс

При поиске записи в файле с **разреженным индексом** (sparse index) часто используется алгоритм **дихотомии** (бинарного поиска)

Как работает поиск в разреженном индексе:
1. Разреженный индекс содержит не все записи данных, а только ключевые (например, каждую 100-ю запись). Пример: если данные отсортированы по полю `ID`, индекс может хранить значения `ID=100, ID=200, ID=300` и т.д.
2. Алгоритм поиска:
    - Сначала выполняется бинарный поиск (дихотомия) по разреженному индексу, чтобы найти ближайший меньший ключ. Например, для поиска записи с `ID=150` алгоритм найдет в индексе запись `ID=100`
    - Затем осуществляется последовательный поиск в основном файле данных от этой точки до следующего ключа в индексе (`ID=200`)

#### IaaS и SaaS

Это две основные модели облачных услуг, которые отличаются уровнем контроля пользователя и степенью ответственности провайдера

**IaaS (Infrastructure as a Service)** — "Инфраструктура как услуга"
- Аренда виртуальной инфраструктуры (серверы, хранилища, сети) у облачного провайдера
- Что управляет провайдер:
	- Физические серверы
	- Сети и дата-центры
	- Системы охлаждения и электропитание
- Что управляет пользователь:
	- Виртуальные серверы (ОС, ПО, настройки)
	- Приложения и данные
	- Сетевые настройки (файрволлы, балансировка нагрузки)

**SaaS (Software as a Service)** — "Программное обеспечение как услуга"
- Готовое облачное приложение, доступное через браузер или API
- Что управляет провайдер:
	- Всё: от инфраструктуры до обновлений ПО
- Что управляет пользователь:
	- Только настройки внутри приложения (например, права доступа сотрудников)

#### Центр обработки данных

**Центр Обработки Данных (ЦОД)** — это специализированное сооружение, где размещается серверное и сетевое оборудование для:
1. Хранения и обработки данных (например, облачные сервисы, базы данных)
2. Обеспечения бесперебойной работы (резервное питание, охлаждение)
3. Защиты информации (физическая безопасность, резервное копирование)

Основные компоненты ЦОД:
- Мониторинг: Контроль состояния серверов, сети, СХД, температуры, энергопотребления в реальном времени
- Выделение ресурсов: Динамическое распределение вычислительных мощностей, памяти, хранилищ и сетевых ресурсов между задачами
- Отчетность: Анализ загрузки, инцидентов, эффективности работы инфраструктуры
- Обслуживание: Техническая поддержка оборудования, замена компонентов, обновление ПО
- Планирование: Прогнозирование нагрузки, масштабирование мощностей, оптимизация размещения серверов

Ключевые характеристики ЦОД:
1. Управляемость: Централизованный контроль оборудования, сети и ресурсов через единые панели (например, DCIM-системы)
2. Емкость: Способность хранить и обрабатывать большие объемы данных (мощность серверов, объем СХД)
3. Безопасность: Физическая (биометрия, видеонаблюдение) и кибербезопасность (брандмауэры, шифрование)
4. Масштабируемость: Возможность наращивать ресурсы (серверы, хранилища) без перебоев в работе     
5. Доступность: Гарантированное время безотказной работы (SLA 99.9% и выше). Обеспечивается резервированием (N+1, 2N)
6. Производительность: Скорость обработки запросов, низкая задержка (например, для облачных сервисов или баз данных)
7. Целостность данных: Защита от потерь и искажений (RAID, репликация, бэкапы)

Уровни ИТ-инфраструктуры ЦОД:
- Программно-определяемые компоненты: Включают SDN (программно-определяемые сети), SDS (программно-определяемые хранилища) и виртуализацию вычислений
- Физические компоненты: Аппаратная основа: серверы, системы хранения, сетевые устройства, ИБП, системы охлаждения
- Оркестрация: Управление и автоматизация рабочих нагрузок (например, Kubernetes, VMware vSphere)
- Услуги: Сервисный уровень: IaaS, PaaS, SaaS, предоставляемые на базе инфраструктуры
- Виртуальные компоненты: Виртуальные машины, контейнеры, виртуальные сети и хранилища

#### Специальные структуры файлов

**КУЧА-файл** — это неупорядоченная структура данных, где записи хранятся в произвольном порядке. Поиск - O(n), вставка - быстро (в конец). Может возникать фрагментация

**ХЭШ-файл** (или хеш-организованный файл) — это способ хранения данных, где каждая запись располагается в соответствии с вычисленным хеш-значением её ключа. Принцип работы:
- Ключ записи (например, ID пользователя) пропускается через хеш-функцию (например, MD5, SHA-1 или простой mod N)
- Полученное значение определяет физическое расположение записи в файле (номер блока или "участка")

![[Pasted image 20250325082304.png]]

### Проект

Мой проект: "Аренда оборудования"
Референсные сайты:
- https://genprokat.ru/catalog/akkumulyatornye_instrumenty/
- https://navysote.org/vyshki-samoxodnye-nozhnichnye-vyshki-samoxodnye-kolenchatye
- https://prokat.vcdp.ru
- https://market.yandex.ru/catalog--umnye-chasy-i-braslety/26893830/list?hid=10498025&rs=eJwz4vnEyMnBIMGg8PJ-AysAF_kDyA%2C%2C
- [Обзор реального сервиса](https://rutube.ru/video/669a3f7f70e57fa33b2ff2212d9efd17/?utm_source=embed&utm_medium=referral&utm_campaign=title&utm_content=669a3f7f70e57fa33b2ff2212d9efd17&utm_term=yastatic.net&referrer=appmetrica_tracking_id%3D1109935222251589310%26ym_tracking_id%3D11787636085779597978)
Полезности:
- [Стилизованные вставки для react](https://www.reactbits.dev)
- [Бесплатное развёртывание](https://yhub.net)

#### Стек технологий

| Компонент | Технологии           | Зачем нужен?                                                      |
| --------- | -------------------- | ----------------------------------------------------------------- |
| Бэкенд    | Python (Flask)       | Обработка логики, работа с БД (MySQL), API для фронтенда          |
| Фронтенд  | JavaScript (React)   | Динамический интерфейс, взаимодействие с пользователем            |
| HTML      | Разметка страниц     | Каркас веб-страницы (используется внутри React-компонентов)       |
| CSS       | Стилизация           | Внешний вид интерфейса                                            |
| Связь     | HTTP-запросы (Axios) | Фронтенд отправляет запросы к API бэкенда, получает данные в JSON |

*JavaScript (JS)* — это высокоуровневый, интерпретируемый язык программирования, который делает веб-страницы интерактивными. Без JS страницы были бы статичными

*Node.js* — это среда выполнения JavaScript на стороне сервера. До Node.js JavaScript работал только в браузере. Теперь можно писать и фронтенд (React, Vue), и бэкенд на одном языке. Также Node.js удобен для разработки

*NPM (Node Package Manager)* — менеджер пакетов для программной платформы Node.js. Это огромная экосистема библиотек (Express, Socket.IO, Mongoose и т. д.)

*Flask* — это микрофреймворк для создания веб-приложений на Python. Он предоставляет минимальный набор инструментов для работы с HTTP-запросами, маршрутизацией и шаблонами, позволяя разработчикам легко создавать API и веб-сайты

*MySQL-connector-python* - официальный драйвер от Oracle для MySQL. Полная совместимость с MySQL. Поддержка подготовленных выражений (защита от SQL-инъекций)

*React* — JavaScript-библиотека для создания пользовательских интерфейсов. Хотя React использует JavaScript, он генерирует HTML под капотом

*Axios* — JavaScript-библиотека для работы с HTTP-запросами

#### Полный цикл работы приложения
1. Браузер загружает HTML/CSS/JS (собранный React)
2. React рендерит интерфейс и ждёт действий пользователя
3. При отправке формы фронтенд делает HTTP-запрос к Python-бэкенду
4. Бэкенд взаимодействует с MySQL, обрабатывает данные и возвращает ответ
5. React обновляет страницу без перезагрузки (SPA-подход)
