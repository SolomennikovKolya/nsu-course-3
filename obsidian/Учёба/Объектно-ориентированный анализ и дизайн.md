
### Полезномти
- [Медия](https://www.nsumedia.ru/main_potok/third_course/fifth_semester/analysis)
- [Сайт Мухортова](https://ai.nsu.ru/projects/ooad/documents)
- [Файлы от Мухортова](https://ai.nsu.ru/projects/ooad/files)
- [Astah (редактор UML диаграмм)](https://astah.net/products/astah-community/)
- [Записи лекций (Максим Муратов)](https://www.youtube.com/playlist?list=PLHAiwjMOQSmzstcpt2613l1AZRGIG5gTv)

#### Критерии оценки:
- 5 - Проект доведен до конца
- 4 - Начат Этап 4
- 3 - Проект готов к старту Этапа 4
- 2 - Проект НЕ готов к старту Этапа 4 = не закончен Этап 3

#### Этапы:
- [x] 0. разбиться на пары и придумать проект
- [x] 1. Провести анализ требований к проекту
- [x] 2. Построить аналитическую UML модель
- [x] 3. Выработать архитектуру и дизайн системы
- [x] 4. Реализовать проект на выбранной технологии
- [x] По всем этапам: создать проектную документацию

### OOAD

#### Объектно-ориентированный анализ

**OOA** (Object-Oriented Analysis) – это методология, в которой требования к системе воспринимаются с точки зрения классов и объектов, выявленных в предметной области.

##### Этапы объектно-ориентированного анализа:
1. *Определение требований*:
    - Сбор и анализ функциональных и нефункциональных требований.
    - Идентификация ключевых объектов системы.
2. *Моделирование системы*:
    - Построение диаграмм вариантов использования (Use Case Diagrams) для определения взаимодействия пользователя с системой.
    - Разработка диаграмм классов, чтобы представить основные объекты и их атрибуты.
3. *Анализ поведения*:
    - Построение диаграмм последовательности (Sequence Diagrams) и диаграмм взаимодействия, чтобы отразить взаимодействие объектов во времени.
4. *Уточнение моделей*:
    - Проверка моделей на корректность, полноту и непротиворечивость.
    - Уточнение и детализация атрибутов, методов и связей.

#### Объектно-ориентированное проектирование

**OOD** (Object-Oriented Design) – методология проектирования, соединяющая в себе процесс объектной декомпозиции и приемы представления логической, физической, а также статической и динамическо моделей проектируемой системы. Этот подход применяется в рамках объектно-ориентированного программирования (ООП) и фокусируется на создании модульной и масштабируемой архитектуры.

| Тип модели       | Что описывает                                                                                      | Фокус                     | Примеры                                     |
| ---------------- | -------------------------------------------------------------------------------------------------- | ------------------------- | ------------------------------------------- |
| **Логическая**   | Концептуальная структура системы без привязки к технической реализации                             | Что система должна делать | DFD (Диаграммы потока данных), ER-диаграммы |
| **Физическая**   | Техническая реализация системы                                                                     | Как система реализована   | Схемы архитектуры, таблицы БД               |
| **Статическая**  | Структура системы в конкретный момент времени. Показывает объекты, их свойства и связи между ними. | Состав и связи элементов  | UML-диаграммы классов, компонентов          |
| **Динамическая** | Поведение системы во времени. Отражает переходы состояний, вызовы методов, выполнение процессов    | Изменения и заимодействие | UML-диаграммы последовательности            |

##### Этапы объектно-ориентированного проектирования:
1. *Анализ требований*: изучение требований системы и выявление ключевых объектов.
2. *Определение классов и объектов*:
    - Выявление сущностей и их взаимосвязей.
    - Определение атрибутов и методов для каждого класса.
3. *Разработка архитектуры системы*:
    - Создание диаграмм классов и других UML-диаграмм.
    - Определение взаимодействий между объектами (диаграммы последовательности, диаграммы взаимодействия).
4. *Определение интерфейсов и модулей*: проектирование способов взаимодействия между объектами и внешними компонентами.
5. *Реализация*: кодирование классов и объектов на языке программирования.

#### DevOps

**DevOps** — это сочетание философий, практик и инструментов, направленных на интеграцию и автоматизацию процессов между разработкой программного обеспечения (Dev) и IT-операциями (Ops). Основная цель DevOps — ускорить процесс разработки, тестирования и развертывания программного обеспечения, улучшив при этом качество и стабильность продукта.

DevOps ориентирован на создание более тесного взаимодействия между разработчиками, которые создают код, и операционными командами, которые развертывают и поддерживают его на продуктивных системах. Это позволяет быстрее выпускать обновления и улучшения с меньшими рисками.

### Диаграммы

**UML** (Unified Modeling Language) — унифицированный язык моделирования. Это язык графического описания для объектного моделирования в области разработки программного обеспечения, который также можно применять для моделирования бизнес-процессов, системного проектирования и отображения организационных структур.

#### Примеры UML диаграмм:
- [[#Диаграмма классов|Диаграмма классов (Class Diagram)]]
- [[#Диаграмма пакетов|Диаграмма пакетов (Package Diagram)]]
- Диаграмма компонентов (Component Diagram)
- Диаграмма потоков данных (Data Flow Diagram)
- [[#Диаграмма прецедентов|Диаграмма прецедентов (Use Case Diagram)]]
- [[#Диаграмма деятельности|Диаграмма деятельности (Activity Diagram)]]
- [[#Диаграмма кооперации|Диаграмма коопераций (Cooperation Diagram)]]
- [[#Диаграмма последовательностей|Диаграмма последовательности (Sequence Diagram)]]
- Диаграмма состояний (State Diagram)

#### Диаграмма классов

**Диаграммы классов** показывают статическую структуру системы, фокусируясь на классах, их атрибутах, методах и связях между ними.

##### Связи между классами:
- *Зависимость* - определяет отношение зависимости (осведомленности)
- *Ассоциация* - общая связь (например, объект A использует объект B)
- *Агрегация* - слабая связь "часть-целое", частный случай ассоциации
- *Композиция* - сильная связь "часть-целое", частный случай агрегации (например, двигатель как часть автомобиля)
- *Наследование* -  отношения типа "является" (например, "Круг" наследуется от "Фигуры")
- *Генерализация* - обобщение
- *Реализация* - отношение выполнения соглашения (реализация интерфейса)

![[Pasted image 20241124150145.png]]

#### Диаграмма пакетов

 **Пакет** (Package) - общий механизм организации элементов модели в группы. Пакет классов – это группа тесно связанных классов (исключение - пакеты утилитных классов). Аспекты:
 - Имеет имя
 - Определяет пространство имен
 - Может быть стереотипирован
 - Может быть импортирован другим пакетом

В контексте связей в OOAD применяются два термина, которые необходимо различать:
- *Cohesion* – единство, спаянность (у классов внутри пакета должно быть высоким)
- *Coupling* – сцепление, сопряжение (должно быть низким между пакетами)

Диаграмма пакетов показывает зависимость пакетов:
![[Pasted image 20241124150432.png]]

#### Диаграмма прецедентов

**Actor** – внешнее по отношению к системе действующее лицо (некто или нечто), взаимодействующее с системой.
**Use case** – описание поведения системы в ответ на запрос извне (запрос Actor-а). Use-case описывает, что делает система с точки зрения Actor-а, но не как эти действия реализованы внутри. Use-case описывает функциональные требования.

| Простой пример:<br>![[Pasted image 20241124115401.png]]                                                           | Иерархия акторов (наследование use-case-ов):<br>![[Pasted image 20241124115856.png]]                                          |
| ----------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| Абстрактные use-case-ы вополняются только в контексте других use-case-ов:<br>![[Pasted image 20241124120227.png]] | Некоторые use-case могут вызываться в контексте других только при некоторых условиях:<br>![[Pasted image 20241124120624.png]] |
| Обобщающий use-case:<br>![[Pasted image 20241124120737.png]]                                                      |                                                                                                                               |

#### Диаграмма деятельности

**Диаграммы деятельности** Используются для описания сценариев (один use-case может включать в себя разные сценарии). Описывают последовательности действий

##### Основные элементы: 
- *Действия* - прямоугольники с закруглёнными углами, представляющие шаги процесса
- *Потоки управления* (переходы) - стрелки, соединяющие действия
- *Блок принятия решения* - ромбы для ветвлений потока
- *Начало и конец* - чёрная точка и мишень соответственно
- *Guard condition* – условие перехода
- *Action* – действие при переходе
- *Fork node* – переход к параллельным деятельностям
- *Sync node* – линейка синхронизации параллельных деятельностей

| Пример авторизации в банкомате:<br>![[Pasted image 20241124121851.png]] | Пример получения наличных из банкомата:<br>![[Pasted image 20241124121943.png]] |
| ----------------------------------------------------------------------- | ------------------------------------------------------------------------------- |

#### Диаграмма кооперации

**Диаграмма коопераций** (диаграмма коммуникаций) в UML — это диаграмма, которая используется для моделирования взаимодействий между объектами системы, чтобы показать, как объекты взаимодействуют друг с другом в контексте выполнения некоторой функции или сценария.

##### Основные цели диаграммы коопераций:
- Отображение взаимодействий между объектами, которые участвуют в конкретном процессе или сценарии.
- Моделирование потоков сообщений между объектами для выполнения задач.
- Визуализация последовательности сообщений и взаимосвязей между объектами, что помогает понять, как взаимодействуют компоненты системы.

![[Pasted image 20241127120952.png]]

##### Элементы диаграммы коопераций:
1. *Объекты*:    
    - Объекты системы, которые участвуют в взаимодействии. Они могут быть представленными прямоугольниками с именем объекта в верхней части.
    - Важно, что объекты отображаются в диаграмме, а не классы, как в диаграмме классов.
2. *Сообщения (Messages)*:
    - Сообщения, которые передаются между объектами.
    - Каждый объект может отправить сообщение другому объекту, и сообщение отображается как стрелка, указывающая от отправителя к получателю.
    - Сообщения могут быть синхронными или асинхронными, и на диаграмме может быть указан порядок сообщений.
3. *Номера сообщений*:
    - Каждое сообщение в диаграмме может иметь уникальный номер или идентификатор для обозначения порядка следования сообщений (например, `1`, `2`, `3`).
    - Это позволяет отследить последовательность вызовов между объектами.
4. *Роли (Roles)*:
    - Роль объекта в процессе. Объект может выполнять одну или несколько ролей в зависимости от взаимодействия.
    - Роли могут быть обозначены как часть имени объекта, что помогает понять, какую задачу выполняет этот объект в взаимодействии.
5. *Линии ассоциаций*:
    - Линии, которые соединяют объекты, показывая, какие объекты могут взаимодействовать друг с другом.
    - Это, по сути, представляет собой связь между участниками диаграммы.
    - Есть 2 вида ассоциаций:
	    - Обычная стрелка: Сообщение передаётся объекту, который уже существует.
		- Стрелка с палочкой: Создаётся новый объект, инициализируемый вызванным сообщением.
6. *Условия и альтернативы*:
    - Некоторые диаграммы коопераций включают условия, которые определяют, будет ли сообщение отправлено, например, в случае выполнения какого-либо условия (логическое ветвление).
    - В таких случаях могут быть использованы различные блоки для альтернативных или цикличных действий.

##### Сравнение с диаграммой последовательности:
- Диаграмма последовательности (Sequence Diagram) — отображает взаимодействие объектов в виде линий времени (ось X — время). Это позволяет удобно следить за последовательностью вызовов.
- Диаграмма коопераций — акцентирует внимание на связях и ассоциациях между объектами и их ролях в процессе.

#### Диаграмма последовательностей

**Диаграмма последовательностей** используется для отображения последовательности обмена сообщениями между объектами системы. Она показывает, какие объекты взаимодействуют, какие сообщения передаются и в каком порядке.

##### Основные элементы диаграммы:
1. *Участники (Actors/Objects)*:    
    - Представляют объекты, классы, компоненты или внешних пользователей системы, которые участвуют в сценарии.
    - Участники располагаются сверху в виде прямоугольников с названием.
    - Например: User, Controller, Database.
2. *Линии жизни (Lifelines)*:
    - Вертикальные пунктирные линии, идущие от участников вниз.
    - Линия жизни показывает период времени, в течение которого объект существует и может участвовать во взаимодействии.
3. *Сообщения (Messages)*:
    - Горизонтальные стрелки между линиями жизни, указывающие на вызовы методов или передачу данных.
        - *Синхронные сообщения* (сплошная стрелка с закрашенным треугольником): указывает на вызов метода, при котором отправитель ждет ответа.
        - *Асинхронные сообщения* (стрелка с пустым треугольником): указывает на вызов, при котором отправитель не ждет ответа.
    - Возвраты (ответы) могут быть обозначены пунктирными стрелками.
4. *Активность (Activation)*:
    - Прямоугольные блоки на линии жизни, показывающие, что объект выполняет действия (активен) в данный момент.
    - Обычно такие блоки появляются при вызове метода и исчезают, когда метод завершается.
5. *Примечания (Notes)*:
    - Дополнительная информация, которую можно привязать к участнику или сообщению.
6. *Условные конструкции (Conditions)*:
    - Используются для отображения ветвлений (if-else) или циклов (loops).
    - На диаграмме обозначаются рамками с ключевыми словами `alt`, `loop` и условием.

##### Как читается диаграмма последовательностей:
- Диаграмма читается сверху вниз.
- Сообщения передаются слева направо (или наоборот) между участниками.
- Акцент делается на порядок вызовов сообщений и взаимодействи

### ООП

#### Этапы ООП
- Реши, какие требуются классы
- Обеспечь полный набор операций для каждого класса
- Явно вырази общность через наследование

#### ОО декомпозиция
- Программная система состоит из объектов, которые обмениваются сообщениями
- Каждый объект обладает:
	- Поведением
	- Состоянием
	- Идентичностью (Уникальностью)
- Схожие объекты объединяются в классы

#### Основные понятия ООП
- **Класс** – абстракция (модель данных и поведения) некоторого множества объектов, обладающих одинаковым поведением
- **Объект** – сущность, обладающая поведением, состоянием и уникальностью
- **Экземпляр** (Instance) – объект, созданный во время исполнения программы

#### Основные принципы ООП
- **Абстракция** - рассмотрение только существенных для решаемой задачи характеристик объекта. Граница между существенными и НЕсущественными характеристиками объекта называется барьером абстракции
- **Инкапсуляция** - сокрытие особенностей реализации, отделение контрактных обязательств абстракции от их реализации
- **Иерархия** - упорядочение абстракций, расположение их по уровням
- **Модульность** - разделение системы на внутренне связные модули, которые слабо связаны между собой

#### Методы ООП
- **Типизация** - способ защититься от использования объектов одного типа вместо другого
- **Полиморфизм** - способ поставить в соответствие некой грамматической конструкции контекстно-зависимую семантику
- **Параллелизм** - способность объекта обрабатывать несколько сообщений одновременно
- **Сохраняемость** - способность объекта сохранять состояние между сеансами работы приложения

#### Принципы SOLID
- Single Responsibility Principle (SRP) — Принцип единственной ответственности:
	- Каждый класс должен иметь только одну причину для изменения. Это значит, что класс должен выполнять лишь одну задачу или быть ответственным за одну область функциональности.
- Open/Closed Principle (OCP) — Принцип открытости/закрытости:
	- Классы должны быть открыты для расширения, но закрыты для модификации. Это означает, что функциональность класса должна расширяться без изменения его исходного кода.
- Liskov Substitution Principle (LSP) — Принцип подстановки Барбары Лисков:
	- Объекты подклассов должны заменять объекты базового класса без нарушения функциональности программы. Другими словами, подкласс должен быть полностью совместим с базовым классом.
- Interface Segregation Principle (ISP) — Принцип разделения интерфейсов:
	- Клиенты не должны быть вынуждены реализовывать интерфейсы, которые они не используют. Лучше иметь несколько узкоспециализированных интерфейсов, чем один общий.
- Dependency Inversion Principle (DIP) — Принцип инверсии зависимостей:
	- Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей, а детали должны зависеть от абстракций.

