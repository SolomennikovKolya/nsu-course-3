
### Полезномти
- [Медия](https://www.nsumedia.ru/main_potok/third_course/fifth_semester/analysis)
- [Сайт Мухортова](https://ai.nsu.ru/projects/ooad/documents)
- [Файлы от Мухортова](https://ai.nsu.ru/projects/ooad/files)
- [Astah (редактор UML диаграмм)](https://astah.net/products/astah-community/)
- [Записи лекций (Максим Муратов)](https://www.youtube.com/playlist?list=PLHAiwjMOQSmzstcpt2613l1AZRGIG5gTv)

#### Критерии оценки:
- 5 - Проект доведен до конца
- 4 - Начат Этап 4
- 3 - Проект готов к старту Этапа 4
- 2 - Проект НЕ готов к старту Этапа 4 = не закончен Этап 3

### Этапы:
- [ ] 0. разбиться на пары и придумать проект
- [ ] 1. Провести анализ требований к проекту
- [ ] 2. Построить аналитическую UML модель
- [ ] 3. Выработать архитектуру и дизайн системы
- [ ] 4. Реализовать проект на выбранной технологии
- [ ] По всем этапам: создать проектную документацию

#### Этап 0
1. Придумать проект и написать к нему Vision
2. Vision – текст 1/2 страницы из 3 абзацев
3. Введение в предметную область (простое описание, которое позволит непосвященному понять, о чем далее пойдет речь)
4. Известные проблемы предметной области 
5. Предлагаемое решение (какие именно проблемы из предыдущего абзаца и как именно решит ваш проект)

#### Этап 1 (Анализ требований)
Типы требований:
- Функциональные - набор функций, которые система должна предоставить пользователям
- Нефункциональные (например требования к  производительности, отказоустойчивости, нагрузочной способности и т.д.)

### OOAD

#### Объектно-ориентированный анализ

**OOA** (Object-Oriented Analysis) – это методология, в которой требования к системе воспринимаются с точки зрения классов и объектов, выявленных в предметной области.

Этапы объектно-ориентированного анализа:
1. Определение требований:
    - Сбор и анализ функциональных и нефункциональных требований.
    - Идентификация ключевых объектов системы.
2. Моделирование системы:
    - Построение _диаграмм вариантов использования_ (Use Case Diagrams) для определения взаимодействия пользователя с системой.
    - Разработка диаграмм классов, чтобы представить основные объекты и их атрибуты.
3. Анализ поведения:
    - Построение _диаграмм последовательности_ (Sequence Diagrams) и _диаграмм взаимодействия_, чтобы отразить взаимодействие объектов во времени.
4. Уточнение моделей:
    - Проверка моделей на корректность, полноту и непротиворечивость.
    - Уточнение и детализация атрибутов, методов и связей.

#### Объектно-ориентированное проектирование

**OOD** (Object-Oriented Design) – методология проектирования, соединяющая в себе процесс объектной декомпозиции и приемы представления логической, физической, а также статической и динамическо моделей проектируемой системы. Этот подход применяется в рамках объектно-ориентированного программирования (ООП) и фокусируется на создании модульной и масштабируемой архитектуры.

| Тип модели       | Что описывает                                                                                      | Фокус                     | Примеры                                     |
| ---------------- | -------------------------------------------------------------------------------------------------- | ------------------------- | ------------------------------------------- |
| **Логическая**   | Концептуальная структура системы без привязки к технической реализации                             | Что система должна делать | DFD (Диаграммы потока данных), ER-диаграммы |
| **Физическая**   | Техническая реализация системы                                                                     | Как система реализована   | Схемы архитектуры, таблицы БД               |
| **Статическая**  | Структура системы в конкретный момент времени. Показывает объекты, их свойства и связи между ними. | Состав и связи элементов  | UML-диаграммы классов, компонентов          |
| **Динамическая** | Поведение системы во времени. Отражает переходы состояний, вызовы методов, выполнение процессов    | Изменения и заимодействие | UML-диаграммы последовательности            |

Этапы объектно-ориентированного проектирования:
1. Анализ требований: изучение требований системы и выявление ключевых объектов.
2. Определение классов и объектов:
    - Выявление сущностей и их взаимосвязей.
    - Определение атрибутов и методов для каждого класса.
3. Разработка архитектуры системы:
    - Создание _диаграмм классов_ и других UML-диаграмм.
    - Определение взаимодействий между объектами (диаграммы последовательности, диаграммы взаимодействия).
4. Определение интерфейсов и модулей: проектирование способов взаимодействия между объектами и внешними компонентами.
5. Реализация: кодирование классов и объектов на языке программирования.

#### DevOps

**DevOps** — это сочетание философий, практик и инструментов, направленных на интеграцию и автоматизацию процессов между разработкой программного обеспечения (**Dev**) и IT-операциями (**Ops**). Основная цель DevOps — ускорить процесс разработки, тестирования и развертывания программного обеспечения, улучшив при этом качество и стабильность продукта.

DevOps ориентирован на создание более тесного взаимодействия между разработчиками, которые создают код, и операционными командами, которые развертывают и поддерживают его на продуктивных системах. Это позволяет быстрее выпускать обновления и улучшения с меньшими рисками.

### Диаграммы

**UML** (Unified Modeling Language) — унифицированный язык моделирования

Некторые UML диаграммы:
1. Структурные диаграммы  - показывают статическую структуру системы и её частей на разных уровнях абстракции и реализации, а также их взаимосвязь:
	- [x] **Диаграммы классов** (Class Diagrams)
	- [x] **Диаграммы пакетов** (Package Diagrams) 
	- [ ] **Диаграммы компонентов** (Component Diagrams)
	- [ ] **Диаграммы потоков данных** (Data Flow Diagrams)
1. Диаграммы поведения  - описывают систему динамически:
	- [x] **Диаграмма вариантов использования** (Use Case Diagram)
	- [x] **Диаграммы деятельности** (Activity Diagrams)
	- [ ] **Диаграммы состояний** (State Diagrams)
	- [ ] **Диаграммы последовательности** (Sequence Diagrams)

#### Use-case диаграмма

**Actor** – внешнее по отношению к системе действующее лицо (некто или нечто), взаимодействующее с системой
**Use case** – описание поведения системы в ответ на запрос извне (запрос Actor-а). Use-case описывает, что делает система с точки зрения Actor-а, но не как эти действия реализованы внутри. Use-case описывает функциональные требования

| Простой пример:<br>![[Pasted image 20241124115401.png]]                                                           | Иерархия акторов (наследование use-case-ов):<br>![[Pasted image 20241124115856.png]]                                          |
| ----------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| Абстрактные use-case-ы вополняются только в контексте других use-case-ов:<br>![[Pasted image 20241124120227.png]] | Некоторые use-case могут вызываться в контексте других только при некоторых условиях:<br>![[Pasted image 20241124120624.png]] |
| Обобщающий use-case:<br>![[Pasted image 20241124120737.png]]                                                      |                                                                                                                               |

#### Диаграмма деятельности

Используются для описания сценариев (один use-case может включать в себя разные сценарии). Описывают последовательности действий

Основные элементы: 
- Действия - прямоугольники с закруглёнными углами, представляющие шаги процесса
- Потоки управления (переходы) - стрелки, соединяющие действия
- Блок принятия решения - ромбы для ветвлений потока
- Начало и конец - чёрная точка и мишень соответственно
- Guard condition – условие перехода
- Action – действие при переходе
- Fork node – переход к параллельным деятельностям
- Sync node – линейка синхронизации параллельных деятельностей

| Пример авторизации в банкомате:<br>![[Pasted image 20241124121851.png]] | Пример получения наличных из банкомата:<br>![[Pasted image 20241124121943.png]] |
| ----------------------------------------------------------------------- | ------------------------------------------------------------------------------- |

#### Диаграмма классов

Диаграммы классов показывают статическую структуру системы, фокусируясь на классах, их атрибутах, методах и связях между ними.

Связи между классами:
- Зависимость - определяет отношение зависимости (осведомленности)
- Ассоциация - общая связь (например, объект A использует объект B)
- Агрегация - слабая связь "часть-целое", частный случай ассоциации
- Композиция - сильная связь "часть-целое", частный случай агрегации (например, двигатель как часть автомобиля)
- Наследование -  отношения типа "является" (например, "Круг" наследуется от "Фигуры")
- Генерализация - обобщение
- Реализация - отношение выполнения соглашения (реализация интерфейса)

![[Pasted image 20241124150145.png]]

#### Диаграмма пакетов

 **Пакет** (Package) - общий механизм организации элементов модели в группы. Пакет классов – это группа тесно связанных классов (исключение - пакеты утилитных классов) 
 - Имеет имя
 - Определяет пространство имен
 - Может быть стереотипирован
 - Может быть импортирован другим пакетом

В контексте связей в OOAD применяются два термина, которые необходимо различать:
- Cohesion – единство, спаянность (у классов внутри пакета должно быть высоким)
- Coupling – сцепление, сопряжение (должно быть низким между пакетами)

Диаграмма авкетов показывает зависимость пакетов:
![[Pasted image 20241124150432.png]]

### ООП

#### Этапы ООП
- Реши, какие требуются классы
- Обеспечь полный набор операций для каждого класса
- Явно вырази общность через наследование

#### ОО декомпозиция
- Программная система состоит из объектов, которые обмениваются сообщениями
- Каждый объект обладает:
	- Поведением
	- Состоянием
	- Идентичностью (Уникальностью)
- Схожие объекты объединяются в классы

#### Основные понятия ООП
- **Класс** – абстракция (модель данных и поведения) некоторого множества объектов, обладающих одинаковым поведением
- **Объект** – сущность, обладающая поведением, состоянием и уникальностью
- **Экземпляр** (Instance) – объект, созданный во время исполнения программы

#### Основные принципы ООП
- **Абстракция** - рассмотрение только существенных для решаемой задачи характеристик объекта. Граница между существенными и НЕсущественными характеристиками объекта называется барьером абстракции
- **Инкапсуляция** - сокрытие особенностей реализации, отделение контрактных обязательств абстракции от их реализации
- **Иерархия** - упорядочение абстракций, расположение их по уровням
- **Модульность** - разделение системы на внутренне связные модули, которые слабо связаны между собой

#### Методы ООП
- **Типизация** - способ защититься от использования объектов одного типа вместо другого
- **Полиморфизм** - способ поставить в соответствие некой грамматической конструкции контекстно-зависимую семантику
- **Параллелизм** - способность объекта обрабатывать несколько сообщений одновременно
- **Сохраняемость** - способность объекта сохранять состояние между сеансами работы приложения

#### Принципы SOLID
- Single Responsibility Principle (SRP) — Принцип единственной ответственности:
	- Каждый класс должен иметь только одну причину для изменения. Это значит, что класс должен выполнять лишь одну задачу или быть ответственным за одну область функциональности.
- Open/Closed Principle (OCP) — Принцип открытости/закрытости:
	- Классы должны быть открыты для расширения, но закрыты для модификации. Это означает, что функциональность класса должна расширяться без изменения его исходного кода.
- Liskov Substitution Principle (LSP) — Принцип подстановки Барбары Лисков:
	- Объекты подклассов должны заменять объекты базового класса без нарушения функциональности программы. Другими словами, подкласс должен быть полностью совместим с базовым классом.
- Interface Segregation Principle (ISP) — Принцип разделения интерфейсов:
	- Клиенты не должны быть вынуждены реализовывать интерфейсы, которые они не используют. Лучше иметь несколько узкоспециализированных интерфейсов, чем один общий.
- Dependency Inversion Principle (DIP) — Принцип инверсии зависимостей:
	- Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей, а детали должны зависеть от абстракций.

### Инструменты

#### Astah

Astah — это программное обеспечение для моделирования, которое используется для проектирования и документирования различных аспектов разработки программного обеспечения. Оно предоставляет инструменты для создания диаграмм.

Основные возможности Astah:
1. UML (Unified Modeling Language): поддержка стандартов UML для визуального проектирования.
2. Mind Mapping: возможность создавать диаграммы ментальных карт.
3. ER-моделирование: поддержка диаграмм сущность-связь (ERD) для работы с базами данных.
4. Интеграция: экспорт и импорт диаграмм, поддержка популярных форматов.
5. Командная работа: возможности для совместной работы над проектами
