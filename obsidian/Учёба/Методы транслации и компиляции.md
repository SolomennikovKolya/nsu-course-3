
### Полезности
- [Медия](https://www.nsumedia.ru/main_potok/third_course/fifth_semester/translation_compilation)
- [Гугл-диск с материалами](https://drive.google.com/drive/folders/14Iz5VGeiokN-9z5kkJT9iDsWU5N3YrhO)
- [Материалы Семинаров](https://disk.yandex.ru/d/9Z3XRJe-RahEmQ)
- [Репозиторий с flow9](https://github.com/area9innovation/flow9)
- [Документация по flow9](https://github.com/area9innovation/flow9/blob/master/doc/flow.markdown)
- [Единственное видео по flow9](https://www.youtube.com/watch?v=RiHw3Wb28yA)[](http://savefrom.net/?url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DRiHw3Wb28yA&utm_source=opera-chromium&utm_medium=extensions&utm_campaign=link_modifier "Получи прямую ссылку")
- [Решалка для z3](https://jfmc.github.io/z3-play/)
- [Записи лекций (Максим Муратов)](https://www.youtube.com/playlist?list=PLHAiwjMOQSmynYxSFQZcX3F1AmAVKa5Xk)
- [Отзывы об экзаменах](https://docs.google.com/spreadsheets/d/1f7Ul7q0BK61sFfOVHNRiad904Ts8MQDXsimatGEt5S4/edit?gid=2010672661#gid=2010672661)
- [Отзывы о преподавателях](https://docs.google.com/document/d/16hbDYg7dMCo3DLn8NgGGI-eOoDxosUn0yKN1fwrPcsA/edit#heading=h.jcnhp9p1wgko)
- [Отзывы о преподавателях 2.0](https://docs.google.com/document/d/11VQiY0Cr86lxh0qlV4kj7X857_xOVnfCdQMilYKfob0/edit#heading=h.z9gt69h3lhwi)

### Лабы
1. блок (до 31 октября)
	- [x] 1
	- [x] 2
	- [x] 3
	- [x] 4
2. блок (до 11 ноября)
	- [ ] 5
	- [ ] 6
	- [ ] 7
	- [ ] 8
	- [ ] 9
	- [ ] 10
3. блок (до 27 декабря)
	- [ ] 11
	- [ ] 12
4. блок
	- [ ] 13
	- [ ] 14
	- [ ] 15

### Условия Лаб

1. Напишите функцию, которая преобразует массив целых чисел в массив строк
	- Например: [1, 2, 3] → ["1", "2", "3"]. Выведите этот массив
	- Используйте функции: `map`, `i2s`, `strGlue`, `println`

2. Напишите функцию, которая вычисляет сумму всех целых чисел в заданном массиве
	- Например [1, 2, 3] должно выдасть 6
	- Используйте функцию: `fold` 

3. Напишите функцию `fib(n : int) -> [int]`, которая вычисляет массив из всех первых n чисел Фибоначчи: 0, 1, 1, 2, 3, 5, . . . Сделайте ее а) рекурсивной б) с хвостовой рекурсией в) со ссылками на массив, сложностью O(n).
	- Используйте функции: `fold`, `concat`, `refArrayPush`

4. Дан массив целых чисел [n1, ..., nk] и число m, найдите все пары индексов (i, j) , такие, что ni + nj == m. Сигнатура функции: `inds(a : [int], m : int) -> [Pair<int, int>]`
	- Усложнение: функция должна иметь сложность O(nlog(n)), а не O(n^2)
	- Используйте функции: `foldi`, `makeTree`, `setTree`, `lookupTree`

5. Напишите PEG-синтаксический анализатор для грамматики простых арифметических выражений (с const int-ами и операциями + и \*), который генерирует AST-дерево. Воспользуйтесь библиотекой `lingo`. Преобразовать AST-дерево арифметических выражений обратно в строку. Реализуйте калькулятор, который вычисляет значение арифметического выражения. 

6. Реализуйте калькулятор, который использует выражения с обратной польской нотацией (RPN) и вычисляет их значения. Напишите функции перевода из арифметических выражений в RPN и обратно. 

7. Обогатите язык арифметических выражений вычитанием, делением, отрицанием и переменными. Новый язык представляет собой язык алгебраических выражений. Напишите функцию, которая вычисляет значение заданного алгебраического выражения с заданным набором значений переменные (внимание: значение является рациональным). 8. Напишите функцию символьного вывода данного алгебраического выражения с помощью данной переменной. Напишите функцию упрощения, которая сокращает избыточные константы, такие как 1 + 0 и x ∗ 0. 9. Напишите функцию, которая преобразует алгебраическое выражение в рациональную функцию ( дробь многочленов). 10. Напишите символьную функцию упрощения, которая находит наименьшую форму данного алгебраического выражения, управляемую набором тождеств. • Простой недетерминированный язык NeMo 11. Реализуйте синтаксический анализатор NeMo. 12. Реализовать виртуальную машину NeMo, которая выполняет программы, переведенные с NeMo. • Формальная проверка программ NeMo 13. Реализовать язык аннотированных программ NeMo. 14. Реализовать генерацию условий проверки для NeMo. 15. Реализуйте переводчик с аннотированных программ NeMo на язык ввода z3.

### Команды
- `code ~/prg/flow9` - запуск VS code (потом надо зайти в dev-контейнер)
- `F1` + `Dev Containers: Reopen in Container` - запуск контейнера
- `cd mtk` - переход в рабочую директорию
- `flowc1 jar=task1/main.jar task1/main.flow` - компиляция в jar
- `java -jar task1/main.jar` - запуск

### Технологии

**Dev-контейнеры** (или development containers) — это среда для разработки, которая изолирована от основной системы и работает на базе контейнерных технологий, таких как Docker. Преимущества dev-контейнеров:
- Изоляция: Код и зависимости проекта изолированы от основной системы.
- Переносимость: Одна и та же среда разработки может быть воспроизведена на любой машине.

**Контейнер** — это легковесная виртуализированная среда, которая включает всё необходимое для запуска приложения, включая библиотеки, зависимости и конфигурации операционной системы. Docker-контейнеры запускаются на базе Docker-образов.

**Docker-образ** — это статическая, неизменяемая шаблонная среда, которая содержит всё необходимое для запуска приложения, которые содержат все нужные зависимости и могут быть настроены через Dockerfile или специальные конфигурационные файлы. Это шаблоны для создания контейнеров.

**Xming** — это реализация **X-сервера** для Windows, который позволяет отображать графические приложения из среды Linux/Unix на вашем локальном компьютере с Windows.

### Основные принципы функциональных языков:

1. **Чистые функции**: Чистая функция — это функция, которая всегда возвращает один и тот же результат для одних и тех же входных данных и **не имеет побочных эффектов**. Это значит, что функция не изменяет состояние программы вне своей области, что делает её предсказуемой и лёгкой для тестирования.

2. **Имутабельность**: Данные в функциональных языках, как правило, **неизменяемы**. Вместо того чтобы изменять переменные, создаются новые значения. Это предотвращает ошибки, связанные с изменением состояния программы в разных местах.

3. **Функции высшего порядка**: Функции в функциональных языках могут быть переданы как аргументы другим функциям, возвращаться из функций, и сохраняться в переменные. Это позволяет создавать абстракции, которые делают код более гибким и лаконичным.

4. **Ленивые вычисления**: В некоторых функциональных языках (например, в Haskell) вычисления происходят только тогда, когда они действительно нужны. Это называется **ленивыми вычислениями** (lazy evaluation), и это позволяет работать с потенциально бесконечными структурами данных.

5. **Рекурсия вместо циклов**: Вместо использования циклов (как `for` или `while`) в функциональных языках часто применяется **рекурсия** для выполнения повторяющихся операций.

6. **Декларативный стиль**: Функциональные программы часто пишутся в **декларативном стиле**, что означает, что вы описываете **что** должно быть сделано, а не **как** это сделать, как в императивных языках.

### flow9

**Flow9** — это функциональный, асинхронный язык программирования.
- Встроенная поддержка асинхронного программирования
- Flow9 позволяет разрабатывать приложения для разных платформ
- Код на языке Flow9 может как компилироваться в исполняемые файлы для Linux, iOS, Android, Windows и macOS, так и транслироваться в форму web-приложений на HTML5/JavaScript (WebAssembly) или в исходные тексты на языках Java, D, Lisp, ML и C++

Особенности:
- Вместо циклов `for` и `while` есть только `map` и `mapi` (используется для итерации с получением результата), а также `iter` и `iteri` (просто для итераций)
- Любые переменные неизменяемы (`mutable` полей структуры)
- Язык основан на выражениях, а не на операторах:
	- Нет оператора `return`
	- Возвращаемое значение функции - результат последнего вычисленного выражения
- Приведение типов работает только через явную функцию `cast(1 : int -> double);`
	- Также есть сокращения `i2d`, `d2i`, `i2s`, `s2i`, `d2s`, `s2d`, `b2s

Подключение модулей:
- `import module1;`
- `import formdesigner/types/generator;` - путь к файлу

Внешние имена, доступные другим модулям, объявляются в блоке `export`:
- `export { bar(i : int, s : string) -> void; }`

Простые типы:
- `x : bool`
- `x : int` - 32 bit
- `x : double` - 64 bit
- `x : string` - 16 bit на символ (UTF 16)

Производные типы:
- `x : [int];` - массив
- `x : ref int;` - ссылка (сама по себе изменяемая, но значение по ссылке изменить нельзя)
	- `x : ref double = ref 1.0;` - инициализация ссылки
	- `x := 2.0;` - обновление значения
	- `println(^r);` - разыменование
- `Mystruct(arg1 : int, arg2 : double);` - структура:
	- `Mystruct : (arg1 : int, arg2 : double);` - другой вариант объявления
	- `val = Mystruct(1, 2.0);` - инстанцирование
	- `val.structname` - получение имени структуры
- `Form ::= Text, Grid, Picture;` - структуры можно соединять в объединения через `::=`
- `flow` - любой тип (как `Object` в Java). К нему и от него можно привести хоть что
- `native` - может хранить нативные функции

Опциональные типы:
- `None()` - как null в других языках
- `Some(value)` - обёртка для значения, чтобы указать, что оно есть
- `Maybe<?>` - объединение, которое содержит либо `None()` либо `Some(value : ?)`
	- `<?>` - как дженерик (в одном выражении `?` - один любой тип, `??` - другой тип и т.д.)
	- `??` - разыменование опционального типа `Maybe<?>`
	- `m ?? m + 2 : 0;` - то же самое что и `switch (m) {Some(v): v + 2; None(): 0;}`

Функции:
- `assert(b : bool, t : string) -> void;` - проверка (нужен модуль `runtime`)
- `concat : ([?], [?]) -> [?];` - конкатенация массивов
- `length : ([?]) -> int;` - длина массива
- `map : ([?], (?)->??) -> [??];` - применяет функцию к каждому элементу массива
- `mapi : ([?], (int, ?)->??) -> [??];` - можно использовать индексом элемента в массиве
- `findi : (a : [?], fn : (?) -> bool) -> Maybe<int>;` - поиск по массиву
- `fold : ([?], init : ??, fn : (??, ?)->??) -> ??;` - редукция массива
- `replace : ([?], int, ?) -> [?];` - возвращает новый массив с изменённым элементом
- `arrayPush(array : [?], value : ?) -> [?];` - добавление элемента в массив
- `subrange : ([?], index : int, length : int) -> [?];` - срез массива
- `tail(a : [?]) -> [?];` - возвращает массив без первого элемента
- `maybeApply : (m: Maybe<?>, f: (?) -> void) -> void;` - применяет `f` к `m` если `m` не None
- `either(m : Maybe<?>, alternative : ?) -> ?;` - m == None ? alternative : m
- `filter : (a : [?], test : (?) -> bool) -> [?];` - фильтрация элементов массива

Лямбда функции:
- Пример: `\name -> if (name == "Bob") true else false`
- Символ `\` указывает на то, что начинается лямбда-функция.
- `name` — это параметр, который принимает эта лямбда-функция. 
- `->` разделяет параметры функции и её тело.

pipe-forward:
- `x |> f` всё равно что `f(x)`
- Пример использования:
```
// Calculate sum of squares of even elements
sum = [0,1,2,3,4,5,6,7,8,9]
	|> (\lst -> filter(lst, \x->x%2==0))
	|> (\filtered -> map(filtered, \x->x*x))
	|> (\squared -> fold(squared, 0, \a, x -> a+x));
```

### DSL и GPL

**Предметно-ориентированные языки** (Domain-Specific Languages, DSL) — это языки программирования, которые созданы для решения задач в конкретной предметной области. В отличие от **языков общего назначения** (General-Purpose Languages, GPL), таких как Python, C++ или Java, которые предназначены для решения широкого круга задач, DSL обычно ограничены одной областью применения и имеют синтаксис и семантику, адаптированные для этой области.

Классификация DSL:
1. Внутренние (Embedded DSL) — это DSL, встроенные в языки общего назначения. Они используют синтаксис и возможности основного языка, при этом адаптируясь для специфичной предметной области. Пример:
    - SQLAlchemy в Python для работы с базами данных.
    - RSpec в Ruby для тестирования.
2. Внешние DSL — это отдельные языки со своим синтаксисом, часто требующие собственного компилятора или интерпретатора. Пример:
    - SQL — язык запросов к базам данных.
    - HTML — язык разметки для создания веб-страниц.
    - RegEx (регулярные выражения) — для работы с текстовыми шаблонами.

Примеры DSL:
- SQL (Structured Query Language) — для управления базами данных.
- CSS (Cascading Style Sheets) — для описания внешнего вида веб-страниц.
- RegEx (Regular Expressions) — для поиска и работы с текстом.
- LaTeX — для верстки и форматирования текстовых документов.
- MATLAB — для математического моделирования и вычислений.
- GraphQL — для выполнения запросов к API.

### AST и CST

**AST** (Abstract Syntax Tree, абстрактное синтаксическое дерево) — это структура данных, представляющая синтаксис программного кода в виде дерева. В узлах дерева находятся элементы программы, такие как операторы, переменные, функции, выражения и т.д. AST используется в компиляторах и интерпретаторах для анализа кода, его оптимизации и преобразования в машинный код.

Ключевые моменты:
1. Абстракция: В отличие от конкретного синтаксического дерева (CST — Concrete Syntax Tree), AST не включает все детали исходного кода, такие как пробелы, комментарии, скобки и т.д. Оно фокусируется только на структурных элементах, важных для семантического анализа.
2. Структура: AST представляет программу в виде иерархии, где:
    - Ветви (потомки) дерева представляют операнды выражений или компоненты операторов.
    - Листья дерева представляют конкретные значения, переменные или литералы.

Пример AST для выражения `x = 2 + 3 * 5`:
```python
    Assign
   /      \
Variable   +
   |     /   \
   x    2     *
             / \
            3   5
```

**CST** (Concrete Syntax Tree / Parse tree) - дерево разбора, также известное как синтаксическое дерево или конкретное синтаксическое дерево, — это дерево, которое представляет структуру исходного кода программы с учётом всех синтаксических элементов, таких как ключевые слова, операторы, символы и даже скобки. Оно отображает конкретный синтаксис программы, то есть, как она написана, с полной детализацией всех элементов и порядка.

Применение Parse Tree:
1. Компиляторы и интерпретаторы:
    - Parse tree — это промежуточное представление программы, которое создается на этапе синтаксического анализа.
    - Компиляторы строят parse tree, чтобы убедиться, что программа синтаксически корректна.
    - Дальнейшие этапы компиляции могут трансформировать parse tree в AST или сразу в байт-код.
2. Обработка естественного языка:
	- В задачах обработки естественного языка (NLP) parse tree используется для анализа предложений, чтобы понять их грамматическую структуру.

### Грамматики

**Грамматика** задаёт набор правил, которые описывают допустимые структуры языка. Эти правила состоят из **нетерминалов** (абстрактных элементов) и **терминалов** (конкретных символов или токенов).

Например, для арифметических выражений можно использовать следующую грамматику: 
```r
E -> E + T | T
T -> T * F | F
F -> (E) | number
```
В этой грамматике:
- `E` — выражение (Expression)
- `T` — терм (Term)
- `F` — фактор (Factor)
- Ветвь `E -> E + T` соответствует сложению
- Ветвь `T -> T * F` соответствует умножению

**PEG** (Parsing Expression Grammar) — это грамматика выражений для парсинга, которая представляет собой альтернативу традиционным контекстно-свободным грамматикам (CFG) для описания синтаксиса языка. PEG используется для синтаксического анализа (парсинга) и характеризуется тем, что она детерминирована и не допускает неоднозначности, что отличает её от традиционных грамматик, таких как CFG.

Основные особенности PEG:
1. Детерминированность:    
    - В отличие от контекстно-свободных грамматик (CFG), где могут быть неоднозначности и несколько возможных разборов одного и того же выражения (например, левая и правая ассоциативность), PEG всегда выбирает первое успешное правило. Это делает её анализ предсказуемым и быстрым.
2. Приоритет правил:
    - В PEG правила проверяются последовательно сверху вниз, и как только одно из них успешно применяется, дальнейшие правила не проверяются. Это похоже на поведение оператора `if-else` в программировании.

**lingo** - технология для создания DSL и синтаксических анализаторов (парсеров). Это язык, который полезен для реализации лексического анализа и построения AST для компиляторов или интерпретаторов. Сам Lingo интерпретируется программой flow и основан на PEG.