
### Полезности
- [Медия](https://www.nsumedia.ru/main_potok/third_course/fifth_semester/translation_compilation)
- [Гугл-диск с материалами](https://drive.google.com/drive/folders/14Iz5VGeiokN-9z5kkJT9iDsWU5N3YrhO)
- [Материалы Семинаров](https://disk.yandex.ru/d/9Z3XRJe-RahEmQ)
- [Репозиторий с flow9](https://github.com/area9innovation/flow9)
- [Единственное видео по flow9](https://www.youtube.com/watch?v=RiHw3Wb28yA)[](http://savefrom.net/?url=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DRiHw3Wb28yA&utm_source=opera-chromium&utm_medium=extensions&utm_campaign=link_modifier "Получи прямую ссылку")
- [Решалка для z3](https://jfmc.github.io/z3-play/)
- [Записи лекций (Максим Муратов)](https://www.youtube.com/playlist?list=PLHAiwjMOQSmynYxSFQZcX3F1AmAVKa5Xk)
- [Отзывы об экзаменах](https://docs.google.com/spreadsheets/d/1f7Ul7q0BK61sFfOVHNRiad904Ts8MQDXsimatGEt5S4/edit?gid=2010672661#gid=2010672661)
- [Отзывы о преподавателях](https://docs.google.com/document/d/16hbDYg7dMCo3DLn8NgGGI-eOoDxosUn0yKN1fwrPcsA/edit#heading=h.jcnhp9p1wgko)
- [Отзывы о преподавателях 2.0](https://docs.google.com/document/d/11VQiY0Cr86lxh0qlV4kj7X857_xOVnfCdQMilYKfob0/edit#heading=h.z9gt69h3lhwi)

### Лабы
1. блок (до 31 октября)
	- [x] 1
	- [ ] 2
	- [ ] 3
	- [ ] 4
2. блок (до 30 ноября)
	- [ ] 5
	- [ ] 6
	- [ ] 7
	- [ ] 8
	- [ ] 9
	- [ ] 10
3. блок (до 27 декабря)
	- [ ] 11
	- [ ] 12
4. блок
	- [ ] 13
	- [ ] 14
	- [ ] 15

### Команды
- `code ~/prg/flow9` - запуск VS code (потом надо зайти в dev-контейнер)
- `F1` + `Dev Containers: Reopen in Container` - запуск контейнера
- `cd mtk` - переход в рабочую директорию
- `flowc1 jar=task1/main.jar task1/main.flow` - компиляция в jar
- `java -jar task1/main.jar` - запуск

### Технологии

**Dev-контейнеры** (или development containers) — это среда для разработки, которая изолирована от основной системы и работает на базе контейнерных технологий, таких как Docker. Преимущества dev-контейнеров:
- Изоляция: Код и зависимости проекта изолированы от основной системы.
- Переносимость: Одна и та же среда разработки может быть воспроизведена на любой машине.

**Контейнер** — это легковесная виртуализированная среда, которая включает всё необходимое для запуска приложения, включая библиотеки, зависимости и конфигурации операционной системы. Docker-контейнеры запускаются на базе Docker-образов.

**Docker-образ** — это статическая, неизменяемая шаблонная среда, которая содержит всё необходимое для запуска приложения, которые содержат все нужные зависимости и могут быть настроены через Dockerfile или специальные конфигурационные файлы. Это шаблоны для создания контейнеров.

**Xming** — это реализация **X-сервера** для Windows, который позволяет отображать графические приложения из среды Linux/Unix на вашем локальном компьютере с Windows.

### Основные принципы функциональных языков:

1. **Чистые функции**: Чистая функция — это функция, которая всегда возвращает один и тот же результат для одних и тех же входных данных и **не имеет побочных эффектов**. Это значит, что функция не изменяет состояние программы вне своей области, что делает её предсказуемой и лёгкой для тестирования.

2. **Имутабельность**: Данные в функциональных языках, как правило, **неизменяемы**. Вместо того чтобы изменять переменные, создаются новые значения. Это предотвращает ошибки, связанные с изменением состояния программы в разных местах.

3. **Функции высшего порядка**: Функции в функциональных языках могут быть переданы как аргументы другим функциям, возвращаться из функций, и сохраняться в переменные. Это позволяет создавать абстракции, которые делают код более гибким и лаконичным.

4. **Ленивые вычисления**: В некоторых функциональных языках (например, в Haskell) вычисления происходят только тогда, когда они действительно нужны. Это называется **ленивыми вычислениями** (lazy evaluation), и это позволяет работать с потенциально бесконечными структурами данных.

5. **Рекурсия вместо циклов**: Вместо использования циклов (как `for` или `while`) в функциональных языках часто применяется **рекурсия** для выполнения повторяющихся операций.

6. **Декларативный стиль**: Функциональные программы часто пишутся в **декларативном стиле**, что означает, что вы описываете **что** должно быть сделано, а не **как** это сделать, как в императивных языках.

### flow9

**Flow9** — это функциональный, асинхронный язык программирования.
- Встроенная поддержка асинхронного программирования
- Flow9 позволяет разрабатывать приложения для разных платформ
- Код на языке Flow9 может как компилироваться в исполняемые файлы для Linux, iOS, Android, Windows и macOS, так и транслироваться в форму web-приложений на HTML5/JavaScript (WebAssembly) или в исходные тексты на языках Java, D, Lisp, ML и C++

Особенности:
- Вместо циклов `for` и `while` есть только `map` и `mapi` (используется для итерации с получением результата), а также `iter` и `iteri` (просто для итераций)
- Любые переменные неизменяемы (`mutable` полей структуры)
- Язык основан на выражениях, а не на операторах:
	- Нет оператора `return`
	- Возвращаемое значение функции - результат последнего вычисленного выражения
- Приведение типов работает только через явную функцию `cast(1 : int -> double);`
	- Также есть сокращения `i2d`, `d2i`, `i2s`, `s2i`, `d2s`, `s2d`, `b2s

Подключение модулей:
- `import module1;`
- `import formdesigner/types/generator;` - путь к файлу

Внешние имена, доступные другим модулям, объявляются в блоке `export`:
- `export { bar(i : int, s : string) -> void; }`

Простые типы:
- `x : bool`
- `x : int` - 32 bit
- `x : double` - 64 bit
- `x : string` - 16 bit на символ (UTF 16)

Производные типы:
- `x : [int];` - массив
- `x : ref int;` - ссылка (сама по себе изменяемая, но значение по ссылке изменить нельзя)
	- `x : ref double = ref 1.0;` - инициализация ссылки
	- `x := 2.0;` - обновление значения
	- `println(^r);` - разыменование
- `Mystruct(arg1 : int, arg2 : double);` - структура:
	- `Mystruct : (arg1 : int, arg2 : double);` - другой вариант объявления
	- `val = Mystruct(1, 2.0);` - инстанцирование
	- `val.structname` - получение имени структуры
- `Form ::= Text, Grid, Picture;` - структуры можно соединять в объединения через `::=`
- `flow` - любой тип (как `Object` в Java). К нему и от него можно привести хоть что
- `native` - может хранить нативные функции

Опциональные типы:
- `None()` - как null в других языках
- `Some(value)` - обёртка для значения, чтобы указать, что оно есть
- `Maybe<?>` - объединение, которое содержит либо `None()` либо `Some(value : ?)`
	- `<?>` - как дженерик (в одном выражении `?` - один любой тип, `??` - другой тип и т.д.)
	- `??` - разыменование опционального типа `Maybe<?>`
	- `m ?? m + 2 : 0;` - то же самое что и `switch (m) {Some(v): v + 2; None(): 0;}`

Функции:
- `assert(b : bool, t : string) -> void;` - проверка (нужен модуль `runtime`)
- `concat : ([?], [?]) -> [?];` - конкатенация массивов
- `length : ([?]) -> int;` - длина массива
- `map : ([?], (?)->??) -> [??];` - применяет функцию к каждому элементу массива
- `mapi : ([?], (int, ?)->??) -> [??];` - можно использовать индексом элемента в массиве
- `findi : (a : [?], fn : (?) -> bool) -> Maybe<int>;` - поиск по массиву
- `fold : ([?], init : ??, fn : (??, ?)->??) -> ??;` - редукция массива
- `replace : ([?], int, ?) -> [?];` - возвращает новый массив с изменённым элементом
- `arrayPush(array : [?], value : ?) -> [?];` - добавление элемента в массив
- `subrange : ([?], index : int, length : int) -> [?];` - срез массива
- `tail(a : [?]) -> [?];` - возвращает массив без первого элемента
- `maybeApply : (m: Maybe<?>, f: (?) -> void) -> void;` - применяет `f` к `m` если `m` не None
- `either(m : Maybe<?>, alternative : ?) -> ?;` - m == None ? alternative : m
- `filter : (a : [?], test : (?) -> bool) -> [?];` - фильтрация элементов массива

Лямбда функции:
- Пример: `\name -> if (name == "Bob") true else false`
- Символ `\` указывает на то, что начинается лямбда-функция.
- `name` — это параметр, который принимает эта лямбда-функция. 
- `->` разделяет параметры функции и её тело.

pipe-forward:
- `x |> f` всё равно что `f(x)`
- Пример использования:
```
// Calculate sum of squares of even elements
sum = [0,1,2,3,4,5,6,7,8,9]
	|> (\lst -> filter(lst, \x->x%2==0))
	|> (\filtered -> map(filtered, \x->x*x))
	|> (\squared -> fold(squared, 0, \a, x -> a+x));
```

### Решаем Лабы

[Хвостовая рекурсия](https://stackoverflow.com/questions/33923/what-is-tail-recursion) отличается тем, что результат рекурсивного вызова напрямую возвращается без дальнейших операций, что позволяет компилятору оптимизировать рекурсию, превращая её в цикл.
