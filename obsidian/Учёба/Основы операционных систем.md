
### Полезности
- [Медия](https://www.nsumedia.ru/main_potok/third_course/fifth_semester/systems)
- [Задания](file:///C:/Users/%D0%9F%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C/Downloads/Telegram%20Desktop/OS.Semester-2.Tasks.pdf)
- [Хабр про POSIX](https://habr.com/ru/articles/326138/)
- [Критерии оценок]([BOS.FinalAssessmentCriteria.pdf](file:///C:/Users/%D0%9F%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C/Downloads/Telegram%20Desktop/BOS.FinalAssessmentCriteria.pdf))

### Лабы
- [ ] 1.1
- [ ] 1.2
- [ ] 1.3
- [ ] 1.4
- [ ] 1.5
- [ ] 1.6
- [ ] 1.7
- [ ] 2.1
- [ ] 2.2
- [ ] 2.3
- [ ] 2.4
- [ ] 3

### POSIX threads - основы

Замечания:
- Базовая единица загрузки ЦПУ - поток.
- У всех исполняемых процессов есть как минимум один поток исполнения. Некоторые процессы этим и ограничиваются.
- Ядро ОС может создать новый поток на порядок быстрее, чем новый процесс.
- Потоки могут быть созданы не только в режиме ядра, но и в режиме пользователя.
- Пользовательские потоки по разному отображаются на потоки в режиме ядра. Всего существует три модели, из которых 1:1 является наиболее часто используемой.
- В каждом потоке есть своё errno, чтобы не было гонки данных.

| Потоки делят память:                 | Copy On Write:                       |
| ------------------------------------ | ------------------------------------ |
| ![[Pasted image 20240926095813.png]] | ![[Pasted image 20240926100353.png]] |

| N:1                                  | 1:1                                  | M:N                                  |
| ------------------------------------ | ------------------------------------ | ------------------------------------ |
| ![[Pasted image 20240926104431.png]] | ![[Pasted image 20240926104341.png]] | ![[Pasted image 20240926104350.png]] |

Основные функции для работы с потоками:
- `pthread_create` — создание нового потока.
- `pthread_join` — ожидание завершения потока.
- `pthread_exit` — завершение потока.
- `pthread_detach` — отделение потока, чтобы его завершение происходило автоматически, без ожидания через `pthread_join`.
- `pthread_mutex_lock` и `pthread_mutex_unlock` — механизмы синхронизации потоков для предотвращения гонок данных.

Набор типов:
- `pthread_t` — идентификатор потока;
- `pthread_mutex_t` — мютекс;
- `pthread_mutexattr_t` — объект атрибутов мютекса
- `pthread_cond_t` — условная переменная
- `pthread_condattr_t` — объект атрибута условной переменной;
- `pthread_key_t` — данные, специфичные для потока;
- `pthread_once_t` — контекст контроля динамической инициализации;
- `pthread_attr_t` — перечень атрибутов потока.

Существуют и другие библиотеки для работы с потоками. Они не обязательно основываются на стандарте POSIX.
 - C++ Standard Library (`std::thread`)
 - OpenMP: OpenMP
 - Boost.Thread: Boost
 - Intel Threading Building Blocks (TBB)
 - И другие
 
### Шаги для создания нового потока:

1. Подключение заголовочного файла pthread: Чтобы использовать потоки, необходимо подключить заголовочный файл pthread.h:
    `#include <pthread.h>`
    
1. Функция потока: Поток выполняет определённую функцию, которая передаётся ему при создании. Функция должна иметь следующий прототип:
    - `void* thread_function(void* arg);`
    - Она возвращает указатель типа `void*` и принимает аргумент того же типа, который можно использовать для передачи данных в поток.
    
3. Создание нового потока: Для создания нового потока используется функция pthread_create, которая имеет следующий синтаксис:
    - `int pthread_create(pthread_t *thread, const pthread_attr_t *attr,                     void *(*start_routine) (void *), void *arg);`
    - `thread`: указатель на переменную типа `pthread_t`, которая будет содержать идентификатор созданного потока.
    - `attr`: атрибуты потока (если указать `NULL`, используются атрибуты по умолчанию).
    - `start_routine`: функция, которую должен выполнить поток.
    - `arg`: аргумент, который передаётся в функцию потока.
    
4. Завершение потока: Поток может завершиться автоматически, когда его функция завершится, или явно, с помощью вызова pthread_exit.
	- `void pthread_exit(void *retval);`
	- `retval` - возвращаемое значение (аналогично return)
	- Если программа завершает работу с помощью return, то весь процесс завершается, поэтому pthread_exit важен, если не надо закрывать все потоки в процессе.
	
5. Ожидание завершения потока: Чтобы родительский поток (основная программа) дождался завершения порождённого потока, используется функция pthread_join.
	- `int pthread_join (pthread_t THREAD_ID, void ** DATA);`
	- `THREAD_ID` - идентификатор ожидаемого потока
	- `DATA` - значение, которое вернул ожидаемый поток 
	- Несколько потоков не могут ждать завершения одного. Если они пытаются выполнить это, один поток завершается успешно, а все остальные — с ошибкой ESRCH.
	- В каком-то смысле `pthread_join()` похожа на вызов `waitpid()`, ожидающую завершения исполнения процесса, но с некоторыми отличиями. Во-первых, все потоки одноранговые, среди них отсутствует иерархический порядок, в то время как процессы образуют дерево и подчинены иерархии родитель — потомок.

### Дополнительные функции

1. `pthread_cancel` - досрочное завершение потока.
	- `int pthread_cancel (pthread_t THREAD_ID);`
	- Поток не только может самостоятельно выбрать момент завершения в ответ на вызов `pthread_cancel()`, но и вовсе его игнорировать, поэтому это больше похоже на запрос на выполнение досрочного завершения потока.

2. `pthread_testcancel` - это функция в POSIX Threads, которая проверяет, были ли отправлены запросы на отмену текущего потока и, при необходимости, немедленно завершает его. Она позволяет программно проверять, нужно ли прервать выполнение потока.
	- `void pthread_testcancel(void);`

3. `pthread_detach()` — переводит поток в отсоединённое состояние (detached state). Когда поток находится в таком состоянии, его завершение не нужно отслеживать с помощью pthread_join(), и система автоматически освобождает все ресурсы, связанные с ним, когда он завершает выполнение.
	- `int pthread_detach(pthread_t thread);`
	- `thread` - идентификатор потока, который вы хотите отсоединить.

4. `pthread_self()` — возвращает идентификатор текущего потока.
	- `pthread_t pthread_self(void);`

5. `pthread_equal()` - сравнивает два идентификатора потоков и возвращает ненулевое значение (истина), если они равны, и 0 (ложь), если не равны.
	- `int pthread_equal(pthread_t t1, pthread_t t2);`
	- Для `pthread_t` нельзя просто использовать == так как это pthread_t - не обязательно число (это может быть структура или другой тип, в зависимости реализации библиотеки в различных системах). 
 
### Как работает POSIX Threads с точки зрения системных вызовов:

Потоки в Linux управляются через механизм **kernel threads** (потоков ядра) и используют такие ключевые системные вызовы, как `clone()`, `futex()`, `sched_yield()`, и другие.

1. Создание потока: `pthread_create()` неявно вызывает `clone()`, который принимает флаги, которые определяют, какие ресурсы будут разделяться между потоком и родительским процессом. В результате, новый поток получает доступ к тому же адресному пространству, файловым дескрипторам, таблице сигналов и другим ресурсам, что и основной процесс.
	- `int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...);`

2. Для синхронизации потоков используется механизм системных вызовов futex (Fast Userspace Mutex). `futex()` — это низкоуровневый примитив синхронизации, который работает как гибридная схема: сначала пытается выполнить синхронизацию в пользовательском пространстве без вмешательства ядра, и только при необходимости (например, в случае конфликта) вызывает системный вызов. 
   Основной принцип работы `futex()`:
    - В большинстве случаев операции блокировки и разблокировки происходят в пользовательском пространстве без перехода в ядро.
    - Если поток блокируется на ожидании ресурса (например, мьютекс занят), вызывается системный вызов `futex()` для перевода потока в спящий режим до тех пор, пока ресурс не станет доступен.
    - `int futex(int *uaddr, int futex_op, int val, const struct timespec *timeout, int *uaddr2, int val3);`

3. Управление потоками:
    - Планирование (scheduling): потоки планируются и управляются с помощью планировщика ядра, который контролирует их выполнение. POSIX Threads в основном полагается на системные вызовы, такие как `sched_yield()` для добровольного уступления процессорного времени другим потокам. 
    - Вызов `sched_yield()`:
        `int sched_yield(void);` - переводит текущий поток в состояние ожидания, позволяя другим потокам выполнять свою работу.
    - Завершение потока: когда поток завершается (например, через `pthread_exit()`), ядро освобождает ресурсы, связанные с этим потоком. Обычно это делается с помощью системного вызова `exit()`, если это последний поток процесса, либо с помощью сигнала ядра, который переводит поток в состояние "зомби" до полной его очистки.
        
4.  Механизм планировщика ядра: Потоки в Linux обрабатываются планировщиком ядра, который распределяет процессорное время между потоками в соответствии с их приоритетами и политиками планирования. Это может быть политика:
    - SCHED_OTHER — обычная политика для обычных задач (по умолчанию).
    - SCHED_FIFO — для задач реального времени (FIFO).
    - SCHED_RR — задачи реального времени с круговым циклом (round-robin).
    - Планировщик ядра решает, какой поток будет запущен на CPU в данный момент на основании этих политик и других факторов, таких как время выполнения и приоритеты.
    
5. Память и разделение ресурсов: Все потоки одного процесса в Linux разделяют одно и то же пространство памяти. Это означает, что глобальные переменные и динамически выделенная память видны всем потокам. Однако у каждого потока есть свой стек, который отделён от стека других потоков, что позволяет каждому потоку сохранять свои локальные данные.
    
6. Сигналы: Потоки могут получать сигналы (например, от других потоков или процессов), но по умолчанию сигналы обрабатываются на уровне процесса. Это означает, что сигналы, такие как `SIGINT` или `SIGTERM`, посылаются процессу в целом, а не отдельному потоку. Однако POSIX Threads позволяет настраивать, какие потоки будут обрабатывать определённые сигналы.

| Характеристика   | `pthread_self()`                | `gettid()`                     |
| ---------------- | ------------------------------- | ------------------------------ |
| Возвращаемый тип | pthread_t                       | pid_t                          |
| Уникальность     | Уникален для потоков в процессе | Уникален для потоков в системе |
| Стандарт         | Часть POSIX                     | Специфична для Linux           |

| Локальные | Локальные статические                                                                      | Локальные константные | Глобальные                    |
| --------- | ------------------------------------------------------------------------------------------ | --------------------- | ----------------------------- |
| стек      | Сегмент данных, в подразделе BSS (uninitialized data segment или initialized data segment) | Стек                  | Сегмент данных (data segment) |

`clone3()` - это системный вызов, который непосредственно отвечает за создание новых потоков в Linux. Он принимает несколько флагов, которые определяют, как будет работать новый поток, включая разделение памяти, файловых дескрипторов и сигналов с родительским потоком. В вашем выводе видны следующие флаги:
    - `CLONE_VM` — новый поток будет разделять адресное пространство с родительским.
    - `CLONE_FS`, `CLONE_FILES`, `CLONE_SIGHAND` — поток разделяет файловые системы, файловые дескрипторы и обработчики сигналов.
    - `CLONE_THREAD` — поток будет являться частью того же процесса, что и родительский (POSIX поток).
    - `CLONE_SYSVSEM`, `CLONE_SETTLS`, `CLONE_PARENT_SETTID`, `CLONE_CHILD_CLEARTID` — дополнительные флаги для управления семафорами, настройкой TLS и передачей идентификаторов потоков между родителем и ребенком.

**Thread Local Storage (TLS)** — это механизм, предоставляющий каждому потоку доступ к уникальной области памяти, которая предназначена только для него. Данные, хранящиеся в TLS, доступны только тому потоку, который их создал, и не разделяются с другими потоками внутри одного процесса. Это важно для потокобезопасности, когда данные должны быть уникальными для каждого потока, а не общими.

