
### Полезности
- [Медия](https://www.nsumedia.ru/main_potok/third_course/fifth_semester/systems)
- [Задания](file:///C:/Users/%D0%9F%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C/Downloads/Telegram%20Desktop/OS.Semester-2.Tasks.pdf)
- [Хабр про POSIX](https://habr.com/ru/articles/326138/)
- [Критерии оценок](file:///C:/Users/%D0%9F%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C/Downloads/Telegram%20Desktop/BOS.FinalAssessmentCriteria.pdf)
- [Старые лекции в вк](https://vk.com/video/@nsu_fit_os/all)

### Лабы
- [x] 1.1
- [x] 1.2
- [x] 1.3
- [x] 1.4
- [x] 1.5
- [x] 1.6
- [x] 1.7
- [x] 2.1
- [x] 2.2
- [x] 2.3
- [x] 2.4
- [x] 3

## Старые темы

### Data segment

**Data segment** (секция данных):
1. *Initialized Data Segment* (Инициализированная секция данных) - инициализированные глобальные и статические переменные
2. *Block Started by Symbol* (BSS, Неинициализированная секция данных) - неинициализированные глобальные и статические переменные
	- При запуске программы они автоматически инициализируются нулями (за счёт того, что все переменные находятся в одной секции, это происходит быстрее, чем если бы каждой переменной отдельно присваивалось значение ноль)
	- Всегда остаются в этом сегменте даже при изменении. То есть при изменении переменной из секции BSS, её адрес не меняется
	- В исполняемом файле они не занимают места

| Нестатические локальные переменные | Инициализированные статические или глобальные переменные | Неинициализированные статические или глобальные переменные |
| ---------------------------------- | -------------------------------------------------------- | ---------------------------------------------------------- |
| стек                               | .data или .rodata (Read-Only Data) если стоит const      | .bss                                                       |

Замечание: Секция BSS и Data существуют только на этапе загрузки программы. Во время выполнения программы операционная система работает только с памятью, а понятия BSS и Data уже не имеют значения

### Прерывания 

**Прерывания** — это аппаратные события, которые сигнализируют процессору о необходимости выполнения определённых действий. Когда происходит прерывание, процессор приостанавливает текущий процесс (или поток) и переключается на обработку прерывания

##### Виды прерываний:
- *Аппаратные прерывания*: Генерируются аппаратными устройствами (например, клавиатура, сеть, таймер). Например, нажатие клавиши или приход сетевого пакета вызывает аппаратное прерывание
- *Программные прерывания*: Вызываются программно с помощью специальных инструкций. Например, системные вызовы работают через программные прерывания
- *Таймерные прерывания*: Генерируются встроенным в процессор таймером для переключения задач в многозадачной среде

##### Что происходит при прерывании:
1. Прерывание возникает
2. Процессор сохраняет контекст текущей задачи
3. Управление передаётся обработчику прерываний (Interrupt Service Routine, ISR)
4. После завершения ISR выполнение программы продолжается с того места, где было приостановлено

### Сигналы

[Сигналы](https://ru.manpages.org/signal/7) — это механизм, с помощью которого процессы могут асинхронно общаться друг с другом и с ядром операционной системы. Сигналы позволяют ОС или одному процессу уведомлять другой процесс о наступлении события, требующего немедленной реакции. Это очень гибкий и мощный инструмент для управления и обработки событий, но их асинхронная природа может быть сложной для корректной обработки. Сигналы идентифицируются по числовым кодам

#### Виды сигналов
- **Ненадёжные сигналы** (Unreliable signals):
    - Это старая модель сигналов. Она остаётся в новых версиях Linux для обратной совместимости
    - Ненадёжные сигналы могут теряться, если тот же сигнал отправляется процессу несколько раз до того, как процесс успел его обработать. В таком случае обработается только один из поступивших сигналов
    - Ненадёжные сигналы также не гарантируют, что сигнал не будет потерян при переходе между процессами. То есть, когда происходит форк (создание нового процесса), сигналы, отправленные родительскому процессу, могут не передаться новому дочернему процессу
- **Надёжные сигналы POSIX** (Reliable signals):
    - POSIX-сигналы стали стандартом для надежной обработки сигналов
    - Надёжные сигналы поддерживают очереди. Если несколько сигналов одного типа отправляются процессу, они будут поставлены в очередь и обработаны последовательно. Система гарантирует, что ни один из этих сигналов не будет потерян. Единственное, что если очередь достигнил лимит размера `RLIMIT_SIGPENDING`, то отправка сигнала вызовет ошибку
    - Надёжные сигналы можно маскировать (временно блокировать) с помощью `sigprocmask` и `pthread_sigmask`. Заблокированные (замаскированные) сигналы откладываются и будут обработаны, когда маска блокировки будет снята. Каждый процесс имеет свою сигнальныю маску
- **Сигналы реального времени** (Real-time signals):
    - Сигналы реального времени являются подмножеством надёжных сигналов и были добавлены в POSIX, чтобы предоставить возможности для работы с асинхронными событиями в режиме реального времени
	- Поддерживается приоритетность: у сигналов реального времени доставляются в порядке приоритета (их номера). Более низкие номера сигналов доставляются раньше более высоких номеров
	- Вместе с сигналом можно передать дополнительные данные с помощью `sigqueue()`

#### Примеры сигналов
- Ненадёжные сигналы:
	- `SIGINT` - прерывание процесса
	- `SIGTERM` - стандартный сигнал завершения процесса
	- `SIGKILL` - принудительное завершение процесса (нельзя заблокировать)
	- `SIGSEGV` - сегментационная ошибка
	- `SIGSTOP` - приостановка процесса (не может быть перехвачен или игнорирован)
	- `SIGCONT` - возобновление процесса после SIGSTOP
- Надёжные сигналы:
	- `SIGUSR1` и `SIGUSR2` — пользовательские сигналы, которые можно настроить для любой задачи
	- `SIGCHLD` — отправляется родительскому процессу, когда один из его дочерних процессов завершается или переходит в состояние ожидания
- Сигналы реального времени:
	- `SIGRTMIN`, `SIGRTMIN + 1`, `SIGRTMIN + 2`, ..., `SIGRTMAX` - действием по умолчанию для необработанных сигналов реального времени является завершение процесса

#### Отправка сигналов
- `CTRL+C` - отправка SIGINT
- `CTRL+Z` - отправка SIGSTP
- `kill -SIGTERM <pid>` - отправка сигнала SIGTERM командой
- Системные вызовы в си:
	- `kill` - посылает сигнал указанному процессу, всем членам указанной группы процессов или всем процессам в системе
	- `killpg` - посылает сигнал всем членам указанной группы процессов
	- `raise` - посылает сигнал вызвавшему потоку
	- `pthread_kill` - посылает сигнал указанной нити POSIX в том же процессе, что и вызывающий
	- `tgkill` - посылает сигнал указанной нити в указанном процессе
	- `sigqueue` - посылает сигнал реального времени указанному процессу с сопроводительными данными
- Сигналы от ядра (ядро может отправить сигналы процессу при определённых событиях)

#### Обработка сигналов
1. Каждый сигнал имеет текущий **обработчик**, который определяет, что будет делать процесс при поступлении сигнала
2. Каждый не пользовательских сигнал имеет **обработчик по умолчанию**, который задаёт стандартное действие для сигнала
3. Процесс может:
	- Игнорировать сигнал: просто не реагировать на него
	- Использовать обработчик по умолчанию
	- Определить собственный обработчик с помощью `sigaction` или `signal`

#### Особенности
- Сигналы в UNIX/Linux работают на уровне процессов, а не на уровне потоков. То есть `signal(<SIG>, <signal_handler>)` установит обработчик сигнала для всего процесса
- Когда сигнал отправляется процессу, любой из потоков может быть выбран системой для обработки сигнала, если он не заблокировал этот сигнал
- В POSIX-системах нельзя установить отдельные обработчики для каждого потока одного процесса
- Для отправки сигнала конкретному потоку используют `pthread_kill(<thread>, <SIG>)`

| Сигналы                                                                | Прерывания                                                                                      |
| ---------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| Применяются к процессам в пользовательском пространстве                | Работают на уровне процессора и устройства                                                      |
| Отправляются ядром или процессами                                      | Возникают в ответ на аппаратные или программные события                                         |
| Процесс может определить обработчики сигналов                          | Прерывания обрабатываются операционной системой через ISR                                       |
| Используются для межпроцессного взаимодействия и управления процессами | Используются для взаимодействия процессора с устройствами и системой                            |
| Могут быть блокированы или обработаны (кроме SIGKILL, SIGSTOP)         | Прерывания нельзя блокировать на уровне программы, но их можно маскировать на уровне процессора |

### Clone

#### Параметры clone:
1. Указатель на функцию (`fn`):
    - Указатель на функцию, которая будет выполнена в новом потоке
2. Указатель на стек (`child_stack`):
    - Указатель на область памяти, которая будет использоваться как стек для нового потока. Если этот параметр равен `NULL`, стек будет выделен автоматически
3. Флаги (`flags`):
    - Эти флаги определяют, какие ресурсы будут разделяться между родительским и дочерним потоками. Например:
        - `CLONE_VM`: общий адресное пространство памяти
        - `CLONE_FS`: общий файловый системный контекст
        - `CLONE_FILES`: общий набор открытых файлов
        - `CLONE_SIGHAND`: общий обработчик сигналов
        - `CLONE_THREAD`: определяет, что дочерний поток является частью того же процесса (потока)
        - `CLONE_PARENT_SETTID`, `CLONE_CHILD_CLEARTID` и другие флаги для управления потоками
        - `CLONE_SYSVSEM` - разделение системных семафор SysV с родительским процессо
4. Указатель на идентификатор потока (`ptid`):
    - Указатель на переменную, которая будет содержать идентификатор потока, создаваемого функцией `clone`
5. Указатель на идентификатор потока родителя (`tid`):
    - Указатель на переменную, в которую будет записан идентификатор потока родителя (если используется `CLONE_CHILD_SETTID`)
6. Сигнал завершения (`exit_signal`):
    - Идентификатор сигнала, который будет отправлен родительскому процессу при завершении дочернего потока (например, `SIGCHLD`)
7. Дополнительные параметры:
    - В зависимости от реализации `clone` могут быть и другие параметры, например, указатели на дополнительные структуры для передачи специфических данных

#### Возвращает:
- TID нового потока
- -1 при ошибке

### Файловые дескрипторы

**Файловые дескрипторы** — это целые числа, которые операционная система использует для идентификации открытых файлов (и других потоков ввода/вывода) в рамках процесса. Они служат абстракцией, позволяющей программам взаимодействовать с файлами, сокетами, терминалами и другими ресурсами ввода/вывода

#### Основные характеристики файловых дескрипторов:
1. Уникальность внутри процесса: каждый дескриптор уникален для текущего процесса, но может быть одинаковым в разных процессах. Каждый процесс имеет свою таблицу файловых дескрипторов, которая хранит ссылки на открытые ресурсы. Одинаковые числа в таблицах разных процессов могут указывать на разные ресурсы
2. Автоматическое назначение: дескрипторы выдаются операционной системой при открытии файлов или других ресурсов
3. Переиспользование: если дескриптор закрыт (например, с помощью `close()`), он может быть назначен для нового ресурса

#### Стандартные файловые дескрипторы:
При запуске процесса операционная система автоматически открывает три стандартных файловых дескриптора:
1. `stdin` (0) — стандартный поток ввода (обычно клавиатура)
2. `stdout` (1) — стандартный поток вывода (обычно консоль)
3. `stderr` (2) — стандартный поток ошибок (обычно консоль)

#### Дескриптор может указывать на любое устройство ввода/вывода:
- Файлы (обычные файлы, сокеты, FIFO и т. д.)
- Терминалы (например, консоль)
- Сетевые соединения (сокеты)
- Анонимные каналы (например, через `pipe()`)
- Устройства (например, `/dev/null`)

#### Таблица файловых дескрипторов
В ядре каждой программе (процессу) выделяется **таблица файловых дескрипторов**. Эта таблица представляет собой массив, где:
- Индексы массива — это числа, используемые в коде как файловые дескрипторы (например, 0, 1, 2)
- Значения массива — это ссылки на открытые файлы или другие ресурсы ввода-вывода (например, устройства, сокеты). А именно это указатели на структуры данных, хранящие метаинформацию о файле (сокете или др.)
Таблица имеет фиксированный размер, но его можно увеличить с помощью системных вызовов, например `setrlimit` или `fcntl`

#### Как определяется дискриптор открыт или нет
При закрытии дескриптора соответствующая запись в таблице дескрипторов процесса становится невалидной. Она перестаёт ссылаться на запись в таблице открытых файлов ядра. Операции с таким дескриптором приводят к ошибке (`EBADF`: Bad File Descriptor)

## Работа с потоками

### Oсновы POSIX threads

##### Основные аспекты:
- Базовая единица загрузки ЦПУ - поток
- У всех исполняемых процессов есть как минимум один поток исполнения. Некоторые процессы этим и ограничиваются
- Ядро ОС может создать новый поток на порядок быстрее, чем новый процесс
- Потоки могут быть созданы не только в режиме ядра, но и в режиме пользователя
- Пользовательские потоки по разному отображаются на потоки в режиме ядра. Всего существует три модели, из которых 1:1 является наиболее часто используемой
- В каждом потоке есть своё errno (чтобы не было конфликтов)

| Потоки делят память:                 | Copy On Write:                       |
| ------------------------------------ | ------------------------------------ |
| ![[Pasted image 20240926095813.png]] | ![[Pasted image 20240926100353.png]] |

| N:1                                  | 1:1                                  | M:N                                  |
| ------------------------------------ | ------------------------------------ | ------------------------------------ |
| ![[Pasted image 20240926104431.png]] | ![[Pasted image 20240926104341.png]] | ![[Pasted image 20240926104350.png]] |

##### Другие библиотекии
Существуют и другие библиотеки для работы с потоками, и они не обязательно основываются на стандарте POSIX.
Примеры:
 - C++ Standard Library (std::thread)
 - OpenMP: OpenMP
 - Boost.Thread: Boost
 - Intel Threading Building Blocks (TBB)
 - И другие

### Команды

#### Команды
- `gcc -pthread -o <output_file> <source_file>.c` - компиляции
	- Флаг -pthread при компиляции добавляет директивы компилятору, обеспечивающие поддержку многопоточности (например, адаптирует компилятор для потокобезопасного кода)
    - Флаг -pthread при компоновке (линковке) включает подключение динамической библиотеки libpthread.so, которая содержит определения и реализации функций pthread (таких как pthread_create, pthread_join и др)
- `gcc -lpthread -o <output_file> <source_file>.c` - тоже компиляций
	- Флаг -lpthread просто добавляет библиотеку libpthread.so, но не устанавливает флаги для компиляции и линковки, поэтому флаг -pthread предпочтительнее
- `./main.out` - запуск (так же как и обычное приложение)
- `strace ./main.out` - трассировка системных вызовов программы
- `strace -c ./main.out` - посмотреть суммарное количество разных системных вызовов
- `strace -o output.txt ./main.out` - перенаправление вывода strace в файл
- `valgrind --tool=memcheck ./main.out` - проверка утечек памяти
- `valgrind --tool=helgrind ./main.out` - для анализа конкурентного доступа к памяти

#### Замечание
Библиотека POSIX threads не включена по умолчанию в стандартную библиотеку C, так как libc определяет только базовые возможности, общие для всех платформ, в то время как pthread разработан в соответствии со стандартом POSIX и не является кросс-платформенным

### Основные функции pthread

1. `pthread_create` - создание нового поток
	- `int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)`
    - `thread` - указатель на идентификатор созданного потока (имеет тип pthread_t)
    - `attr` - атрибуты потока (если указать NULL, используются атрибуты по умолчанию)
    - `start_routine` - функция, которую должен выполнить поток
    - `arg` - аргумент, который передаётся в функцию потока

2. `pthread_exit` - явное завершение потока
	- `void pthread_exit(void *retval)`
	- `retval` - возвращаемое значение (аналог return)
	- Если программа завершает работу с помощью return, то весь процесс завершается, поэтому pthread_exit важен, если не надо закрывать все потоки в процессе

3. `pthread_join` - ожидание завершения потока
	- `int pthread_join (pthread_t THREAD_ID, void ** DATA)`
	- `THREAD_ID` - идентификатор ожидаемого потока
	- `DATA` - значение, которое вернул ожидаемый поток
	- Несколько потоков не могут ждать завершения одного. Если они пытаются выполнить это, один поток завершается успешно, а все остальные — с ошибкой ESRCH
	- В каком-то смысле pthread_join похожа на вызов waitpid, ожидающую завершения исполнения процесса, но с некоторыми отличиями. Во-первых, все потоки одноранговые, среди них отсутствует иерархический порядок, в то время как процессы образуют дерево и подчинены иерархии родитель — потомок

4. `pthread_cancel` - досрочное завершение другого потока
	- `int pthread_cancel(pthread_t THREAD_ID)`
	- Поток не только может самостоятельно выбрать момент завершения в ответ на вызов pthread_cancel, но и вовсе его игнорировать, поэтому это больше похоже на запрос на выполнение досрочного завершения потока

5. `pthread_testcancel` - точка потенциального завершения потока
	- `void pthread_testcancel(void)`
	- Проверяет, были ли отправлены запросы на отмену текущего потока (pthread_cancel)
	- Если оказывается, что текущие поток был отменен, то он завершается

6. `pthread_detach` — переводит поток в отсоединённое состояние (detached state). Когда поток находится в таком состоянии, его завершение не нужно отслеживать с помощью pthread_join(), и система автоматически освобождает все ресурсы, связанные с ним, когда он завершает выполнение
	- `int pthread_detach(pthread_t thread)`
	- `thread` - идентификатор потока, который вы хотите отсоединить

7. `pthread_self` — возвращает идентификатор текущего потока
	- `pthread_t pthread_self(void);`

8. `pthread_equal` - сравнивает два идентификатора потоков и возвращает ненулевое значение (истина), если они равны, и 0 (ложь), если не равны
	- `int pthread_equal(pthread_t t1, pthread_t t2)`
	- Для pthread_t нельзя просто использовать == так как это pthread_t - не обязательно число (это может быть структура или другой тип, в зависимости реализации библиотеки в различных системах)


### Системные вызовы pthreads

Потоки в Linux управляются через механизм потоков ядра и используют такие ключевые системные вызовы, как `clone()`, `futex()`, `sched_yield()` и другие

#### Некоторые используемые системные вызовы
- **clone**: Создание потока: `pthread_create()` неявно вызывает `clone()`, который принимает флаги, которые определяют, какие ресурсы будут разделяться между потоком и родительским процессом. В результате, новый поток получает доступ к тому же адресному пространству, файловым дескрипторам, таблице сигналов и другим ресурсам, что и основной процесс
- **futex**: Для синхронизации потоков используется механизм системных вызовов futex (Fast Userspace Mutex). `futex()` — это низкоуровневый примитив синхронизации, который работает как гибридная схема: сначала пытается выполнить синхронизацию в пользовательском пространстве без вмешательства ядра, и только при необходимости (например, в случае конфликта) вызывает системный вызов. Также futex служет основой для механизма синхронизации `mutex`
- **sched_yield**: Планирование (scheduling): потоки планируются и управляются с помощью планировщика ядра, который контролирует их выполнение. POSIX Threads в основном полагается на системные вызовы, такие как `sched_yield()` для добровольного уступления процессорного времени другим потокам
- **exit**: Когда поток завершается (например, через `pthread_exit()`), ядро освобождает ресурсы, связанные с этим потоком. Обычно это делается с помощью системного вызова `exit()`, если это последний поток процесса, либо с помощью сигнала ядра, который переводит поток в состояние "зомби" до полной его очистки

### Cancel

`pthread_cancel()` — это функция, используемая для запроса завершения другого потока. Когда один поток вызывает pthread_cancel() для другого потока, операционная система посылает запрос (механизм из pthread) на его завершение. Однако завершение не происходит немедленно

#### Режимы отмены (Cancellation Modes)
1. **Отложенная отмена** (по умолчанию). Поток завершает своё выполнение только при достижении определённых точек отмены (cancellation points). Эти точки — это места, где поток может быть безопасно прерван. Примеры точек отмены: функции ввода-вывода, такие как `read()`, `write()`, `sleep()`, `pthread_cond_wait()`, `pthread_testcancel();`
	- `pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL);`
2. **Асинхронная отмена**  — поток может быть прерван в любой момент, что делает отмену мгновенной. Однако это небезопасный режим, так как прерывание может произойти в критическом участке кода (например, при работе с общими данными), что может привести к непредсказуемому поведению и ошибкам
	- `pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);`

#### Возможность отмены
1. **Отменяемое состояние** (по умолчанию) — поток может быть отменён (это состояние)
	- `pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);`
2. **Неотменяемое состояние** — запросы на отмену будут игнорироваться
	- `pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);`

#### Обработчики завершения
Когда поток получает запрос на завершение, он может зарегистрировать **обработчики завершения** для правильного освобождения ресурсов и завершения
``` c
void cleanup(void *arg) { 
	printf("Cleaning up: %s\n", (char *)arg); 
} 
pthread_cleanup_push(cleanup, "Thread finished"); // регистрирует обработчик
// ... критическая секция 
pthread_cleanup_pop(1); // удаляет его
```

### Подробности про потоки

#### Особенности потоков
- Потоки полностью делят адресное пространство процесса (вирутальное и физическое)
- Каждый поток имеет свой task struct (так же как и каждый процесс)
- Основная единица деспетчеризации в ОС - это потоки 

#### Clone
`clone3()` - это системный вызов, который непосредственно отвечает за создание новых потоков в Linux. Он принимает несколько флагов, которые определяют, как будет работать новый поток, включая разделение памяти, файловых дескрипторов и сигналов с родительским потоком. В вашем выводе видны следующие флаги:
- `CLONE_VM` — новый поток будет разделять адресное пространство с родительским
- `CLONE_FS`, `CLONE_FILES`, `CLONE_SIGHAND` — поток разделяет файловые системы, файловые дескрипторы и обработчики сигналов
- `CLONE_THREAD` — поток будет являться частью того же процесса, что и родительский (POSIX поток)
- `CLONE_SYSVSEM`, `CLONE_SETTLS`, `CLONE_PARENT_SETTID`, `CLONE_CHILD_CLEARTID` — дополнительные флаги для управления семафорами, настройкой TLS и передачей идентификаторов потоков между родителем и ребенком

#### Переключение контекств
**Переключение контекста** (context switch) — это процесс, при котором процессор останавливает выполнение одного процесса или потока и переключается на выполнение другого:
1. Сохранение контекста текущего процесса
	- Регистры общего назначения
	- Счётчик команд
	- Указатель стека
	- Указатель базы стека
	- Флаги процессора
	- Контекст сопроцессоров
	- Состояние управления памятью
	- Контексты ядра
2. Выбор нового процесса scheduler-ом
3. Загрузка контекста нового процесса
4. Продолжение выполнения нового процесса

#### Виды потоков
1. **Ядерные** (kernel-level threads) - их диспетчеризирует ядро
	- Cоздаются, управляются и уничтожаются ядром
	- Операционная система выполняет планирование этих потоков через системные вызовы
	- Блокировка: Если ядерный поток блокируется, например, при ожидании ввода-вывода (I/O), ядро может переключиться на другой поток. Это позволяет системе эффективно управлять ресурсами
	- Процессорные ресурсы: Ядерные потоки могут выполняться на нескольких процессорах одновременно
2. **Пользовательские** (user-level threads) - работают только в рамках юзерспейса и ядро не видит их напрямую
	- Работают быстрее, так как не тратится время на системные вызовы при переключении контекста
3. **Модель смешанных потоков** (Hybrid Threads)
	- Современные системы часто используют гибридную модель, которая сочетает в себе элементы как ядерных, так и пользовательских потоков

#### Thread Local Storage
**Thread Local Storage** (TLS) — это область памяти, выделенная для хранения данных, уникальных для каждого потока. Каждый поток имеет собственный набор переменных, которые не разделяются с другими потоками и остаются доступными только для него
1. Локальные переменные с ключевым словом `__thread` или `thread_local`:
	- `__thread int thread_local_var = 0;`
2. Поточные переменные, используемые библиотеками:
	- Например errno из libc

#### Отличия pthread_self() и gettid
- `pthread_self()` уникален для потоков в процессе и возвращает `pthread_t`
- `gettid()` уникален для потоков в системе и возвращает `pid_t` 

#### Отличие fork и clone
- `fork` полностью копирует task struct
- `clone` заполняет task struct как надо (зависит от агрументов)

#### Отличия pthread_exit и return
- `pthread_exit`: Завершает только текущий поток, а остальные потоки продолжают выполнение
- `return`: Завершает только текущий поток, но если это основной поток (например, в `main`), завершится весь процесс, включая другие потоки

#### Атрибуты потока
- *Размер стека*
- *Положение стека*
- *Отделение от родительского процесса*
    - `PTHREAD_CREATE_JOINABLE` (по умолчанию) или `PTHREAD_CREATE_DETACHED`
- *Политика планирования*
	- `SCHED_FIFO` (First In, First Out):
		- Поток выполняется до тех пор, пока он не завершится или не блокируется (например, при ожидании ввода/вывода)
		- Потоки с одинаковым приоритетом выполняются в порядке их создания
	- `SCHED_RR` (Round Robin):
		- Основана на `SCHED_FIFO`, но с временными квантами
		- Если поток не завершает выполнение в течение своего кванта времени, он отправляется в конец очереди потоков с таким же приоритетом
		- Потоки с одинаковым приоритетом выполняются по очереди на фиксированный промежуток времени (квант времени)
	- `SCHED_OTHER`:
		- Это стандартная политика планирования, используемая для обычных процессов, не относящихся к реальному времени. Обычно она основана на алгоритме CFS (Completely Fair Scheduler), который стремится обеспечить "справедливое" распределение процессорного времени между всеми потоками
		- Потоки с этой политикой имеют более низкий приоритет по сравнению с потоками `SCHED_FIFO` и `SCHED_RR`
		- Предоставляет эффективное управление процессорным временем, но не гарантирует выполнение в реальном времени
		- Потоки с данной политикой в отличае от предыдущих не считаются потоками реального времени 
- *Приоритет*
    - Устанавливает параметры планирования (включая приоритет) для потока
    - Политика планирования должна поддерживать приоритеты (например, `SCHED_FIFO` и `SCHED_RR`)
    - Диапазон от 1 до 99, где 99 — наивысший приоритет
    - Для `SCHED_OTHER` приоритеты обычно задаются системой
- *Состояние потока*
    - Устанавливает, будет ли новый поток наследовать политику и приоритет планирования от родительского потока (`PTHREAD_INHERIT_SCHED`) или использовать свои собственные параметры (`PTHREAD_EXPLICIT_SCHED`)
- *Наследование атрибутов*
- *Оптимизация для обработки сигналов*
    - Устанавливает область видимости потоков
    - Может быть `PTHREAD_SCOPE_SYSTEM` (системный уровень, потоки могут быть запланированы на различных процессорах. Это позволяет операционной системе более гибко управлять потоками, используя более сложные алгоритмы планирования, которые могут учитывать состояние других потоков, запущенных в системе) или `PTHREAD_SCOPE_PROCESS` (потоки в пределах одного процесса)

#### Отличия joinable и detached
1. Если поток создан как joinable (присоединяемый):
	- Когда другой поток вызывает `pthread_join()`, операционная система:
		- Ждёт завершения потока
		- Освобождает его ресурсы (стэк, дескрипторы и другие структуры)
	- Если вы не вызываете pthread_join() после завершения потока, ресурсы будут висеть в памяти (т.н. зомби-поток), пока процесс не завершится
2. Если поток создан как detached (отсоединённый):
	- Ресурсы освобождаются автоматически после его завершения. Ресурсы освобождаются ядром сразу по окончанию потока

#### Состояния потока
- **TASK_RUNNING**: Поток готов к выполнению или выполняется
- **TASK_INTERRUPTIBLE**: Поток ожидает события (например, данных от сокета или завершения таймера). Он может быть разбужен сигналом
- **TASK_UNINTERRUPTIBLE**: Поток ожидает события, которое не может быть прервано сигналом (например, доступ к оборудованию)
- **TASK_STOPPED**: Поток приостановлен (например, при обработке сигнала `SIGSTOP`)
- **TASK_ZOMBIE**: Поток завершён, но его родительский процесс ещё не собрал его статус (`waitpid`)

#### Идентификаторы:
- Каждый поток процесса имеет одинаковый PID
- Каждый поток процесса имеет уникальный TID
- Основной поток процесса имеет TID = PID

#### Как ядро определяет, что поток завис или ждёт
Когда поток выполняет системный вызов, который приводит к блокировке (например, `read`, `write`, `select`, `poll`, `recv`, `sleep`), это сигнал для ядра. В процессе обработки системного вызова:
- Поток переходит из пользовательского режима в режим ядра
- Ядро анализирует, может ли операция быть выполнена немедленно (например, данные уже доступны в кэше или готов к записи сокет). В зависимости от этого меняет состояние потока

### Модели

##### Модель "1:1"
В модели **1:1** каждому пользовательскому потоку соответствует один ядерный поток. Если программа создаёт 10 потоков, операционная система создаёт 10 ядерных потоков, которые планируются ядром
- Преимущества:
	1. **Параллелизм на уровне ядра**:
	    - Каждый пользовательский поток может работать на отдельном ядре (если доступно несколько ядер). Это обеспечивает настоящую параллельность
	2. **Блокировка потоков**:
	    - Если один пользовательский поток блокируется (например, ожидает данные ввода/вывода), ядро может переключиться на другой поток из того же процесса. Это невозможно в модели N:1
	3. **Упрощение реализации**:
	    - ОС берёт на себя управление потоками. Программисту не нужно реализовывать сложные пользовательские планировщики, как в модели N:M
	4. **Поддержка ОС**:
	    - Современные ОС (например, Linux, Windows) изначально ориентированы на модель 1:1, предоставляя богатые API для работы с потоками
- Недостатки:
	1. **Ресурсоёмкость**:
	    - Каждый поток занимает значительное количество ресурсов ядра (стек, контекст выполнения и т. д.)
	    - Большое количество потоков (например, тысячи) может привести к исчерпанию ресурсов
	2. **Контекст переключения**:
	    - Переключение между потоками осуществляется ядром и требует времени. Это дороже, чем в модели N:1, где переключение можно делать внутри пользовательского планировщика

##### Модель "N:1"
В модели **N:1** множество пользовательских потоков мапятся на один ядерный поток. ОС видит только один поток, независимо от того, сколько пользовательских потоков создано
- Преимущества:
	1. **Быстрое переключение потоков**:
	    - Все потоки управляются библиотекой потоков на уровне пользователя. Переключение между потоками происходит без участия ядра, что очень быстро
	2. **Экономия ресурсов**:
	    - Нет необходимости создавать множество ядерных потоков. Это снижает нагрузку на ядро
	3. **Простота управления**:
	    - Программист может полностью контролировать, как планируются пользовательские потоки
- Недостатки:
	1. **Отсутствие параллелизма**:
	    - Все пользовательские потоки выполняются на одном ядре. Даже если у системы есть несколько ядер, остальные ядра будут простаивать
	2. **Проблемы блокировки**:
	    - Если один пользовательский поток блокируется (например, ожидает ввод/вывод), блокируется весь процесс, так как блокируется единственный ядерный поток

##### Модель "N:M"
Модель **N:M** сочетает преимущества двух предыдущих. В этой модели несколько пользовательских потоков мапятся на несколько ядерных потоков
- Преимущества:
	1. **Эффективное использование ресурсов**:
	    - Количество ядерных потоков ограничено (может быть меньше, чем пользовательских потоков). Это экономит ресурсы ОС
	2. **Частичная параллельность**:
	    - Пользовательские потоки могут работать на нескольких ядрах, если есть свободные ядерные потоки
	3. **Гибкость**:
	    - Пользовательские потоки планируются библиотекой, но часть работы делегируется ядру, что снимает проблемы с блокировкой
- Недостатки:
	1. **Сложность реализации**:
	    - Управление потоками требует как пользовательского, так и ядерного планировщика, что усложняет разработку
	2. **Неоптимальность для малых нагрузок**:
	    - Если пользовательских потоков мало, модель 1:1 будет более простой и эффективной

### Пользовательские потоки

#### Отличие ядерных потоков от пользовательских
- Ядерные потоки: планируются в ядре (шедулер в ядре)
- Пользовательские потоки: 
	- Планируются в userspace-е (шедулер пользовательский)
	- Работают в рамках одного ядерного процесса
	- Реально на процессоре выполняется только один из пользовательских потоков

**Контекст** представляет собой всю информацию, необходимую для приостановки и последующего возобновления выполнения потока или процесса. Контекст включает множество элементов, которые зависят от уровня абстракции, где происходит управление

Основные составляющие контекста:
1. Состояние регистров процессора:
    - Общие регистры: Содержат промежуточные данные, такие как локальные переменные или результаты арифметических операций
    - Счётчик команд: Указывает на следующую инструкцию, которую процессор должен выполнить
    - Указатель стека: Указывает на вершину текущего стека вызовов
    - Базовый указатель: Используется для работы с локальными переменными в рамках вызова функции
    - Флаги: Содержат информацию о состоянии процессора (например, результат предыдущей операции, наличие прерываний и т. д.)
2. Состояние памяти:
    - Стек: Содержит локальные переменные, адреса возврата, а также параметры функций. Для каждого потока обычно создаётся свой стек
    - Сегменты данных и кода: Текущая область памяти, используемая для данных и команд
    - Динамическая память: Указатели на выделенные области памяти (например, через malloc), если они относятся к текущему процессу/потоку
4. Информация о сигналах (для процессов):
    - Какие сигналы зарегистрированы
    - Установленные обработчики сигналов
    - Маска сигналов (т. е. какие сигналы блокированы)
5. Потоковое состояние (для потоков):
    - Текущие идентификаторы потока
    - Информация о синхронизации (например, заблокированные мьютексы, ожидание на условной переменной)
    - Текущий статус потока (выполняется, ожидает, завершён и т. д.)
6. Дополнительная информация:
    - Информация о привилегиях: Режимы работы (пользовательский или привилегированный режим)
    - Текущий контекст ввода-вывода: Файловые дескрипторы и указатели файлов
    - Привязка к процессору: На каком ядре процессора выполняется поток

#### Сравнение времени переключения контекста

| Тип переключения        | Время переключения | На что тратится время                                                                                                                                                                                                        |
| ----------------------- | ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Пользовательские потоки | Наименьшее         | Смена регистров процессора (в том числе указателя стека)                                                                                                                                                                     |
| Потоки ядра             | Среднее            | Всё предыдущее + сохранение task_struct и информации о потоках (приоритеты, привязка к ядрам и т.д.) + работа в пространстве ядра (системные вызовы)                                                                         |
| Процессы                | Наибольшее         | Всё предыдущее + смена адресного пространства (смена таблицы трансляций из-за изоляции памяти) + сохранение системных ресурсов (дескрипторы, файлы, устройства и т.д.) + сброс кэша (из-за изменения адресного пространства) |

#### Элементы кода для работы с пользовательским переключением контекста

- `ucontext_t` - структура для хранения контекста исполнения. Содержит:
	- `uc_stack` - указатель на стек, который будет использоваться при выполнении данного контекста
	- `uc_sigmask` - множество сигналов, которые блокируются при выполнении этого контекста
	- **`uc_mcontext`** - аппаратно-зависимое описание состояния процессора (регистры)
	- `uc_link` - указатель на следующий контекст, который будет восстановлен после завершения текущего (если указано `NULL`, то при завершении тукущего контекста завершиться вся программа)

- `int getcontext(ucontext_t *ucp);` - сохраняет текущий контекст выполнения
	- `ucp` — указатель на структуру `ucontext_t`, куда сохраняется текущий контекст

- `int setcontext(const ucontext_t *ucp);` - восстанавливает контекст выполнения
	- `ucp` — указатель на структуру `ucontext_t`, содержащую контекст для восстановления

- `void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);` - используется для настройки контекста выполнения, который можно передать в функцию setcontext или swapcontext. Она позволяет определить, что будет выполняться (какая функция), когда управление перейдёт к заданному контексту
	- `ucp` - указатель на объект типа `ucontext_t`, который содержит контекст выполнения
	- `func` - функция, которая будет вызвана, когда управление перейдёт к данному контексту
	- `argc` - число аргументов, передаваемых в функцию `func`
	- `...` - аргументы, передаваемые в функцию `func` (в неё можно передать только int-ы). Замечание: аргументы передаются не через обычный вызов функции, а через стек, который предварительно настроен в контексте. Это значит, что `makecontext` сам "готовит" вызов функции, используя переданные аргументы, а не компилятор

- `int swapcontext(ucontext_t *old_context, const ucontext_t *new_context);` - свап контекстов. Сохраняет текущий контекст и переключается на другой
	- `old_context` - указатель на структуру, в которую будет сохранён текущий контекст
	- `new_context` - указатель на структуру, содержащую контекст, к которому нужно переключиться

## Синхронизация

### Механизмы синхронизации

#### Основные механизмы:
- *На уровне ядра* (предоставляются операционной системой):
	- [[#Mutex|Мьютекс]]
	- [[#Futex]]
	- [[#Spinlock|Спинлок]]
	- [[#Семафоры]]
	- [[#Условные переменные]]
	- [[#RW-Locks]]
	- [[#Барьеры]]
- *На уровне пользователя*:
	- [[#Compare And Swap|CAS]]
	- [[#Барьеры памяти]]

| Механизм | Преимущества                   | Недостатки                   |
| -------- | ------------------------------ | ---------------------------- |
| Мьютекс  | Простота, универсальность      | Возможность взаимоблокировок |
| Семафор  | Ограничение параллелизма       | Требует больше ресурсов      |
| Спинлок  | Быстрота на коротких секциях   | Нагрузка на CPU              |
| RW-Lock  | Баланс между чтением и записью | Сложнее в использовании      |
| Futex    | Минимизация затрат на ядро     | Только на Linux              |

| **Механизм синхронизации**                          | **Описание**                                                                                                              | **Плюсы**                                                                                                                                               | **Минусы**                                                                                                                                               | **Применение**                                                                            |
| --------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **Мьютекс (`=pthread_mutex_t`)**                    | Бинарный объект блокировки для защиты критической секции                                                                  | - Высокая производительность при небольшом количестве потоков <br>- Прост в использовании                                                               | - Поток может заблокироваться, если мьютекс занял другой поток<br>- Возможны deadlock'и при неправильном использовании                                   | Защита критических секций, где доступ к ресурсу должен быть строго последовательным       |
| **Рекурсивный мьютекс (`PTHREAD_MUTEX_RECURSIVE`)** | Модификация мьютекса, позволяющая одному и тому же потоку блокировать его несколько раз                                   | - Удобен для функций, вызывающих друг друга и работающих с одним и тем же ресурсом<br>- Избегает deadlock'ов при повторной блокировке одним потоком     | - Производительность ниже, чем у обычного мьютекса  <br>- Может привести к сложному коду и трудноуловимым ошибкам                                        | Рекурсивные функции, работающие с одним ресурсом                                          |
| **Семафор (`sem_t`)**                               | Счётчик, ограничивающий доступ к ресурсу для определённого количества потоков                                             | - Удобен для контроля доступа к ресурсам, разделяемым несколькими потоками<br>- Может использоваться между процессами                                   | - Более сложен в использовании, чем мьютексы<br>- Нет встроенной привязки к конкретному потоку (любой поток может разблокировать)                        | Ограничение числа потоков, одновременно работающих с ресурсом (например, пул соединений)  |
| **Условная переменная (`pthread_cond_t`)**          | Механизм для ожидания изменения состояния, связанный с мьютексом                                                          | - Удобен для реализации событийной синхронизации<br>- Потоки засыпают до тех пор, пока другое событие не пробудит их                                    | - Требует правильной работы с мьютексами<br>- Может привести к спонтанным пробуждениям (spurious wakeups)                                                | Ожидание событий (например, когда очередь становится непустой)                            |
| **Барьеры (`pthread_barrier_t`)**                   | Синхронизирует группу потоков, заставляя их ждать друг друга                                                              | - Удобен для ситуаций, где все потоки должны дойти до одной точки перед продолжением<br>- Простая концепция                                             | - Не поддерживает динамическое изменение количества потоков <br>- Не так гибок, как условные переменные                                                  | Синхронизация этапов выполнения в алгоритмах (например, итеративные вычисления)           |
| **RW-блокировка (`pthread_rwlock_t`)**              | Разделяет доступ между читателями и писателями: позволяет нескольким потокам читать одновременно, но только одному писать | - Увеличивает производительность при большом количестве чтений и редких записях <br>- Гарантирует синхронизацию между читателями и писателями           | - Сложность реализации, если число читателей/писателей нестабильно<br>- Может привести к starvation (например, когда потоки-писатели не получают доступ) | Разделение ресурсов, где преобладает чтение над записью (например, кеши, базы данных)     |
| **Фьютикс (`futex`)**                               | Быстрая блокировка, основанная на пользовательском пространстве, с минимальным обращением к ядру                          | - Очень высокая производительность<br>- Меньше системных вызовов при частой разблокировке<br>- Используется в реализациях мьютексов и других примитивов | - Низкоуровневый API.  <br>- Не удобен для использования напрямую в `pthread`<br>- Нужен контроль состояний и логики                                     | Реализация высокопроизводительных примитивов синхронизации                                |
| **Спинлок (`pthread_spinlock_t`)**                  | Простая блокировка, где поток активно ждёт, пока не освободится ресурс                                                    | - Высокая производительность при коротких критических секциях<br>- Избегает затрат на системные вызовы                                                  | - Неэффективен при долгих ожиданиях (сжирает CPU)<br>- Не рекурсивен.  <br>- Не подходит для I/O-зависимых операций                                      | Критические секции с коротким временем ожидания (например, на многопроцессорных системах) |

### Compare And Swap

**CAS-операция** - атомарная операция сравнения и присвоения.
По логике работает примерно как следующий псевдокод (только атомарно):
```c
int CAS(flag, old, new)
{
	if (*flag != old)
		return 0;
	*flag = new;
	return 1;
}
```

#### CAS функции:
- `_Bool atomic_compare_exchange_strong(volatile A *obj, C *expected, C desired)`
	- **`obj`** - указатель на атомарную переменную, значение которой нужно проверить и, при необходимости, обновить
	- **`expected`** - указатель на переменную, содержащую предполагаемое значение `obj`. Если текущее значение `obj` не совпадает с `*expected`, то `*expected` будет обновлено до текущего значения `obj`
	- **`desired`** - новое значение, которое будет записано в `obj`, если текущее значение `obj` совпадает с `*expected`
	- Возвращает `_Bool` (true/false) - произощёл обмен или нет
- `atomic_compare_exchange_weak` — слабая версия CAS
	- Делает то же самое, что и "сильная" версия, но с важным отличием: Может спонтанно "провалиться". Это означает, что даже если ожидаемое значение `expected` совпадает с текущим значением атомарной переменной, операция всё равно может вернуть неуспех (false), не изменяя переменную. Такое поведение связано с архитектурными особенностями некоторых процессоров, где операция CAS может иногда "отменяться" по разным причинам (например, из-за оптимизаций)

### Spinlock

**Спинлоки** используются для синхронизации между потоками, где предполагается, что блокировка будет удерживаться короткое время. Вместо того чтобы блокировать поток, как в случае мьютексов, спинлоки "крутятся" в цикле, ожидая освобождения блокировки

#### Основные функции:
1. `int pthread_spin_init(pthread_spinlock_t *lock, int pshared)`
	- Инициализация спинлока
    - **`lock`** — указатель на объект типа `pthread_spinlock_t`
    - **`pshared`** — указывает, будет ли спинлок доступен только в рамках одного процесса или между процессами:
        - `PTHREAD_PROCESS_PRIVATE` — доступен только в текущем процессе.
        - `PTHREAD_PROCESS_SHARED` — может использоваться между процессами (если поддерживается системой)
2. `int pthread_spin_destroy(pthread_spinlock_t *lock)`
	- Уничтожение спинлока
    - Освобождает ресурсы, связанные со спинлоком. Не уничтожайте спинлок, пока на него ссылаются другие потоки
3. `int pthread_spin_lock(pthread_spinlock_t *lock)`
    - Захватывает спинлок. Если он уже захвачен другим потоком, текущий поток будет "крутиться" в цикле, ожидая освобождения
4. `int pthread_spin_trylock(pthread_spinlock_t *lock)`
    - Попытка захвата спинлока (без блокировки)
    - Захватывает спинлок, если он свободен. Если занят, возвращает `EBUSY`
5. `int pthread_spin_unlock(pthread_spinlock_t *lock)`
    - Освобождает спинлок, делая его доступным для других потоков

#### Ограничения спинлоков
1. *Время ожидания*: Если поток долго удерживает спинлок, другие потоки будут расходовать процессорное время впустую.
2. *Приоритетное инверсирование*: Если поток с низким приоритетом удерживает спинлок, высокоприоритетный поток будет вынужден ждать, что приводит к инверсии приоритетов.
3. *Портативность*: Спинлоки доступны не во всех системах POSIX. Перед использованием убедитесь, что ваша система их поддерживает.

#### Пример простой реализации спинлока:
```c
typedef struct {
    atomic_flag lock;
} spinlock_t;

void spinlock_acquire(spinlock_t *lock) {
    while (atomic_flag_test_and_set(&lock->lock)) {
        // Пустой цикл ...
        // atomic_flag_test_and_set - устанавливает атомарный флаг в true и
        // возвращает его предыдущее значение
    }
}

void spinlock_release(spinlock_t *lock) {
    atomic_flag_clear(&lock->lock);
}

```

### Futex

**Futex** (Fast Userspace Mutex) — это низкоуровневый механизм синхронизации, по минимому использующий системные вызовы. Он решает проблему спинлока (бесполезная загрузка процессора) с помощью перевода потоков в состояние SLEEP и обратно в RUNNABLE. На его основе создаются высокопроизводительных синхронизирующие примитивы (мьютексы, семафоры)

Futex использует разделяемую переменную в памяти (обычно типа `int`), которую потоки проверяют и изменяют атомарными операциями. Это позволяет:
- Синхронизировать доступ к ресурсу без вмешательства ядра, если блокировка свободна
- При необходимости блокировать поток, обращаясь к ядру

#### Основные состояния процесса:
1. *RUN* - сейчас выполняется
2. *RUNNABLE* - может выполняться (планировщик может выбрать эту задачу для выполнения, переведя её тем самым в состояние RUN)
3. *SLEEP* - не может выполняться, так как ждёт какого-то события. Процессорное время имеется, но делать нечего

#### Интерфейс фьютекса:
`int futex(int *uaddr, int futex_op, int val, const struct timespec *timeout, int *uaddr2, int val3)`
- `uaddr` - указатель на переменную в памяти, используемую для синхронизации
- `futex_op` - операция, которую нужно выполнить
- `val` - значение, используемое в зависимости от операции
- `timeout` - таймаут для операций ожидания (опционально)
- `uaddr2` и `val3` - дополнительные параметры для более сложных операций

#### Основные операции Futex:
- `futex(uaddr, FUTEX_WAIT, expected_val, NULL, NULL, 0);` - переводит поток в режим ожидания, если значение переменной равно заданному. Если значение не совпадает, поток продолжает работу
- `futex(uaddr, FUTEX_WAKE, num_threads_to_wake, NULL, NULL, 0);` - пробуждает один или несколько потоков, ожидающих на данном адресе

#### Замечания:
- Интерфейс Futex в Linux — системный вызов `syscall(SYS_futex, ...)`
- Вместо нескольких функция для работы с примитовом, у фьютекса есть только одна универсальная функция, в которую надо передавать номер, определяющий, какая именно операция должна выполниться
- Переменная синхронизации вынесена в пользовательское пространство для обеспечения гибкости, универсальности и минимизации системных вызовов. Это ключевой принцип фьютексов — оставить максимальную часть работы на стороне пользователя, используя ядро только для операций блокировки и пробуждения

### Mutex

**Мьютекс** (от mutual exclusion, "взаимное исключение") — работает как замок: только один поток может завладеть мьютексом в данный момент времени, получая доступ к ресурсу. Остальные потоки должны ждать, пока мьютекс освободится

#### Как работает?
1. Захват мьютекса: поток блокирует мьютекс перед доступом к ресурсу. Если поток пытается захватить уже занятый мьютекс, он будет ждать (перейдёт в режим сна) до тех пор, пока мьютекс не освободится
2. Критическая секция: поток выполняет операции с ресурсом
3. Освобождение мьютекса: поток освобождает мьютекс, чтобы другие потоки могли получить доступ

#### Типы мьютексов:
1. **Обычный** (PTHREAD_MUTEX_NORMAL):
    - Самый простой мьютекс
    - Один поток может захватить мьютекс, другие потоки блокируются до его освобождения
    - Используется для синхронизации доступа к ресурсам
2. **Рекурсивный** (PTHREAD_MUTEX_RECURSIVE):
    - Позволяет одному и тому же потоку захватить мьютекс несколько раз
    - Полезен, если функции вызываются рекурсивно и требуется повторный доступ к одному ресурсу
    - Поток должен освободить мьютекс столько же раз, сколько он его захватил
3. **Тайм-аутный** (Timed Mutex):
    - Позволяет потоку попытаться захватить мьютекс в течение определённого времени
    - Если мьютекс не освободится за это время, поток получит уведомление о неудаче
4. **Приоритетный** (Priority Mutex):
    - Гарантирует, что потоки с более высоким приоритетом получат доступ к мьютексу раньше, чем потоки с более низким приоритетом
5. **Мьютекс с проверкой ошибок** (PTHREAD_MUTEX_ERRORCHECK):
    - Добавляет проверки на корректность вызова
    - В отличае от обычного мьютекса при возникновении ошибки не происходит undefined behavior
    - Потенциальные ошибки:
	    - Если поток пытается снова заблокировать мьютекс, который он уже захватил, возвращается ошибка `EDEADLK` (потенциальный deadlock)
	    - Если поток пытается разблокировать мьютекс, который не захвачен, возвращается ошибка `EPERM`
	    - Если поток разблокирует мьютекс, захваченный другим потоком, возвращается ошибка `EPERM`

##### Изменение типа мьютекса:
```c
pthread_mutex_t mutex;
pthread_mutexattr_t attr; 
// Инициализация атрибутов мьютекса
pthread_mutexattr_init(&attr); 
pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK); 
// Инициализация мьютекса 
pthread_mutex_init(&mutex, &attr);
```

#### Функции для работы с обычным мьютексом:
- `int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);` - инициализирует мьютекс с заданными атрибутами или значениями по умолчанию (если передать NULL в аргументах)
- `int pthread_mutex_lock(pthread_mutex_t *mutex);` - захватывает мьютекс, блокируя выполнение потока, если мьютекс уже захвачен
- `int pthread_mutex_trylock(pthread_mutex_t *mutex);` - пытается захватить мьютекс. Если мьютекс уже захвачен, возвращает немедленно
- `int pthread_mutex_unlock(pthread_mutex_t *mutex);` - освобождает ранее захваченный мьютекс
- `int pthread_mutex_destroy(pthread_mutex_t *mutex);` - освобождает ресурсы, связанные с мьютексом

#### Особенности мьютексов:
1. *Deadlock* (взаимная блокировка):
    - Может произойти, если два потока захватили разные мьютексы и ждут друг друга для их освобождения
2. *Race Condition* (состояние гонки):
    - Если мьютекс не используется или используется неправильно, несколько потоков могут одновременно получить доступ к ресурсу, что приведёт к непредсказуемому поведению
3. *Производительность*:
    - Захват мьютекса может быть дорогой операцией из-за переключения контекста между потоками

### Условные переменные

**Условные переменные** (Condition Variables) позволяют потокам ожидать наступления определённых условий, одновременно освобождая связанный мьютекс, чтобы другие потоки могли изменять эти условия. Это удобное средство синхронизации, помогающее избежать холостых циклов

#### Основные функции:
- `int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);` - Инициализирует условную переменную
- `int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);` - освобождает мьютекс и блокирует поток до тех пор, пока другой поток не подаст сигнал об изменении условия
- `int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);` - как pthread_cond_wait, но с тайм-аутом
- `int pthread_cond_signal(pthread_cond_t *cond);` - пробуждает один поток, ожидающий на условной переменной. Пробуждающийся поток сначала пытается обратно захватить мьютекс. Только после успешного захвата мьютекса поток продолжает выполнение. Если мьютекс уже захвачен другим потоком, пробуждённый поток остаётся заблокированным, пока мьютекс не станет доступным
- `int pthread_cond_broadcast(pthread_cond_t *cond);` - как pthread_cond_signal, но пробуждает все потоки, ожидающие на условной переменной
- `int pthread_cond_destroy(pthread_cond_t *cond);` - освобождает ресурсы, связанные с условной переменной

#### Особенности условных переменных:
1. *Обязательная блокировка мьютекса*: Условные переменные работают только в связке с мьютексами.
2. *Спуриация пробуждений*: Поток может проснуться без явного сигнала, поэтому важно повторно проверять условие после пробуждения.
3. *Производительность*: Условные переменные позволяют избежать холостого цикла, что делает их более эффективными для синхронизации.

### Семафоры

**Семафоры** — предоставляют простой способ ограничить количество потоков, одновременно использующих ресурс. Семафор — это целочисленный счётчик, который указывает, сколько потоков или процессов могут одновременно получить доступ к ресурсу

#### Типы семафоров:
- **Бинарный семафор** (аналог мьютекса): принимает значения 0 или 1, используется для управления доступом к одному ресурсу. В отличае от мьютекса бинарный симофор не обязательно освобождается тем же потоков, который его захватил
- **Счётный семафор**: принимает значения от 0 до некоторого максимума, ограничивая количество потоков, которым одновременно разрешён доступ

#### Основные операции:
- `int sem_init(sem_t *sem, int pshared, unsigned int value);` - инициализация
    - `pshared = 0` - семафор используется только потоками внутри процесса
    - `value` - начальное значение счётчика семафора
- `int sem_destroy(sem_t *sem);` - удаление
- `sem_wait` - уменьшает значение семафора, блокирует, если значение ≤ 0
- `sem_post` - увеличивает значение семафора, пробуждая ожидающие потоки
- `sem_trywait` - не блокирует, если семафор недоступен

#### Зачем нужны семафоры?
- Используются для ограничения количества потоков или процессов, одновременно имеющих доступ к ресурсу (например, пул соединений, фиксированное количество файлов или сетевых подключений)
- Пример: Если есть 5 принтеров, семафор с начальным значением 5 гарантирует, что одновременно будет использоваться не больше 5 принтеров

#### Особенности семафоров:
- Не привязан к конкретному потоку:
    - Семафоры не имеют понятия "владельца". Это значит, что один поток может уменьшить счётчик, а другой поток может его увеличить
- Могут работать между процессами:
    - Семафоры можно использовать для синхронизации процессов (межпроцессная синхронизация). Это отличает их от мьютексов, которые чаще всего работают в пределах одного процесса

### RW-Locks

**RW-Locks** — это тип синхронизирующего примитива, позволяющий управлять доступом к ресурсу с учетом разделения операций на чтение и запись. Они полезны, когда требуется обеспечить параллельный доступ для операций чтения при условии, что запись выполняется только одной сущностью одновременно

#### Два уровня блокировки:
1. *Читательский блок (shared lock)*:
    - Множественные потоки могут захватывать блокировку на чтение одновременно, если нет активной блокировки на запись
    - Это оптимизирует производительность для операций чтения, которые не изменяют общий ресурс
2. *Писательский блок (exclusive lock)*:
    - Блокировка на запись захватывается только одним потоком
    - Все другие потоки (как читающие, так и записывающие) должны ждать, пока писатель освободит блокировку

#### Функции:
- `pthread_rwlock_init(&rwlock, NULL);` - инициализация
- `pthread_rwlock_rdlock(&rwlock);` - захватывает блокировку на чтение. Если есть активный писатель, поток блокируется
- `pthread_rwlock_wrlock(&rwlock);` - захватывает блокировку на запись. Все читатели и другие писатели блокируются
- `if (pthread_rwlock_tryrdlock(&rwlock) == 0) { // Захват успешен }` - попытка захвата
- `if (pthread_rwlock_trywrlock(&rwlock) == 0) { // Захват успешен }` - попытка захвата
- `pthread_rwlock_unlock(&rwlock);` - освобождение блокировки
- `pthread_rwlock_destroy(&rwlock);` -  уничтожение

#### Замечания:
- В каждый момент времени возможны только следующие сценарии:
	- Один поток пишет (write lock)
	- Несколько потоков одновременно читают (read lock)
	- Ни один поток ничего не делает (ресурс свободен)
- RW-Locks обеспечивают более высокую производительность, чем обычные мьютексы, для сценариев с высокой частотой операций чтения, так как они позволяют множественным потокам читать одновременно
- Проблемы с читателями и писателями:
    - Если читатели занимают ресурс слишком долго, писатели могут быть заблокированы на неопределенное время (*starvation писателей*)
    - Если приоритет у писателей, читатели могут страдать от задержек (ногие реализации дают предпочтение либо читателям, либо писателям)

#### RW-Locks подходят, если:
1. Чтения ресурса происходят гораздо чаще, чем записи
2. Чтения являются независимыми и не изменяют состояние ресурса
3. Вы хотите оптимизировать производительность для параллельных операций чтения

### Барьеры

**Барьеры**  — это механизмы, которые позволяют нескольким потокам или процессам согласовывать свои действия, гарантируя, что каждый из них достигает определённой точки (называемой барьером) перед продолжением выполнения. Барьеры используются для обеспечения синхронности между потоками в многопоточных программах

#### Как работают барьеры?
1. Потоки выполняют свои задачи параллельно
2. В определённый момент они вызывают функцию, связанную с барьером (например, `pthread_barrier_wait` в POSIX)
3. Каждый поток блокируется при достижении барьера и ждёт, пока все другие потоки также не достигнут барьера
4. Когда все потоки достигли барьера, они продолжают выполнение

#### Особенности и ограничения:
1. *Число участников*:
    - Барьер заранее инициализируется с числом потоков, которые должны его достичь. Это число обычно фиксировано
2. *Необходимость учёта всех потоков*:
    - Если один поток не достигает барьера (например, зависает), остальные потоки будут ждать бесконечно, что приведёт к deadlock
3. *Неудобство при динамическом изменении числа потоков*:
    - Барьеры не подходят, если число потоков в процессе синхронизации меняется

### Барьеры памяти

**Барьеры памяти** (memory barriers) — это механизм, используемый в многопоточном программировании для управления порядком выполнения операций с памятью. Они обеспечивают гарантии о том, что операции записи и чтения данных в память будут выполняться в определённом порядке, несмотря на возможные оптимизации процессора или компилятора

#### Почему нужны барьеры памяти?
1. *Переупорядочивание инструкций:*
    - Процессор может менять порядок выполнения операций, чтобы лучше использовать доступные ресурсы
2. *Кэширование:*
    - Разные ядра могут видеть устаревшие значения данных из кэша, что нарушает согласованность данных
3. *Оптимизация компилятора:*
    - Компилятор может удалить или переставить инструкции, если они кажутся независимыми

#### Типы барьеров памяти:
1. **Load Barrier**:
    - Гарантирует, что все операции чтения, выполненные до барьера, завершатся до начала операций чтения после барьера
2. **Store Barrier**:
    - Гарантирует, что все операции записи, выполненные до барьера, завершатся до начала операций записи после барьера
3. **Full Barrier**:
    - Гарантирует, что все операции записи и чтения, выполненные до барьера, завершатся до начала операций чтения и записи после барьера
4. **Acquire/Release Barriers**:    
    - **Acquire**: предотвращает переупорядочивание инструкций до барьера
    - **Release**: предотвращает переупорядочивание инструкций после барьера

#### Когда использовать барьеры памяти?
1. *Работа с lock-free алгоритмами:*
    - Контроль порядка операций критичен
2. *Согласованность данных между потоками:*
    - Гарантия видимости изменений
3. *Улучшение производительности:*
    - Различные типы барьеров помогают минимизировать затраты на синхронизацию

### Атомарные операции

**Атомарные переменные** — это переменные, для которых операции чтения, записи и сравнения выполняются как неделимые (атомарные). Это значит, что в многопоточном окружении доступ к такой переменной не прерывается и не вызывает гонок данных

**Атомарные операции** — это операции, которые выполняются без возможности их прерывания другими потоками. Они гарантируют согласованность данных при работе с разделяемыми ресурсами

#### Атомарные типы:
- `atomic_int` - атомарный тип для целых чисел
- `atomic_intptr_t` - атомарный тип для указателей целых чисел (`intptr_t`)
- `atomic_size_t` - атомарный тип для размера объектов (`size_t`)
- `atomic_void *` - атомарный указатель на произвольный тип данных
- `atomic_flag` - булевая атомарная переменная
- `_Atomic(type)` - универсальный атомарный тип. Например: `_Atomic(float)`
- И так далее...

#### Ключевые функции атомарных операций:
- `atomic_load` - атомарное читает значения переменной
- `atomic_store` - атомарная запись значения в переменную
- `atomic_fetch_add` - атомарное добавление (возвращает предыдущее значение)
- `atomic_fetch_sub` - атомарное вычитание (возвращает предыдущее значение)
- `atomic_compare_exchange_strong` - сравнивает и, если совпадает, изменяет значение
- `atomic_compare_exchange_weak` - слабая версия, может ложно завершаться неудачно
- `atomic_flag_clear` - установка атомарного флага в false
- `atomic_flag_test_and_set` - устанавливает атомарный флаг в true и возвращает его предыдущее значение

#### Чтобы атомарно изменять переменную необходимо:
1. *Использовать атомарный тип* (например, `atomic_int` из `<stdatomic.h>`):
    - Эти типы специально разработаны для работы с атомарными операциями
    - Они обеспечивают гарантии атомарности благодаря встроенной аппаратной или программной поддержке
2. *Применять атомарные функции и макросы*:
    - Например, `atomic_load`, `atomic_store`, `atomic_fetch_add`, `atomic_compare_exchange_strong` из `<stdatomic.h>`.

#### Замечания:
- Атомарные операции не предназначены для обычных неатомарных типов
- Обычные операции не работают атомарно с переменными атомарных типов

## Дополнительные темы

### Lock-Free алгоритмы

**Lock-Free алгоритмы** — это алгоритмы, которые обеспечивают синхронизацию между потоками без использования блокировок (mutex, spinlock и т.п.). Они гарантируют, что по крайней мере один поток завершит свою операцию за конечное число шагов, независимо от поведения других потоков. Основной инструмент для реализации lock-free алгоритмов - атомарные операции. Lock-free алгоритмы находят применение в системах реального времени, базах данных и других приложениях, где минимизация задержек имеет ключевое значение.

#### Популярные lock-free алгоритмы:
1. Lock-Free Стек
2. Lock-Free Очередь
3. Lock-Free Кольцевой Буфер
4. Lock-Free Списки
5. Lock-Free Хэш-таблица
6. Lock-Free Счётчики
7. Lock-Free Деки
8. Lock-Free Массивы

#### Гарантии lock-free алгоритмов:
- *Lock-Free*: Гарантия прогресса хотя бы одного потока.
- *Wait-Free*: Гарантия прогресса всех потоков за конечное время.
- *Obstruction-Free*: Поток завершит операцию, если не будет конкуренции.

#### Преимущества Lock-Free алгоритмов:
1. Избегают deadlock, starvation и priority inversion.
2. Улучшают производительность в условиях высокой параллельности.
3. Лучше масштабируются на многоядерных системах.

#### Недостатки Lock-Free алгоритмов:
1. Более сложная реализация по сравнению с блокировками.
2. Требуют атомарных операций, которые могут быть медленнее на старых процессорах.
3. Зависимость от архитектуры процессора (некоторые инструкции недоступны на всех системах).
4. ABA-проблема:
	- Возникает, когда указатель A изменился на B, а затем обратно на A, но операция CAS не обнаруживает изменений.
	- Решения: использование счетчиков версий либо примитивы, такие как double-wide CAS (где CAS проверяет одновременно указатель и версию).

### Терминалы

**Shell** (оболочка) — это программа, предоставляющая интерфейс между пользователем и операционной системой. Shell позволяет запускать команды, программы и скрипты, а также управлять процессами и файловой системой

##### Основные оболочки из UNIX:
- *Bash* (Bourne Again Shell): наиболее популярная оболочка в Linux. Обеспечивает мощные возможности, такие как редактирование команд, автодополнение, функции и скрипты.
- *sh* (Bourne Shell): классическая оболочка UNIX, изначально разработанная для написания скриптов.
- *zsh* (Z Shell): улучшенная оболочка с поддержкой тем, плагинов и улучшенного автодополнения.
- *fish* (Friendly Interactive Shell): более современная оболочка с удобным интерфейсом и встроенными функциями автодополнения.
- *ksh* (KornShell): расширение Bourne Shell с добавлением возможностей программирования.

**Tmux** (от "terminal multiplexer") — это инструмент для многозадачной работы в командной строке, который позволяет запускать несколько терминальных сессий в одном окне, а также управлять ими. Он является популярным среди разработчиков и системных администраторов для управления несколькими задачами в одном терминале.

### HTTP кэширующий прокси

#### Ключевые моменты
- *HTTP/1.0 не поддерживает постоянные соединения* по умолчанию. После обработки запроса сервер может закрыть соединение.
- *Каждый HTTP/1.0 запрос требует нового TCP-соединения*, что снижает эффективность по сравнению с HTTP/1.1, где используется "Keep-Alive".

#### Структура HTTP-запроса:
1. Стартовая строка (Request Line):
	- `<Метод> <URL> <Версия HTTP>` - тип запроса, целевой ресурс и версия HTTP
	- Пример: GET /index.html HTTP/1.0
2. Заголовки (Headers):
	- Пары ключ: значение, определяющие дополнительную информацию для сервера
	  - Пример: Host: example.com
		           User-Agent: Mozilla/5.0
		           Accept: text/html
3. Пустая строка:
	- Отделяет заголовки от тела запроса. Если тела запроса нет, запрос заканчивается здесь
4. Тело запроса (Body):
	- Может содержать данные для передачи на сервер (например, при методе POST)

#### Структура URL
URL := <протокол> <хост> <порт> <путь> <запрос> <фрагмент>
Пример: `https://www.example.com:443/path/to/page?user=123#section`
- Протокол: `https`
- Имя хоста: `www.example.com`
- Порт: `443` (опускается, если используется стандартный порт для протокола)
- Путь: `/path/to/page`
- Запрос: `?user=123`
- Фрагмент: `#section`

#### Пример последовательности передачи
Клиент отправляет запрос:
```
GET /index.html HTTP/1.0\r\n
Host: example.com\r\n
\r\n
```
Сервер обрабатывает запрос и отправляет ответ:
```
HTTP/1.0 200 OK\r\n
Content-Length: 13\r\n
\r\n
Hello, World!
```

Пример настройки прозрачного прокси с использованием iptables (для Linux):
`iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 3128`
В данном случае все запросы на порту 80 будут перенаправлены через прокси, устанавливая два соединения.

### Запуск системы

Запуск системы Linux проходит через несколько ключевых этапов, каждый из которых запускает определенные процессы и инициализирует компоненты системы. Вот подробное описание этих этапов:

#### 1. BIOS / UEFI (или загрузчик)

Когда вы включаете компьютер, первым запускается **BIOS** (Basic Input/Output System) или **UEFI** (Unified Extensible Firmware Interface), которые выполняют несколько базовых функций:
- **POST (Power-On Self Test)** — проверка оборудования, включая процессор, память, устройства ввода/вывода и другие компоненты
- **Загрузка загрузчика** — BIOS/UEFI ищет на жестком диске или другом устройстве загрузки (например, в сети) раздел, на котором находится загрузчик операционной системы. Он может быть на MBR (Master Boot Record) или в GPT (GUID Partition Table) — в зависимости от того, используется ли BIOS или UEFI

#### 2. Загрузчик (GRUB)

После того как BIOS/UEFI находит загрузчик, чаще всего это **GRUB (Grand Unified Bootloader)**, который:
- **Загружает ядро Linux** — GRUB выбирает и загружает ядро Linux (обычно файл `vmlinuz`) в память
- **Загружает initrd (initial ramdisk)** — это временная файловая система, которая используется до монтирования основной файловой системы. Она содержит драйверы, которые необходимы для начала работы с файловыми системами и устройства хранения данных
- **Конфигурация загрузки** — GRUB может предложить выбор между несколькими версиями ядра или операционными системами, если это настроено.

#### 3. Ядро Linux (Kernel)

После того как GRUB загружает ядро в память, оно начинает свою работу. Основные этапы работы ядра:
- **Декомпрессия ядра** — ядро может быть сжато, и на этом этапе оно распаковывается в память
- **Инициализация ядра** — ядро инициализирует необходимые драйверы для работы с оборудованием (например, жесткими дисками, процессорами, памятью, сетевыми картами)
- **Монтаж root файловой системы** — ядро находит корневую файловую систему (обычно через `initrd`), и монтирует её
- **Запуск процесса init** — когда ядро готово, оно запускает процесс с PID 1, который управляет всеми остальными процессами в системе. Это процесс **init** (или его современная альтернатива — **systemd**)

#### 4. Система инициализации (init)

Процесс `init` (или его современный заменитель **systemd**) отвечает за запуск всей системы и управление ею. Он выполняет несколько важных функций:
- **Запуск всех необходимых сервисов** — init (или systemd) запускает набор необходимых системных служб и демонов, таких как сетевые сервисы, сервисы управления логами, службы безопасности и другие
- **Загрузка конфигураций** — systemd читает свои конфигурационные файлы (например, `/etc/systemd/system/`), чтобы инициализировать нужные службы
- В случае с **systemd**, это происходит через **unit файлы**, которые управляют запуском сервисов и других системных процессов

#### 5. Запуск пользовательских процессов

После инициализации всех системных сервисов, система готова к запуску пользовательских процессов:
- **Учетные записи пользователей** — systemd запускает процессы, такие как **getty**, которые позволяют пользователю войти в систему
- **Графическая оболочка** — если настроен графический интерфейс, запускается дисплейный менеджер (например, **GDM**, **LightDM**, **SDDM**), который запускает оконную систему, такую как **X11** или **Wayland**, и графическую оболочку, например, **GNOME** или **KDE**

#### 6. Окончательная настройка и работа системы

На этом этапе:
- **Вход пользователя** — пользователь входит в систему, запускаются его процессы (например, оболочка **bash**)
- **Запуск программ** — пользователь может запускать программы, работать с сетью, файловой системой и т.д

### Кэш

#### Основные виды кэш-памяти

1. **Кэш процессора (CPU Cache)**
    Это **мелкозернистая кэш-память**, которая расположена прямо на процессоре или рядом с ним. Она значительно быстрее, чем основная память (RAM), и служит для хранения недавно использованных инструкций и данных, к которым процессор часто обращается. Кэш процессора разделяется на несколько уровней, каждый из которых имеет разную скорость и размер
    - **L1 Cache** (Level 1 Cache) — самый быстрый и самый маленький кэш, обычно встроен непосредственно в процессор. Он хранит данные, которые недавно использовались или могут быть использованы в ближайшее время
    - **L2 Cache** (Level 2 Cache) — немного медленнее, чем L1, но имеет больший размер. Часто находится на одном чипе с процессором, но может быть и внешним для некоторых архитектур
    - **L3 Cache** (Level 3 Cache) — ещё более медленный и более крупный кэш, который обычно разделяется несколькими ядрами процессора. Он используется для хранения данных, которые могут понадобиться сразу нескольким ядрам
    **Принцип работы**:
    - Когда процессор запрашивает данные, сначала он проверяет наличие этих данных в **L1 Cache**. Если данные отсутствуют, кэш проверяется поочередно в **L2** и **L3**, и если в этих кэшах данные не найдены, процессор обращается к основной памяти (RAM)
    - Если данные найдены в одном из кэшей, это называется **cache hit** (попадание в кэш), и доступ к данным происходит гораздо быстрее, чем при обращении к основной памяти
    - Если данные не найдены в кэшах, происходит **cache miss** (промах), и процессор загружает данные из основной памяти в кэш, что замедляет выполнение
2. **Страница кэша (Page Cache)**
    В операционных системах, таких как Linux, существует также **страничный кэш**, который работает на уровне ядра операционной системы. Это кэш, в который загружаются часто используемые страницы данных из основной памяти. Страница — это фиксированный блок памяти, который операционная система использует для управления памятью
    **Как это работает**:
    - Когда программа обращается к файлу (например, при чтении из файла на диске), операционная система может загрузить части этого файла в **страничный кэш**
    - Если программа позже снова обратится к этим данным, операционная система может получить их из кэша, что значительно ускоряет доступ, поскольку чтение из памяти намного быстрее, чем из диска
    - Страничный кэш активно используется для ускорения доступа к данным с жестких дисков, SSD и других носителей данных
3. **Кэш трансляции (Translation Lookaside Buffer, TLB)**
    **TLB** — это специализированный кэш, используемый для ускорения трансляции виртуальных адресов в физические адреса. Когда процесс обращается к памяти, операционная система и процессор используют таблицы страниц для преобразования виртуальных адресов в физические. Этот процесс может занимать время, поэтому существует TLB, который кеширует результаты последних преобразований
    **Как это работает**:
    - Когда процессор пытается перевести виртуальный адрес в физический, он сначала проверяет **TLB**
    - Если требуемый адрес уже есть в TLB (это называется **TLB hit**), то процессор сразу использует физический адрес, что ускоряет операцию
    - Если адреса нет в TLB (**TLB miss**), процессор обращается к таблицам страниц в основной памяти для выполнения преобразования

## Экзамен

##### В ответе на вопросы экзаменатор ожидает услышать
1. Описание технологии
2. Проблемы, которые решает данная технология
3. Каким образом решаются указанные проблемы
4. Особенности реализации
5. Функции или системные вызовы, связанные с технологией
6. Какие новые проблемы появляются

##### Вопросы по первому семестру
- [x] 1. Понятие процесса в Операционной системе. Создание-удаление процесса
- [x] 2. Исполнение программы. Переменные среды исполнения
- [x] 3. Пользователь. Идентификаторы пользователя
- [x] 4. Виртуальная память
- [x] 5. Адресное пространство процесса
- [x] 6. Отображение памяти (mmap)
- [x] 7. Системные вызовы
- [x] 8. Понятие файла. Операции с файлами
- [x] 9. Блокирующий и неблокирующий ввод-вывод. Мультиплексирование ввода-вывода
- [x] 10. Файловые системы
- [x] 11. Межпроцессное взаимодействие. Pipe
- [x] 12. Межпроцессное взаимодействие. Разделяемая память
- [x] 13. Межпроцессное взаимодействие. Сокеты
- [ ] 14. Терминальный ввод-вывод
- [x] 15. Сигналы
- [x] 16. Способы выделения памяти в процессе
- [x] 17. Выделение памяти в куче

##### Вопросы по второму семестру
- [x] 1. Понятие потока. Системные и пользовательские потоки
- [x] 2. Понятие потока. Создание потока в POSIX
- [x] 3. Понятие потока. Завершение потока в POSIX
- [x] 4. Механизмы ОС Linux для создания системных потоков
- [x] 5. Механизмы ОС Linux для создания пользовательских потоков
- [x] 6. Объекты синхронизации. Spin lock
- [x] 7. Объекты синхронизации. Mutex
- [x] 8. Объекты синхронизации. Condition variable
- [x] 9. Объекты синхронизации. Read-Write lock
- [x] 10. Объекты синхронизации. Semaphore
- [x] 11. Объекты синхронизации. Barrier
- [x] 12. Обработка сигналов в многопоточной программе
- [x] 13. Мертвые и живые блокировки
- [x] 14. Механизмы ОС Linux для создания объектов синхронизации
- [x] 15. Задача потребитель-производитель
- [x] 16. Задача об обедающих философах
- [x] 17. Изоляция процессов

#### Понятие процесса в ОС. Создание-удаление процесса

Создание процесса - выделение памяти под структуру процесса и её инициализация

**Демон (daemon)** — это фоновый процесс в операционной системе, который выполняет системные или служебные задачи. Название происходит от греческого слова "δαίμων" (дух, хранитель) и связано с тем, что такие процессы «незаметно» помогают системе работать. Демоны это сервисы, которые предназначены для долгосрочной работы в фоновом режиме

##### Особенности демонов
1. **Работа в фоне**:
    - Демоны запускаются при старте системы и продолжают работать в фоновом режиме, не взаимодействуя напрямую с пользователем
2. **Назначение**:
    - Демоны обслуживают различные функции системы, такие как:
        - Обслуживание сети (например, `sshd`, `networkd`)
        - Обработка веб-запросов (например, `httpd` или `nginx`)
        - Управление файлами и принтерами (например, `cupsd`)
3. **Именование**:
    - Имена демонов обычно заканчиваются на `d`. Например:
        - `sshd` — сервер SSH
        - `systemd` — системный менеджер
        - `crond` — планировщик заданий
4. **Кто запускает демонов?**
    - Демоны обычно запускаются суперпользователем (root) или специальной учетной записью (например, `www-data` для веб-серверов), чтобы ограничить их привилегии
5. **Пример работы демона**:
    - Сервер SSH (sshd):
        - Ожидает входящих запросов на подключение через SSH
        - Обрабатывает запросы от клиентов, создавая отдельный процесс для каждого соединения

##### Основные этапы создания процесса
1. **Создание записи в таблице процессов:**
    - ОС резервирует место в своей таблице процессов для нового процесса (каждый процесс имеет уникальный идентификатор — PID)
    - Таблица процессов содержит информацию о состоянии процесса, приоритетах, родительском процессе, используемых ресурсах и др
2. **Копирование контекста процесса:**
    - При вызове `fork()` создаётся точная копия родительского процесса, включая память, регистры, дескрипторы файлов и другие ресурсы
    - При вызове `vfork()` или `clone()` ресурсы копируются частично или вовсе не копируются, чтобы минимизировать накладные расходы
3. **Инициализация нового процесса:**
    - Новый процесс получает собственное виртуальное адресное пространство
    - Для выполнения программы используется вызов `execve()`, который заменяет содержимое памяти новыми инструкциями и данными
4. **Назначение ресурсов:**
    - ОС выделяет ресурсы для процесса: память, файловые дескрипторы, процессорное время и др
5. **Добавление процесса в очередь планировщика:**
    - Новый процесс помещается в очередь задач планировщика, который решает, когда этот процесс будет выполнен

##### Как работает COW при fork()
- Вместо немедленного копирования всего виртуального адресного пространства родителя (памяти, стека, данных), дочерний процесс разделяет его с родителем
- Таблица страниц в MMU (Memory Management Unit) обоих процессов настраивается таким образом, чтобы виртуальные адреса указывали на одни и те же физические страницы
- Эти страницы помечаются как только для чтения
- Если один из процессов (родитель или дочерний) пытается изменить данные в памяти, срабатывает механизм COW:
    - Создаётся копия изменяемой страницы в физической памяти
    - Процесс, выполняющий запись, получает доступ к новой копии, а остальные продолжают использовать оригинал

##### Основные этапы удаления процесса
1. **Процесс завершает выполнение:**
    - Процесс может завершиться самостоятельно, вызвав `exit()` (или неявно, возвратив значение из `main()`)
    - Завершение может быть принудительным, если другой процесс (обычно родительский) вызывает `kill()`
2. **ОС отмечает процесс как "завершённый":**
    - В таблице процессов состояние процесса изменяется на "завершённый"
    - При этом процесс становится "зомби", чтобы родитель мог прочитать его код завершения с помощью `wait()` или `waitpid()`
3. **ОС освобождает ресурсы:**
    - Закрываются все открытые файловые дескрипторы
    - Освобождается память, выделенная процессу
    - Удаляются временные файлы и другие ресурсы
4. **Удаление записи из таблицы процессов:**
    - Когда родитель вызывает `wait()` или `waitpid()`, запись о процессе полностью удаляется

##### Состояния процесса
- `TASK_RUNNING` — процесс выполняется или готов к выполнению
- `TASK_INTERRUPTIBLE` — процесс ожидает события
- `TASK_UNINTERRUPTIBLE` — процесс ожидает события, но не может быть прерван
- `TASK_STOPPED` — процесс остановлен (например, сигналом SIGSTOP)
- `TASK_ZOMBIE` — процесс завершён, но его родитель ещё не получил информацию о завершении

#### Исполнение программы. Переменные среды исполнения

**Переменные среды** (переменные окружения) используются для хранения информации о текущем окружении процесса, такой как пути к исполняемым файлам, настройки локали, имя пользователя и другие параметры

##### Особенности
- Переменные среды хранятся в виде пар: `ключ=значение`
- Они доступны в программе через массив строк `envp[]` или с помощью стандартных функций (например, `getenv()` в C). Можно устанавливать/изменять переменные с помощью функций `setenv()` и `putenv()`
- Дочерние процессы наследуют переменные среды родительского процесса. При запуске программы через оболочку (shell) ей передаются переменные среды, доступные в текущей сессии

##### Классификация
1. **Системные переменные**
	- Это переменные окружения, которые определяются на уровне всей операционной системы и доступны всем пользователям и процессам. Они задают глобальные настройки и параметры, влияющие на поведение системы
	- Действуют глобально и наследуются всеми процессами
	- Изменения системных переменных требуют прав администратора
	- Настраиваются через `/etc/environment`
	- Примеры:
		- **`PATH`** — содержит список директорий, в которых система ищет исполняемые файлы
		- **`HOME`** — домашняя директория текущего пользователя
		- **`SHELL`** — путь к используемой оболочке (например, `/bin/bash`)
		- **`LANG`** — настройки локализации и языка
		- **`USER`** — имя текущего пользователя
2. **Пользовательские переменные**
	- Это переменные, которые задаются на уровне конкретного пользователя. Они позволяют настраивать окружение индивидуально для каждого пользователя, без влияния на других
	- Действуют только в сессии текущего пользователя
	- Настраиваются через `~/.bashrc`
	- Примеры:
		- **`PYTHONPATH`** — список директорий для поиска Python-модулей
		- **`EDITOR`** — предпочтительный текстовый редактор (например, `vim` или `nano`)
		- **`HISTSIZE`** — количество команд, хранимых в истории терминала
3. **Локальные переменные**
	- Это переменные, область видимости которых ограничена текущим процессом или скриптом, в котором они объявлены. Они не наследуются дочерними процессами и используются для временных задач
	- Видны только в текущем процессе (или текущем скрипте)
	- Не влияют на глобальные или системные настройки
	- Обычно используются в скриптах или в командной строке
	- Чтобы переменная стала доступной для дочерних процессов, её нужно экспортировать

##### Работа с переменными среды в Shell
1. Просмотр всех переменных среды:
    `env`
2. Просмотр значения конкретной переменной:
    `echo $PATH`
3. Установка переменной для текущей сессии:
    `export MY_VAR="Hello" echo $MY_VAR`
4. Удаление переменной:
    `unset MY_VAR`
5. Передача переменной в программу:
    `MY_VAR="Hello" ./my_program`

##### Пример использования envp
```c
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char **argv, char **envp)
{
    for (char **env = envp; *env != 0; env++)
    {
        char *thisEnv = *env;
        printf("%s\n", thisEnv);
    }
    return 0;
}
```

##### Пример использования environ
```c
#include <stdio.h>
extern char **environ;
int main(int argc, char **argv) {
    for (int i=0; environ[i]!=NULL; i++) {
        printf("%d: %s\n", i, envp[i]);
    }
    return 0;
}
```

##### Проблемы
- Программа не может изменить переменные окружения родительского процесса
- При добавлении/изменении переменной окружения программно, происходит копирование всего списка переменных в кучу (из за того, что изначально массив переменных окружения храняться в начале стека, его не получится увеличить)
- Потоконебезопасность

#### Пользователь. Идентификаторы пользователя

В Linux каждый пользователь и группа имеет уникальные идентификаторы, которые используются системой для управления доступом к файлам, процессам и другим ресурсам

##### Пользовательская учетная запись
- У каждого пользователя есть уникальная запись в системе, которая определяет его имя, идентификатор и другие атрибуты
- Информация о пользователях хранится в файле `/etc/passwd`

##### Типы пользователей
- **Суперпользователь (root)**:
	- Это пользователь с идентификатором `UID=0`
	- Обладает полными правами на выполнение любых операций в системе
- **Обычные пользователи**:
	- Пользователи с UID больше 0
	- Имеют ограниченные права, заданные системой и администратором
- **Системные пользователи**:
	- Это учетные записи, которые используются операционной системой и ее службами (демонами) для выполнения различных задач
	- Такие учетные записи предназначены не для обычных пользователей, а для запуска системных процессов и служб с минимальными привилегиями. (например, пользователь `www-data` для запуска веб-серверов, `nobody` для запуска сервисов без специальных прав)
	- У большинства системных пользователей оболочка (`shell`) в `/etc/passwd` заменена на `/usr/sbin/nologin` или `/bin/false`. Это предотвращает вход в систему через такие учетные записи

##### Идентификаторы пользователя и группы
1. **UID (User ID)**:
    - Уникальный идентификатор пользователя
    - Например, `UID=1000` обычно соответствует первому созданному пользователю на системе (после root)
2. **GID (Group ID)**:
    - Идентификатор основной группы пользователя
    - Для каждого пользователя автоматически создается группа с тем же названием и GID, что и UID

##### Группы в Linux
1. **Основная группа**:
    - У каждого пользователя есть основная группа, заданная в поле `GID` файла `/etc/passwd`
    - Основная группа автоматически назначается для вновь созданных файлов и процессов пользователя
2. **Дополнительные группы**:
    - Пользователь может быть членом других групп, которые позволяют ему выполнять определённые действия
    - Например, группа `sudo` позволяет выполнять команды с привилегиями root

##### Поля в /etc/passwd
Пример: `username:x:UID:GID:Full Name:/home/username:/bin/bash`
- `username` — имя пользователя
- `x` — ссылка на зашифрованный пароль (реально пароли хранятся в `/etc/shadow`)
- `UID` — уникальный идентификатор пользователя
- `GID` — идентификатор основной группы
- `Full Name` — комментарий (обычно имя пользователя)
- `/home/username` — домашний каталог
- `/bin/bash` — оболочка, используемая по умолчанию

##### Поля в /etc/group
Пример: `groupname:x:GID:user1,user2,user3`
- `groupname` — название группы
- `x` — не используется (исторический элемент)
- `GID` — идентификатор группы
- `user1,user2,user3` — список пользователей, входящих в группу

##### Команды
- `id` - посмотреть UID, GID и groups для текущего пользователя
- `id username` - то же самое для конкретного пользователя
- `cat /etc/passwd` - список пользователей
- `cat /etc/group` - список групп
- `usermod -u NEW_UID username usermod -g NEW_GID username` - изменение UID или GID пользователя
- `usermod -aG groupname username` -добавление пользователя в группу
- `adduser username` - создание пользователя
- `groupadd groupname` - создание группы

---

В Linux системах каждый процесс имеет **реальные**, **эффективные** и (в некоторых случаях) **сохраненные** идентификаторы пользователя и группы. Эти идентификаторы определяют права доступа и возможности процесса. Разберем каждое понятие подробно:

##### 1. Реальный идентификатор пользователя (Real User ID, RUID)
- **RUID** соответствует идентификатору пользователя, который запустил процесс
- Он используется для отслеживания "истинного владельца" процесса
- Пример: Если пользователь `user1` запускает программу, ее процесс будет иметь `RUID`, равный UID пользователя `user1`

##### 2. Эффективный идентификатор пользователя (Effective User ID, EUID)
- **EUID** определяет, от имени какого пользователя процесс выполняется
- Этот идентификатор используется системой для проверки прав доступа (например, к файлам, сетевым ресурсам и т. д.)
- Если программа имеет установленный бит `setuid` (Set User ID), то `EUID` процесса будет равен UID владельца файла программы, а не пользователю, который её запустил
    - Пример: Команда `passwd` (которая изменяет пароли) имеет владельцем `root` и установленный `setuid`. Когда пользователь запускает `passwd`, процесс получает `EUID=root`, что позволяет ему изменять файлы с паролями

##### 3. Реальный идентификатор группы (Real Group ID, RGID)
- **RGID** соответствует основной группе пользователя, который запустил процесс
- Аналогично `RUID`, используется для определения "истинной" группы владельца процесса

##### 4. Эффективный идентификатор группы (Effective Group ID, EGID)
- **EGID** определяет права доступа, связанные с группой, от имени которой процесс выполняется
- Если программа имеет установленный бит `setgid`, то `EGID` процесса будет равен GID владельца файла программы, а не группе пользователя, который её запустил

##### 5. Сохранённый идентификатор пользователя (Saved User ID, SUID)
- Сохраняет `EUID` процесса, чтобы процесс мог временно сбросить свои привилегии (вернуться к `RUID`) и затем восстановить их
- Используется для выполнения привилегированных операций без постоянного сохранения привилегий

##### 6. Сохранённый идентификатор группы (Saved Group ID, SGID)
- Аналогично `SUID`, но относится к групповым правам

**Sticky bit** в Linux — это специальный флаг, который применяется к каталогам. Он заставляет операционную систему ограничивать доступ к файлам внутри каталога таким образом, что только владельцы файлов могут их удалять или изменять, даже если другие пользователи имеют доступ к этому каталогу.

Обычно sticky bit используется в публичных каталогах, таких как `/tmp`, чтобы предотвратить удаление файлов другими пользователями, даже если они имеют права на запись в этот каталог.


![[Pasted image 20250126214011.png]]

#### Виртуальная память

Когда программа запускается в Linux (и в других операционных системах), не весь её код и данные помещаются в RAM (оперативную память) сразу. Это связано с тем, что программы могут быть очень большими, а физическая память ограничена. Вместо того чтобы загружать всю программу сразу, система использует несколько методов для эффективного управления памятью. Давайте разберемся, как это работает.

##### Основные механизмы работы с памятью при запуске программы:
1. **Виртуальная память**:
    - В Linux (и других современных операционных системах) используется виртуальная память. Это означает, что каждый процесс видит свою собственную виртуальную память, которая может быть гораздо больше, чем фактическая физическая память (RAM). Виртуальная память абстрагирует программу от физической памяти, позволяя использовать диск в качестве расширения оперативной памяти при необходимости
    - Виртуальная память разделяется на *страницы* (обычно размер страницы — 4 КБ). Процесс может использовать больше памяти, чем есть в RAM, и операционная система будет управлять тем, что хранить в оперативной памяти, а что можно «отправить» на диск
2. **Ленивая загрузка (Lazy loading)**:
    - Когда программа запускается, ядро загружает только те части её кода и данных, которые нужны в данный момент (например, начальную точку входа). Это называется *ленивой загрузкой*
    - Если программе нужно выполнить какую-то функцию или получить доступ к данным, которые ещё не загружены в память, операционная система загружает эти части программы из файла на диск в память. Это называется *страничная подкачка*
3. **Использование своп-файла (Swap space)**:
    - Если в системе не хватает оперативной памяти (RAM), Linux может перемещать часть данных из RAM в специальную область на диске, называемую *свопом*. Это позволяет системе продолжать работу, даже если физическая память заканчивается
    - Когда процессу снова требуется доступ к данным, которые были выгружены в своп, они снова загружаются в память
4. **Программы с разделяемыми библиотеками**:
    - Вместо того чтобы загружать все функции библиотеки в память для каждого процесса, система использует *разделяемые библиотеки* (например, `.so` файлы). Это означает, что библиотека загружается в память только один раз и может быть использована несколькими процессами одновременно
    - Когда программа запускается, лишь те части библиотеки, которые она использует, загружаются в память, и это происходит по мере необходимости
5. **Подсистема памяти в Linux**:
    - Когда вы запускаете программу, ядро Linux создаёт для неё *адресное пространство*. Это пространство делится на несколько частей:
        - *Текстовая секция*: код программы (сама программа)
        - *Данные*: переменные программы
        - *Стек (stack)*: память для локальных переменных и вызовов функций
        - *Куча (heap)*: память для динамически выделенных объектов (например, через `malloc`)
        - Эти секции загружаются в память постепенно и по мере необходимости

##### Как это работает в практике:
1. **Запуск программы**:
    - Когда вы запускаете программу, операционная система сначала загружает в память лишь необходимые части её кода и данных. Например, она загружает часть кода (начальную секцию), которая необходима для старта программы, и несколько основных библиотек, которые программа сразу же использует
2. **Страничная подкачка (paging)**:
    - Если программа обращается к данным или коду, который ещё не загружен в память, происходит *подкачка страницы*: необходимая часть кода или данных загружается в оперативную память. Если в памяти недостаточно места, одна из старых страниц может быть выгружена на диск в своп
3. **Использование свопа**:
    - Если физической памяти не хватает, Linux может перемещать части данных программы в своп — на жесткий диск. Это позволяет продолжать работу программы, но доступ к этим данным будет медленнее

#### Адресное пространство процесса

**Адресное пространство процесса** — это абстрактное (виртуальное) представление памяти, которое операционная система выделяет каждому процессу. Оно представляет собой набор виртуальных адресов, которые процесс может использовать для работы с данными, кодом и другими ресурсами

Каждый процесс имеет своё собственное адресное пространство, изолированное от других процессов. Это достигается благодаря механизму виртуальной памяти, который сопоставляет виртуальные адреса с физической памятью (RAM) или другими хранилищами (например, swap)

##### Структура адресного пространства
1. **Текстовый сегмент (Text Segment)**:
    - Содержит машинный код программы, загруженный из исполняемого файла.
    - Эта область является **read-only**, чтобы предотвратить изменения кода во время выполнения
2. **Сегмент данных (Data Segment)**:
    - Хранит глобальные и статические переменные программы.
    - Разделяется на две части:
        - **Инициализированные данные** (инициализированные переменные, например, `int x = 5`)
        - **Неинициализированные данные** или **BSS (Block Started by Symbol)** (переменные, которым не присвоено значение, например, `int y;`)
3. **Куча (Heap)**:
    - Используется для динамического выделения памяти во время выполнения программы
    - Управляется функциями, такими как `malloc`/`free` в C или `new`/`delete` в C++
4. **Сегмент стека (Stack)**:
    - Хранит локальные переменные, параметры функций и адрес возврата
    - Управляется автоматически при вызове и завершении функций
    - Стек растёт в сторону уменьшения адресов (вниз)
5. **Сегмент, связанный с mmap (Memory Mapped Segment)**:
    - Используется для отображения файлов или устройств в память
    - Например, библиотеки, загружаемые динамически (`.so` или `.dll`), попадают в эту область
6. **Резервированные области (Kernel Space)**:
    - Определённые адреса зарезервированы для взаимодействия с ядром (обычно недоступны процессу напрямую)

##### Системный вызов brk
Используется в Linux для изменения размера кучи. Он позволяет процессу расширять или сжимать область памяти, которую он использует для динамического выделения памяти

![[Pasted image 20250127011807.png]]
![[Pasted image 20250127012404.png]]
![[Pasted image 20250127013435.png]]

#### Отображение памяти (mmap)

##### Флаги
- **`p` - Частная память (Private)**: Это память, которая не синхронизируется с другими процессами. Когда процесс модифицирует такую память, изменения остаются локальными для этого процесса
- **`s` - Общая память (Shared)**: Это память, которая может быть использована несколькими процессами, и любые изменения в одном процессе могут быть видны другим процессам
- **`d` - Динамическая память (Dynamic)**: Обычно относится к памяти, выделяемой динамически во время выполнения программы (например, с помощью `malloc` или `new` в C/C++)
- **`a` - Анонимная память (Anonymous)**: Если используется `MAP_ANONYMOUS`, это означает, что память не связана с каким-либо файлом и используется для создания анонимных областей, таких как стек или куча
- **`f` - Привязка к конкретному адресу (Fixed)**: Флаг `MAP_FIXED` указывает, что память должна быть отображена в заранее указанном адресе, даже если там уже есть какие-то данные
- **`h` - Использование больших страниц (Huge pages)**: С помощью `MAP_HUGETLB` можно указать, что память должна быть выделена с использованием больших страниц (например, 2 МБ вместо стандартных 4 КБ)

#### Системные вызовы

##### Описание технологии

**Системные вызовы** (System Calls) — это механизм взаимодействия между пользовательским пространством (пользовательскими приложениями) и ядром операционной системы. Когда программа в пользовательском пространстве требует выполнения операции, которая требует привилегированного доступа (например, доступ к файлам, создание процессов, управление памятью и т.д.), она вызывает системный вызов. Системный вызов позволяет программе запросить ресурсы и функциональность, которые предоставляет операционная система.

Программирование с использованием системных вызовов позволяет пользователю взаимодействовать с операционной системой на низком уровне, предоставляя доступ к основным функциям ОС, таким как управление файлами, управление процессами, взаимодействие с сетями и так далее.

##### Проблемы, которые решает данная технология
- **Изоляция между пользователем и ядром**: Прямой доступ пользовательских программ к аппаратным ресурсам или чувствительным данным может быть опасным и привести к сбоям системы или уязвимостям. Системные вызовы решают эту проблему, обеспечивая безопасность и изоляцию
- **Контроль за доступом к ресурсам**: Многие ресурсы, такие как память, файлы и устройства, являются ограниченными и требуют правильного управления. Системные вызовы позволяют ОС контролировать доступ к этим ресурсам, предотвращая их неправильное использование
- **Доступ к оборудованию**: Хотим, чтобы только один ОС имела доступ к оборудованию, а пользователи работали через API
- **Управление процессами и многозадачностью**: Для создания и управления процессами, потоками, синхронизации и межпроцессного взаимодействия требуются специальные механизмы. Системные вызовы решают эту задачу
- **Портируемость приложений**: Системные вызовы позволяют абстрагировать работу программы от специфики аппаратного обеспечения, обеспечивая таким образом более широкую совместимость программ с различными архитектурами

##### Каким образом решаются указанные проблемы
- **Изоляция между пользователем и ядром**: Когда программа вызывает системный вызов, она переходит в привилегированный режим (режим ядра) через прерывание или исключение, что гарантирует безопасный доступ к ресурсам системы. Это предотвращает прямое вмешательство программ в работу ядра или доступ к критичным данным
- **Контроль за доступом к ресурсам**: С помощью системных вызовов операционная система может ограничивать доступ к памяти, файлам, устройствам и другим ресурсам. Например, вызов `open()` позволяет открывать файлы только с нужными правами доступа, а системный вызов `mmap()` может контролировать, как память отображается в процессе
- **Управление процессами и многозадачностью**: С помощью системных вызовов можно создавать, уничтожать и изменять характеристики процессов (например, с помощью `fork()`, `exec()`, `wait()`). Операционная система также использует системные вызовы для реализации синхронизации между процессами, межпроцессного взаимодействия и управления очередями
- **Портируемость приложений**: Системные вызовы представляют собой стандартизированный интерфейс, скрывающий детали работы с оборудованием. Например, программы, использующие POSIX-системные вызовы, могут работать на разных Unix-подобных операционных системах без необходимости переписывать код для каждой платформы

##### Особенности реализации
- **Прерывания и переключение контекста**: При вызове системного вызова происходит переключение контекста с пользовательского режима на режим ядра. Это может быть дорогостоящей операцией, так как она требует сохранения состояния процесса и перехода в другое привилегированное состояние
- **Системные вызовы и библиотеки**: Для удобства программирования многие системные вызовы оборачиваются в библиотечные функции (например, в библиотеке `glibc` для Linux). Это делает работу с системными вызовами более удобной для разработчиков, скрывая детали низкоуровневой реализации
- **Асинхронность**: Некоторые системные вызовы могут быть выполнены асинхронно, например, операции ввода-вывода (I/O). Это позволяет не блокировать процесс, пока выполняется операция, улучшая производительность и отзывчивость приложений
- **Блокировка**: Некоторые системные вызовы, такие как `read()` или `write()`, могут блокировать выполнение программы, если ресурсы временно недоступны (например, если данные ещё не загружены из файла или если устройство ввода/вывода занято)

##### Функции или системные вызовы, связанные с технологией
- **`fork()`** — создает новый процесс, копируя текущий
- **`exec()`** — заменяет текущий процесс новым, исполнив указанную программу
- **`wait()`** — позволяет процессу ожидать завершения дочернего процесса
- **`open()`** — открывает файл для чтения или записи
- **`read()`** — читает данные из файла или устройства
- **`write()`** — записывает данные в файл или устройство
- **`mmap()`** — отображает файл или анонимную память в адресное пространство процесса
- **`ioctl()`** — выполняет управление устройствами через их драйверы
- `brk()` / `sbrk()` — изменяет размер кучи
- **`kill()`** — отправляет сигнал процессу
- **`getpid()`** — возвращает идентификатор текущего процесса
- **`clone()`** — создает новый процесс или поток (более низкоуровневый, чем `fork`)

##### Какие новые проблемы появляются
- **Повышенные накладные расходы**: Системные вызовы могут быть затратными по времени, так как они требуют переключения контекста, что замедляет выполнение программы, особенно если вызовы часто выполняются или происходит множество переключений между режимами пользователя и ядра
- **Уязвимости безопасности**: Системные вызовы являются точками взаимодействия с ядром ОС, и при неправильном использовании (например, при недостаточной проверке входных данных) могут стать уязвимыми к атакам, таким как буферные переполнения или атаки на привилегии
- **Блокировки и дедлоки**: Системные вызовы, связанные с блокировками (например, операции ввода-вывода или ожидания процессов), могут привести к дедлокам, если процессы или потоки не правильно синхронизированы
- **Портируемость и различия в реализации**: Хотя системные вызовы предоставляют стандартизированный интерфейс, в разных операционных системах могут быть различия в реализации или в поддерживаемых вызовах, что иногда приводит к трудностям при переносе приложений между различными платформами
- **Ресурсозатратность**: Некоторые системные вызовы требуют значительных ресурсов системы, например, для создания нового процесса или выделения памяти. Это может привести к проблемам с производительностью при большом количестве таких вызовов

#### Понятие файла. Операции с файлами

##### Описание технологии
**Файл** — это абстракция, скрывающа за собой объекты, реализующие определённый интерфейс (реализуются некоторые функции, например read, write и т.д.). В частном случае это логическая единица хранения данных в операционной системе, которая представляет собой последовательность байтов, связанных с определенным именем и расположением на носителе данных. В операционной системе файлы могут хранить различные виды информации, включая текстовые, бинарные данные, изображения, аудио, видео и другие форматы данных.

Файлы являются абстракцией, которая позволяет пользователям и программам организовывать данные на диске или других устройствах хранения. Операционные системы предлагают интерфейсы для работы с файлами, включающие их создание, открытие, чтение, запись, закрытие и другие операции.

Имя файла - жёсткая ссылка. Файл существует, пока кто то на него ссылается

##### Проблемы, которые решает данная технология
- **Управление данными**: Файлы позволяют организовать и хранить данные на устройствах хранения, таких как жесткие диски, SSD, или другие носители информации, обеспечивая доступ к данным на основе имени файла или пути
- **Абстракция физического устройства**: Файлы абстрагируют работу с физическим устройством хранения, предоставляя пользователю и приложениям доступ к данным без необходимости заботиться о деталях аппаратной реализации
- **Организация данных**: Файлы позволяют эффективно организовывать данные для различных целей, таких как текстовые документы, бинарные файлы, базы данных и так далее
- **Персистентность данных**: Файлы обеспечивают долговременное хранение данных, позволяя сохранять информацию даже после завершения работы программы или перезагрузки системы
- **Управление доступом**: Операционные системы позволяют управлять доступом к файлам, обеспечивая различные права (чтение, запись, выполнение), а также обеспечивают безопасность и изоляцию данных

##### Каким образом решаются указанные проблемы
- **Управление данными**: Операционная система использует файловую систему для организации данных в виде файлов и каталогов, эффективно управляя метаданными (например, именами файлов, их размером, датой последнего изменения и правами доступа)
- **Абстракция физического устройства**: Когда приложение обращается к файлу, операционная система предоставляет доступ через абстракцию, скрывая детали хранения данных на различных физических носителях (например, дисках или SSD)
- **Организация данных**: Файловая система организует данные в иерархическую структуру каталогов и подкаталогов, позволяя пользователям и программам эффективно находить и управлять файлами
- **Персистентность данных**: Операционная система гарантирует сохранность данных в файлах при завершении работы программы или в случае сбоя, благодаря использованию буферов записи, журналирования и других механизмов
- **Управление доступом**: Операционная система использует механизмы управления доступом (права чтения, записи и выполнения) для контроля доступа к файлам, ограничивая возможности пользователей и программ для обеспечения безопасности

##### Особенности реализации
- **Файловая система**: Все файлы хранятся в файловой системе, которая управляет структурой данных на устройстве хранения. Примеры файловых систем: FAT, NTFS, ext4, APFS
- **Метаданные файла**: Каждый файл имеет метаданные, такие как имя, размер, дата последней модификации, права доступа (чтение, запись, выполнение), владельца файла, и местоположение на устройстве
- **Потоки ввода-вывода (I/O)**: Операции с файлами часто выполняются через потоки ввода-вывода, где данные читаются или записываются поэтапно
- **Буферизация**: Для повышения производительности при чтении и записи файлов операционные системы часто используют буферы, которые временно хранят данные в памяти, а затем записывают их на диск (или наоборот)
- **Права доступа**: Файлы могут иметь различные права доступа для разных пользователей. Эти права управляются через системные вызовы, такие как `chmod`, `chown`, и могут включать права на чтение, запись и выполнение
- **Синхронизация и блокировки**: Для обеспечения целостности данных и предотвращения конфликтов в многозадачных или многопроцессных системах могут использоваться блокировки файлов, чтобы избежать одновременного доступа к файлам разными процессами

##### Функции или системные вызовы, связанные с технологией
- **`open()`** — открывает файл для чтения, записи или других операций. Возвращает файловый дескриптор для дальнейших операций
- **`close()`** — закрывает файл, освобождая ресурс (файловый дескриптор)
- **`read()`** — читает данные из файла в память
- **`write()`** — записывает данные в файл
- **`lseek()`** — изменяет позицию в файле (для произвольного доступа)
- **`stat()`** — получает информацию о файле, такую как размер, права доступа и время последнего изменения
- **`unlink()`** — удаляет файл из файловой системы
- **`rename()`** — изменяет имя или расположение файла
- **`chmod()`** — изменяет права доступа к файлу
- **`chown()`** — изменяет владельца и группу файла
- **`mkdir()`** — создает новый каталог
- **`rmdir()`** — удаляет пустой каталог

##### Какие новые проблемы появляются
- **Проблемы с производительностью**: Операции с файлами, особенно на больших объемах данных или при частых обращениях, могут быть затратными по времени, особенно если файлы находятся на удаленных устройствах или сетевых хранилищах
- **Утечки файловых дескрипторов**: Неправильное управление открытыми файлами (например, отсутствие вызова `close()` после работы с файлом) может привести к утечке файловых дескрипторов, что исчерпывает ресурсы системы
- **Конкуренция за доступ**: В многозадачных или многопроцессных системах может возникнуть ситуация, когда несколько процессов пытаются одновременно читать или записывать в один и тот же файл. Это может привести к повреждению данных или конфликтам. Для решения этой проблемы используются блокировки или семафоры
- **Ошибки при работе с большими файлами**: Файлы очень большого размера (особенно на 32-битных системах) могут вызывать проблемы с обработкой из-за ограничений на размер файлов или сбоев в операциях чтения/записи
- **Безопасность и контроль доступа**: Неверно настроенные права доступа к файлам могут привести к утечке данных или несанкционированному доступу, что является серьезной угрозой для безопасности системы
 
#### Блокирующий и неблокирующий ввод-вывод. Мультиплексирование ввода-вывода

##### Блокирующий ввод-вывод
- **Описание:**
    - При блокирующем вводе-выводе вызов функции (`read`, `write`, `recv`, `send` и т.д.) приостанавливает выполнение программы до тех пор, пока операция не завершится. Например, программа будет ждать, пока данные не будут прочитаны из файла, получены по сети или записаны на диск
    - Это стандартное поведение ввода-вывода в большинстве случаев
- **Проблемы:**
    - Если операция ввода-вывода занимает много времени (например, из-за ожидания данных от устройства или сети), программа простаивает, не выполняя других задач
    - В многозадачных приложениях это может приводить к низкой производительности
- **Пример:**
    `int fd = open("file.txt", O_RDONLY); char buffer[100]; read(fd, buffer, 100);  // Заблокирует выполнение до завершения чтения`

##### Неблокирующий ввод-вывод
- **Описание:**
    - При неблокирующем вводе-выводе функция сразу возвращает управление, даже если операция не завершена. Например, если данные ещё не готовы для чтения, вызов `read` вернёт код ошибки (`-1`) с установкой `errno` в `EAGAIN` или `EWOULDBLOCK`
    - Программа может продолжать выполнение других задач, проверяя статус операции позже
- **Реализация:**
    - Для установки неблокирующего режима можно использовать флаг `O_NONBLOCK` при открытии файла/сокета или изменить режим с помощью системного вызова `fcntl`
- **Пример:**
    `int fd = open("file.txt", O_RDONLY | O_NONBLOCK); char buffer[100]; int bytes = read(fd, buffer, 100); if (bytes == -1 && errno == EAGAIN) {     // Данные пока не готовы }`
    

##### Мультиплексирование ввода-вывода
- **Описание:**
	- Мультиплексирование ввода-вывода позволяет обрабатывать ввод-вывод для нескольких файловых дескрипторов одновременно, не блокируя выполнение программы на одном дескрипторе.
	- Используется в ситуациях, когда нужно управлять несколькими источниками данных (сокетами, файлами, устройствами) в одном потоке выполнения.
- **Основные методы:**
	1. `select`
		- Мониторит множество файловых дескрипторов на наличие событий (например, готовность к чтению, записи или появления ошибок)
		- Ограничение: количество дескрипторов ограничено (обычно 1024 на процесс)
		- Пример:
		    `fd_set readfds; FD_ZERO(&readfds); FD_SET(fd1, &readfds); FD_SET(fd2, &readfds); select(max_fd + 1, &readfds, NULL, NULL, NULL); if (FD_ISSET(fd1, &readfds)) {     // fd1 готов к чтению }`
	2. `poll`
		- Подобен `select`, но не имеет ограничения на количество дескрипторов. Вместо битовой маски используется массив структур
		- Пример:
			`struct pollfd fds[2]; fds[0].fd = fd1; fds[0].events = POLLIN; fds[1].fd = fd2; fds[1].events = POLLIN; poll(fds, 2, -1); if (fds[0].revents & POLLIN) {     // fd1 готов к чтению }`
    3. `epoll`
	    - Более эффективная альтернатива `poll`, доступная в Linux
		- Позволяет отслеживать большое количество файловых дескрипторов с меньшими затратами ресурсов
		- Использует файловый дескриптор для управления множеством других дескрипторов
		- Пример:
		    `int epfd = epoll_create1(0); struct epoll_event event; event.events = EPOLLIN; event.data.fd = fd1; epoll_ctl(epfd, EPOLL_CTL_ADD, fd1, &event);  struct epoll_event events[10]; int nfds = epoll_wait(epfd, events, 10, -1); for (int i = 0; i < nfds; i++) {     if (events[i].data.fd == fd1) {         // fd1 готов к чтению     } }`

##### Сравнение подходов

| **Метод**              | **Блокирующий**                             | **Неблокирующий**                         | **Мультиплексирование**                       |
| ---------------------- | ------------------------------------------- | ----------------------------------------- | --------------------------------------------- |
| **Потоки**             | Один поток блокируется на одном дескрипторе | Один поток обслуживает несколько операций | Один поток обслуживает несколько дескрипторов |
| **Простота**           | Легко реализуется, интуитивен               | Сложнее из-за проверки готовности         | Умеренно сложный, но эффективен               |
| **Производительность** | Низкая для нескольких операций              | Высокая для однопоточных приложений       | Высокая при большом количестве дескрипторов   |

##### Какие задачи решаются?
- **Блокирующий:** Подходит для простых операций с одним источником данных
- **Неблокирующий:** Используется для улучшения производительности в однопоточных системах
- **Мультиплексирование:** Основной инструмент для высокопроизводительных серверов и систем с большим количеством подключений (например, сетевых приложений)

#### Файловые системы

**Файловая система** (FS) — это способ организации, хранения и управления данными на носителях информации (дисках, SSD и т.д.). Она предоставляет интерфейс для работы с файлами и обеспечивает их упорядочивание в виде структурированных объектов: файлов и каталогов

##### Основные задачи файловой системы
- Организация хранения данных в виде файлов и каталогов
- Предоставление интерфейса для работы с файлами (создание, удаление, чтение, запись)
- Управление свободным и занятым пространством на диске
- Обеспечение безопасности и контроля доступа
- Поддержка надежности данных (журналирование, резервирование)
- Эффективность доступа к данным (оптимизация операций чтения и записи)

##### Основные компоненты файловой системы
- **Файлы**: Единицы хранения данных
- **Каталоги**: Структуры для организации файлов в иерархическом порядке
- **Индексные структуры (inode):** Метаданные файлов, такие как права доступа, размер, указатели на блоки данных
- **Таблицы размещения файлов:** Хранение информации о свободных и занятых блоках на носителе
- **Кэш файловой системы:** Ускорение операций за счет хранения недавно использованных данных в RAM

##### Файловая система обычно состоит из следующих частей
1. **Boot Block:** Содержит загрузочную информацию
2. **Superblock:** Метаданные файловой системы (размеры, количество блоков, состояние)
3. **Inode Table:** Метаданные файлов (размеры, права, временные метки, указатели на данные). Cодержит все inode на диске, и каждый inode идентифицируется номером (inode number)
4. **Data Blocks:** Хранение фактического содержимого файлов
5. **Bitmap:** Таблица распределения блоков. Хранит информацию о том, какие блоки используются (заняты) и какие свободны
6. **Bitmap:** Таблица распределения inode. Аналогично таблице распределения блоков, но отвечает за учёт свободных и занятых inode
7. **Directories:** Каталоги хранятся как специальные файлы, где записаны связи между именами файлов и номерами inode
8.  **Journal:** Лог для восстановления после сбоев (в журналируемых файловых системах)

##### Операции с файловыми системами
- `mkfs` - создание файловой системы
	- `sudo mkfs.ext4 /dev/sdb1` - пример создания ФС на устройстве (содерживое устройства удалится и сформируются необходимые структуры)
	- `sudo mkfs.ext4 ./data` - пример создания ФС в файле
- `mount` - связывает файловую систему с определённой точкой в иерархии
	- `sudo mount /dev/sdb1 /mnt_mydisk` - пример монтирования
- `open`, `read`, `write`, `close` - чтение/запись
- `rsync`, `tar`, `cp` - резервное копирование
- `fsck` - для исправления ошибок файловой системы
- `df -h` - список смонтированных файловых систем и их точки монтирования.

##### Типы файловых систем
1. Журналируемые файловые системы:
	- Поддерживают журналирование операций для повышения надежности данных
	- Примеры: Ext3, Ext4, NTFS, XFS
2. Файловые системы без журналирования:
	- Простые и быстрые, но менее устойчивы к сбоям
	- Пример: Ext2
3. Файловые системы для сетевого доступа:
	- Разработаны для работы по сети
	- Примеры: NFS (Network File System), SMB/CIFS
4. Файловые системы для флеш-накопителей:
	- Оптимизированы для флеш-памяти с учётом её ограниченного ресурса записи
	- Примеры: exFAT, F2FS

##### Проблемы и их решения
1. Проблемы:
	- Потеря данных при сбоях
	- Ограничение на размер файлов/томов
	- Сложность управления большими объёмами данных
2. Решения:
	- Использование журналирования
	- Внедрение файловых систем с поддержкой моментальных снимков (Btrfs, ZFS)
	- Периодическое резервное копирование

**Блочное устройство** — это устройство в операционной системе, которое предоставляет доступ к данным на уровне блоков фиксированного размера (обычно 512 байт или 4 КБ). Такие устройства позволяют организовать хранение и чтение данных в произвольном порядке (random access), в отличие от символьных устройств, которые работают с потоком данных. Это могут быть как реальные устройства (HDD, SSD, DVD, USB...), так и виртуальные (RAM-диск, RAID-массивы - логическое блочное устройство, объединяющее несколько физических дисков)

В Linux блочные устройства представлены в виде специальных файлов, расположенных в каталоге `/dev`. Например:
- **`/dev/sda`** — жёсткий диск
- **`/dev/sdb1`** — первый раздел второго диска
- **`/dev/loop0`** — виртуальное блочное устройство (loopback)

**Loop device** (или loopback device) — это специальное блочное устройство в Linux, которое позволяет монтировать файл как будто это физический диск или раздел. Это абстракция, позволяющая представить файл как устройство

##### Как работает loop device
- Loop device "связывает" файл с виртуальным блочным устройством
- Операционная система взаимодействует с этим виртуальным устройством так, как будто это реальный диск
- Таким образом, содержимое файла можно считывать и записывать с помощью стандартных операций работы с блочными устройствами

##### Зачем нужен loop device
1. **Тестирование без физического диска:**
    - Позволяет создавать и тестировать файловые системы в файлах без записи на диск
2. **Работа с ISO-образами:**
    - Можно монтировать и просматривать содержимое ISO-образов
3. **Контейнеры и виртуализация:**
    - Используется для создания и работы с образами в Docker, LXC и других технологиях
4. **Резервные копии:**
    - Удобно для хранения и монтирования файловых систем из резервных копий

##### Пример системных файловых систем
1. **/proc** — виртуальная файловая система, отображающая информацию о процессах и различных параметрах системы
    - Пример: `/proc/cpuinfo`, `/proc/meminfo`, `/proc/[pid]/status`
2. **/sys** — ещё одна виртуальная файловая система, которая предоставляет информацию о различных устройствах, ядре и настройках системы
    - Пример: `/sys/class/net/eth0`, `/sys/devices/system/cpu/`, `/sys/block/sda`
3. **tmpfs** — временная файловая система, которая использует память (RAM) для хранения данных. Данные в `tmpfs` не сохраняются при перезагрузке
    - Пример: `/tmp`, `/dev/shm`
4. **procfs** — на самом деле это и есть сама файловая система **/proc**, которая предоставляет информацию о процессах и системных параметрах, как описано выше. Для каждого файла там реализована своя функция read
5. **cgroupfs** — виртуальная файловая система для работы с контрольными группами (cgroups), которые позволяют организовывать и управлять ресурсами, выделенными для процессов
    - Пример: `/sys/fs/cgroup/`
6. **devtmpfs** — файловая система, которая используется для динамического управления устройствами в `/dev`. Она монтируется во время загрузки для автоматического создания файлов устройст
    - Пример: `/dev/`, где находятся устройства, такие как `/dev/sda`, `/dev/tty0`

#### Межпроцессное взаимодействие. Pipe

**Pipe** — это абстракция, которая предоставляет один поток данных между двумя процессами. Один процесс записывает данные в начало канала, а другой процесс читает данные с конца канала. Pipe является *односторонним*: один процесс может только записывать в pipe, а другой — только читать из него. Для двустороннего общения используется два канала

##### Проблемы, которые решает данная технология
- **Межпроцессное взаимодействие (IPC)**: Pipe решает задачу передачи данных между процессами, позволяя процессам обмениваться данными без создания промежуточных файлов
- **Синхронизация данных**: Pipe обеспечивает синхронизацию между процессами, которые используют его для обмена информацией

##### Как решаются указанные проблемы
- Когда процесс записывает данные в pipe, данные находятся в буфере до тех пор, пока другой процесс не начнёт их читать. Если pipe переполнен (например, если процесс, читающий данные, не успевает за процессом записи), процесс записи может блокироваться
- Если процесс пытается читать данные из пустого pipe, он будет заблокирован, пока в pipe не появятся данные

##### Разновидности pipe
- **Неименованный pipe**: В основном, pipe создаются через системный вызов `pipe()`. Эти pipe не имеют имени, и их можно использовать только в рамках одного родительского процесса, поскольку они существуют только в памяти
- **Именованный pipe (FIFO)**: Это разновидность pipe, которая хранится в файловой системе, и её можно использовать для обмена данными между произвольными процессами. Именованные pipe создаются с помощью команды `mkfifo`. Они доступны в файловой системе как обычные файлы. Для записи в именоманный пайп надо просто открыть файл и сделать write, а для чтения - открыть файл и сделать read

##### Функции и системные вызовы, связанные с pipe
- `pipe(int pipefd[2])` — создает неименованный pipe. `pipefd[0]` — файловый дескриптор для чтения, `pipefd[1]` — для записи
- `mkfifo(const char *pathname, mode_t mode)` — создает именованный pipe (FIFO)
- `read(int fd, void *buf, size_t count)` — используется для чтения из pipe
- `write(int fd, const void *buf, size_t count)` — используется для записи в pipe
- `close(int fd)` — закрывает файловый дескриптор pipe
- `FILE *popen(const char *command, const char *mode)` - открывает файл для чтения вывода команды либо открывает файл для передачи данных команде. Команда запускается в новом процессе и общается с родителем через pipe в виде файла

##### Команды bash
- `echo "Hello, World!" | grep "Hello"` - простейший пример использования pipe в командной строке Linux
- `mkfifo /tmp/myfifo` - создаем именованный pipe
- `echo "Hello from shell" > /tmp/myfifo` - записываем данные в pipe
- `cat < /tmp/myfifo` - читаем данные из pipe

##### Символы в терминале
- **`>`** — перенаправляет вывод в файл (перезаписывает).
- **`>>`** — добавляет вывод в файл (не перезаписывает).
- **`<`** — перенаправляет ввод из файла.
- **`|`** — передает вывод одной команды как ввод другой.
- **`2>`** — перенаправляет стандартную ошибку в файл.
- **`&>`** — перенаправляет и вывод, и ошибки в файл.
- **`2>>`** — добавляет стандартные ошибки в файл.
- **`<<`** — позволяет передавать текстовый ввод непосредственно в команду через Here Document (многострочный текст)

##### Какие новые проблемы появляются
- **Блокировка процесса**: Если процесс пытается записать в pipe, но нет другого процесса для чтения данных (или pipe уже заполнен), процесс будет заблокирован
- **Размер буфера**: Размер pipe ограничен. Если pipe переполнен, запись будет блокировать процесс, пока в pipe не появится место
- **Односторонность**: Обычный pipe работает в одном направлении (или на запись, или на чтение). Для двустороннего общения нужно использовать два pipe

#### Межпроцессное взаимодействие. Разделяемая память

В Linux и других Unix-подобных системах для межпроцессного взаимодействия (IPC, Inter-Process Communication) через **разделяемую память** предоставляются функции и API. Разделяемая память позволяет нескольким процессам напрямую обмениваться данными, минуя промежуточные копирования. Это обеспечивает высокую производительность.

##### Системные вызовы и функции:
1. **`shmget`**  
    Создает или получает идентификатор сегмента разделяемой памяти
    `int shmget(key_t key, size_t size, int shmflg);`
    - `key`: уникальный ключ для идентификации сегмента (можно использовать `ftok` для генерации ключа)
    - `size`: размер сегмента памяти в байтах
    - `shmflg`: флаги (например, права доступа `0666` или флаг `IPC_CREAT` для создания сегмента)
    - Возвращает идентификатор сегмента (shmid) или `-1` в случае ошибки
2. **`shmat`**  
    Подключает сегмент разделяемой памяти к адресному пространству процесса
    `void *shmat(int shmid, const void *shmaddr, int shmflg);`
    - `shmid`: идентификатор сегмента памяти, полученный через `shmget`
    - `shmaddr`: адрес, по которому подключается память (обычно `NULL` — выбирается автоматически)
    - `shmflg`: флаги (например, `SHM_RDONLY` для доступа только на чтение)
    - Возвращает указатель на подключенный сегмент памяти или `(void *) -1` в случае ошибки
3. **`shmdt`**  
    Отключает сегмент разделяемой памяти от адресного пространства процесса
    `int shmdt(const void *shmaddr);`
    - `shmaddr`: адрес сегмента памяти, который нужно отключить (тот же, что возвращает `shmat`)
    - Возвращает `0` при успешном завершении или `-1` в случае ошибки
4. **`shmctl`**  
    Управляет сегментом разделяемой памяти (например, удаляет сегмент или изменяет его свойства)
    `int shmctl(int shmid, int cmd, struct shmid_ds *buf);`
    - `shmid`: идентификатор сегмента памяти
    - `cmd`: команда управления (например, `IPC_RMID` для удаления сегмента)
    - `buf`: указатель на структуру `shmid_ds` для получения или изменения информации о сегменте
    - Возвращает `0` при успешном завершении или `-1` в случае ошибки

##### Пример программы

###### Создание и запись в разделяемую память
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    FILE *fp;
    char path[1035];

    // Открываем команду "ls" для чтения
    fp = popen("ls -l", "r");
    if (fp == NULL) {
        perror("popen");
        exit(1);
    }

    // Читаем вывод команды строка за строкой
    while (fgets(path, sizeof(path), fp) != NULL) {
        printf("%s", path);
    }

    // Закрываем файл
    fclose(fp);
    return 0;
}
```

###### Чтение данных из разделяемой памяти
```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    FILE *fp;

    // Открываем команду "sort" для записи
    fp = popen("sort", "w");
    if (fp == NULL) {
        perror("popen");
        exit(1);
    }

    // Отправляем данные в команду "sort"
    fprintf(fp, "banana\napple\ncherry\n");
    fclose(fp);

    return 0;
}

```

##### shmget/shmat (System V Shared Memory)
- Это часть старого стандарта **System V IPC**, разработанного в 1980-х годах
- Используется для создания сегментов разделяемой памяти, которые могут использовать несколько процессов
- Управление сегментами памяти происходит через идентификатор (shmid), а привязка сегмента осуществляется через `shmat`
- Для взаимодействия между процессами с помощью этих вызовов **система хранит таблицу сегментов разделяемой памяти**, в которой содержатся метаданные, такие как права доступа, размер и владельцы
##### Особенности
- Предоставляет механизм управления памятью на уровне ядра (очистка, права доступа)
- Не требует файла на диске: память выделяется в системных ресурсах
- Позволяет нескольким процессам подключаться к одному сегменту памяти
- Взаимодействие контролируется через флаги (`IPC_CREAT`, права доступа, и т. д.)
- Данный механизм остался в стандарте для совместимости

##### mmap (Memory Mapping)
- Это более современный и гибкий механизм управления памятью
- Позволяет отображать файлы или анонимные области памяти в адресное пространство процесса
- Если `mmap` используется с флагом **`MAP_SHARED`**, несколько процессов могут работать с одной и той же областью памяти (например, через общий файл или анонимную память, созданную с `shm_open`)
##### Особенности:
- Универсальный инструмент: может отображать как файлы, так и выделенные области памяти
- Управление правами доступа происходит через флаги (`PROT_READ`, `PROT_WRITE`).
- Позволяет работать с файлами в качестве разделяемой памяти (например, через tmpfs)
- Более гибкий, но требует дополнительной настройки для создания сегментов, аналогичных `shmget`

#### Межпроцессное взаимодействие. Сокеты

**Сокеты** — это программный интерфейс, через который процессы могут отправлять/получать данные, используя системные вызовы

##### Типы сокетов
1. **Unix Domain Sockets (локальные сокеты)**:
	- Используются для взаимодействия между процессами на одной машине
	- Передача данных происходит через файловую систему (сокеты представлены как специальные файлы)
	- Быстрее, чем сетевые сокеты, так как не требуется сетевой стек
2. **TCP/UDP сокеты (сетевые сокеты)**:
	- TCP сокеты: обеспечивают надежную потоковую передачу данных
	- UDP сокеты: обеспечивают ненадежную, но более быструю передачу сообщений
	- Используются для связи между процессами на разных хостах
3. **Raw сокеты**:
	- Предоставляют доступ к низкоуровневым сетевым протоколам
	- Используются для реализации протоколов или работы с нестандартными пакетами

##### Особенности локальных сокетов
- Локальные сокеты передают данные через файловую систему (в пространстве имен Unix)
- Они используют адреса в виде путей файлов (например, `/tmp/socket`) вместо IP-адресов и портов
- Взаимодействие с локальными сокетами происходит через файловые дескрипторы

##### Пример локального взаимодействия через Unix сокет:

###### Сервер:
```c
#include <sys/socket.h>
#include <sys/un.h>
#include <stdio.h>
#include <unistd.h>

#define SOCKET_PATH "/tmp/unix_socket"

int main() {
    int server_fd = socket(AF_UNIX, SOCK_STREAM, 0);
    
    struct sockaddr_un addr;
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, SOCKET_PATH, sizeof(addr.sun_path) - 1);

    unlink(SOCKET_PATH); // Удаляем старый файл сокета
    bind(server_fd, (struct sockaddr*)&addr, sizeof(addr));
    listen(server_fd, 5);

    int client_fd = accept(server_fd, NULL, NULL);

    char buffer[256];
    read(client_fd, buffer, sizeof(buffer));
    printf("Received: %s\n", buffer);

    close(client_fd);
    close(server_fd);
    unlink(SOCKET_PATH); // Удаляем файл сокета после завершения
    return 0;
}
```

###### Клиент:
```c
#include <sys/socket.h>
#include <sys/un.h>
#include <stdio.h>
#include <unistd.h>

#define SOCKET_PATH "/tmp/unix_socket"

int main() {
    int client_fd = socket(AF_UNIX, SOCK_STREAM, 0);
    struct sockaddr_un addr;

    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, SOCKET_PATH, sizeof(addr.sun_path) - 1);

    connect(client_fd, (struct sockaddr*)&addr, sizeof(addr));

    const char *message = "Hello, server!";
    write(client_fd, message, strlen(message) + 1);

    close(client_fd);
    return 0;
}
```


#### Терминальный ввод-вывод
#### Сигналы
#### Способы выделения памяти в процессе
#### Выделение памяти в куче

--- 

#### Понятие потока. Системные и пользовательские потоки

#### Понятие потока. Создание потока в POSIX
#### Понятие потока. Завершение потока в POSIX
#### Механизмы ОС Linux для создания системных потоков
#### Механизмы ОС Linux для создания пользовательских потоков
#### Объекты синхронизации. Spin lock
#### Объекты синхронизации. Mutex
#### Объекты синхронизации. Condition variable
#### Объекты синхронизации. Read-Write lock
#### Объекты синхронизации. Semaphore
#### Объекты синхронизации. Barrier
#### Обработка сигналов в многопоточной программе
#### Мертвые и живые блокировки

##### Мёртвая блокировка (Deadlock)

**Мёртвая блокировка** возникает, когда два или более процессов (или потоков) находятся в состоянии взаимного ожидания, из-за чего ни один из них не может продолжить выполнение

###### Пример:
1. Поток A захватывает ресурс 1
2. Поток B захватывает ресурс 2
3. Поток A пытается получить ресурс 2, который уже занят потоком B
4. Поток B пытается получить ресурс 1, который уже занят потоком A

###### Условия блокировки:
1. **Взаимное блокирование:** Каждый процесс удерживает ресурс и ждёт другой
2. **Удержание и ожидание:** Процесс удерживает ресурсы, пока ждёт дополнительные
3. **Отсутствие вытеснения:** Ресурсы, уже захваченные процессом, не могут быть принудительно отобраны
4. **Циклическое ожидание:** Существует цепочка процессов, где каждый ждёт ресурс, удерживаемый другим

###### Как избежать мёртвой блокировки:
1. **Избегание взаимного ожидания:** Убедитесь, что процессы запрашивают все необходимые ресурсы разом
2. **Упорядоченное выделение ресурсов:** Вводите строгий порядок захвата ресурсов
3. **Тайм-аут ожидания:** Ограничьте время, в течение которого процесс может ждать ресурс
4. **Использование дедлок-детекторов:** Мониторинг и обнаружение мёртвых блокировок с последующим устранением (например, принудительное завершение одного из процессов)

###### Что делать в состоянии дедлока
1. **Забрать ресурс у процесса**: Полезно, если нет возможности изменить исходный код
2. **checkpoint restore in user space**: Откат к моменту до дедлока
3. **Убить процесс**: Можно убрать процесс, который держит ресурс

##### Живая блокировка (Livelock)

**Живая блокировка** возникает, когда два или более процесса продолжают изменять своё состояние в ответ на действия друг друга, но не делают полезной работы. Процессы как бы "двигаются", но не продвигаются к завершению

###### Пример:
1. Два потока A и B пытаются захватить один и тот же ресурс
2. Поток A освобождает ресурс, чтобы дать возможность потоку B его захватить
3. Поток B также освобождает ресурс, чтобы позволить потоку A продолжить
4. В результате оба потока постоянно уступают друг другу, но никто не захватывает ресурс

###### Как избежать живой блокировки:
1. **Введение случайности:** Используйте случайные задержки перед повторной попыткой захвата ресурса
2. **Назначение приоритетов:** Потоки с более высоким приоритетом получают доступ к ресурсам раньше
3. **Ограничение попыток:** Ограничьте число попыток захвата ресурса, после чего будет возвращена ошибка
4. **Чёткие протоколы взаимодействия:** Реализуйте алгоритмы синхронизации с учётом предотвращения взаимного уступания

#### Механизмы ОС Linux для создания объектов синхронизации
#### Задача потребитель-производитель

Задача **потребитель-производитель** (или **producer-consumer problem**) — это классическая задача синхронизации, часто встречающаяся в многозадачных операционных системах. Она описывает ситуацию, когда один или несколько **производителей** создают данные, а один или несколько **потребителей** их обрабатывают. Эти данные обычно хранятся в общем **буфере** или **очереди**, к которой и производители, и потребители имеют доступ.

Задача заключается в том, чтобы правильно синхронизировать действия производителей и потребителей, чтобы избежать гонок и ошибок доступа к данным, а также эффективно использовать ресурсы, такие как память и процессорное время.

##### Условия задачи
- **Производители** создают данные и помещают их в общий буфер (например, очередь или массив)
- **Потребители** извлекают данные из буфера для обработки
- Буфер имеет ограниченный размер, и важно обеспечить, чтобы:
    - Производители не переполнили буфер (не записали в него, если он полный)
    - Потребители не пытались извлечь данные из пустого буфера

##### Задача
1. **Производитель** должен ждать, если буфер полный
2. **Потребитель** должен ждать, если буфер пустой
3. Нужно синхронизировать доступ к буферу, чтобы избежать конфликтов при записи и чтении

##### Алгоритм решения
Задача решается с использованием *семафоров* или *мьютексов* для синхронизации
- Шаги:
	1. Производители: 
	    - Производитель генерирует данные и пытается записать их в буфер
	    - Если буфер полный, производитель блокируется (ждет)
	    - Когда данные записаны, потребители могут забрать их из буфера
	2. Потребители:
	    - Потребитель пытается извлечь данные из буфера
	    - Если буфер пустой, потребитель блокируется (ждет)
	    - После извлечения данных потребитель обрабатывает их
- В этом решении используются два семафора:
	1. **`empty`** — количество пустых слотов в буфере
	2. **`full`** — количество заполненных слотов в буфере
- Кроме того, используется мьютекс для синхронизации доступа к буферу

##### Пример решения
```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>

#define MAX_BUF_SIZE 10

// Буфер для хранения данных
int buffer[MAX_BUF_SIZE];
int in = 0;  // Индекс для записи
int out = 0; // Индекс для чтения

// Семафоры
sem_t empty;  // Количество пустых слотов
sem_t full;   // Количество заполненных слотов
pthread_mutex_t mutex;  // Мьютекс для защиты буфера

// Производитель
void* producer(void* arg) {
    int item;
    while (1) {
        item = rand() % 100;  // Генерация случайных данных
        sem_wait(&empty);  // Ожидание, если нет пустых слотов
        pthread_mutex_lock(&mutex);  // Блокируем доступ к буферу

        buffer[in] = item;  // Записываем данные в буфер
        printf("Produced: %d\n", item);
        in = (in + 1) % MAX_BUF_SIZE;  // Обновляем индекс записи

        pthread_mutex_unlock(&mutex);  // Разблокируем доступ к буферу
        sem_post(&full);  // Увеличиваем количество заполненных слотов

        sleep(1);  // Ждем немного перед следующим производством
    }
}

// Потребитель
void* consumer(void* arg) {
    int item;
    while (1) {
        sem_wait(&full);  // Ожидание, если буфер пуст
        pthread_mutex_lock(&mutex);  // Блокируем доступ к буферу

        item = buffer[out];  // Извлекаем данные из буфера
        printf("Consumed: %d\n", item);
        out = (out + 1) % MAX_BUF_SIZE;  // Обновляем индекс чтения

        pthread_mutex_unlock(&mutex);  // Разблокируем доступ к буферу
        sem_post(&empty);  // Увеличиваем количество пустых слотов

        sleep(1);  // Ждем немного перед следующим потреблением
    }
}

int main() {
    pthread_t prod, cons;
    
    // Инициализация семафоров и мьютекса
    sem_init(&empty, 0, MAX_BUF_SIZE);  // Буфер изначально пуст
    sem_init(&full, 0, 0);  // Нет заполненных слотов
    pthread_mutex_init(&mutex, NULL);

    // Создаем потоки производителя и потребителя
    pthread_create(&prod, NULL, producer, NULL);
    pthread_create(&cons, NULL, consumer, NULL);

    // Ждем завершения потоков
    pthread_join(prod, NULL);
    pthread_join(cons, NULL);

    // Очистка
    sem_destroy(&empty);
    sem_destroy(&full);
    pthread_mutex_destroy(&mutex);

    return 0;
}
```

##### Важные моменты
- Производитель и потребитель могут работать независимо друг от друга, синхронизируясь через семафоры
- Алгоритм предотвращает переполнение буфера и подождет, если буфер пуст
- Эффективность использования ресурсов достигается с помощью блокировки и ожидания только при необходимости (если буфер полон или пуст)

#### Задача об обедающих философах

Задача об обедающих философах — это классическая задача синхронизации в многозадачных системах, которая иллюстрирует проблему взаимодействия нескольких процессов, требующих доступа к ограниченным ресурсам (в данном случае — вилкам), и возникающие при этом проблемы синхронизации и мертвых блокировок (deadlock).

##### Условия задачи
Представьте себе 5 философов, сидящих за круглым столом. Каждый философ может либо думать, либо есть. Чтобы поесть, философу необходимо использовать две вилки, по одной с каждой стороны. Вилки лежат между философами, и каждый философ должен взять две вилки, чтобы поесть. После того как он поест, он должен положить вилки обратно на стол

##### Основная проблема
1. **Deadlock (Мертвые блокировки)**: Если каждый философ одновременно захватит вилку с одной стороны, они все будут блокировать друг друга, ожидая вторую вилку, и ни один не сможет начать есть
2. **Starvation (Голодание)**: Если философы берут вилки не поочередно, а с разной скоростью, то могут возникнуть ситуации, при которых некоторые философы будут постоянно голодать, не имея возможности поесть
3. **Конкуренция за ресурсы**: Вилок всего 5, и каждый философ должен получить доступ к двум вилкам, но при этом нужно избегать конфликтов между философами

##### Решение с использованием семафоров или мьютексов
Одно из решений — использование мьютексов или семафоров для синхронизации доступа к вилкам
1. **Мьютексы для вилок**: Мы можем создать 5 мьютексов, по одному для каждой вилки. Каждый философ должен захватить два мьютекса (один для каждой вилки), прежде чем начать есть
2. **Предотвращение мертвых блокировок**:
    - Один из подходов для предотвращения deadlock — это всегда захватывать вилки в одном и том же порядке (например, всегда сначала левую вилку, затем правую). Это помогает избежать ситуации, когда все философы захватят одну вилку и будут ожидать другую
    - Другой подход — ввести дополнительный мьютекс для контроля количества философов, которые могут есть одновременно (например, не более 4 философов, чтобы избежать захвата всех вилок сразу)

##### Алгоритм решения
1. Философи по очереди:
    - Пытаются взять левую вилку
    - Пытаются взять правую вилку
    - Если обе вилки доступны, философ начинает есть
    - По завершении еды философ кладет вилки обратно и начинает думать

##### Пример псевдокода
```c
mutex fork[5];  // 5 вилок, для каждой — свой мьютекс
mutex mutex;    // Общий мьютекс для синхронизации доступа к философам

void philosopher(int id) {
    while (true) {
        think(); // Философ думает
        mutex.lock(); // Забираем общий мьютекс
        fork[id].lock();  // Берем левую вилку
        fork[(id + 1) % 5].lock();  // Берем правую вилку
        mutex.unlock();  // Освобождаем общий мьютекс
        eat(); // Философ ест
        fork[id].unlock();  // Кладем левую вилку
        fork[(id + 1) % 5].unlock();  // Кладем правую вилку
    }
}
```

##### Решение с ограничением количества философов:
Для предотвращения deadlock можно использовать идею ограничить количество философов, которые могут одновременно пытаться поесть. Например, можно ограничить количество философов, которые могут захватить вилки, до 4-х, чтобы избежать ситуации, когда все философы захватят по одной вилке и будут блокировать друг друга

##### Вариант с приоритетами
Одним из решений проблемы голодания (starvation) может быть использование приоритетов или очередей для философов. Например, философы, которые долго не могли поесть, могут получить приоритет и брать вилки первыми, чтобы не оставаться голодными

#### Изоляция процессов

**Изоляция процессов** — это важная концепция в многозадачных операционных системах, которая позволяет каждому процессу работать в своем собственном, независимом пространстве, ограничивая доступ к ресурсам и данным других процессов. Это предотвращает их взаимное влияние и обеспечивает безопасность, стабильность и надежность системы

##### Описание технологии
Изоляция процессов в операционных системах обычно достигается через механизмы виртуализации, такие как:
- **Виртуальные адресные пространства**: каждый процесс имеет свое собственное виртуальное адресное пространство, которое не пересекается с адресным пространством других процессов
- **Системные вызовы и интерфейсы**: процессы взаимодействуют с операционной системой через абстракции, которые обеспечивают изоляцию, например, через системные вызовы
- **Контексты процессов**: каждый процесс имеет свой собственный контекст, включая регистры процессора, стек и другие данные, что помогает в изоляции

Основная цель изоляции — предотвратить одноразрушение работы одного процесса из-за ошибок или атак в другом процессе, а также обеспечить безопасность данных.

##### Проблемы, которые решает данная технология
- **Безопасность**: изоляция процессов предотвращает несанкционированный доступ одного процесса к памяти другого, что уменьшает риски, связанные с утечкой данных, подслушиванием или атаками
- **Стабильность системы**: ошибки в одном процессе (например, сбой в вычислениях или неправильный доступ к памяти) не должны приводить к сбоям в других процессах или в системе в целом
- **Конфиденциальность**: процессы не могут напрямую обмениваться данными без явного механизма связи (например, через каналы IPC — межпроцессное взаимодействие), что позволяет поддерживать конфиденциальность
- **Избежание коллизий**: изоляция предотвращает случайное или злонамеренное вмешательство одного процесса в работу другого, например, изменяя файлы или общие переменные

##### Как решаются указанные проблемы
- **Виртуальная память**: используется для изоляции адресных пространств процессов. Каждый процесс видит свою собственную виртуальную память, которая отображается на физическую память с помощью механизмов управления памятью (например, с помощью таблиц страниц).
    - Это позволяет каждому процессу работать с собственным набором данных и не беспокоиться о данных других процессов
- **Системные вызовы**: изоляция также поддерживается через доступ к ресурсам системы только через безопасные системные вызовы. Процесс не может напрямую манипулировать аппаратными ресурсами или памятью
- **Контексты выполнения**: операционная система сохраняет контекст каждого процесса при его приостановке и восстанавливает его при возобновлении работы, гарантируя, что данные других процессов не будут перезаписаны

##### Особенности реализации
- **Аппаратная поддержка**: изоляция процессов часто требует поддержки со стороны аппаратного обеспечения. Современные процессоры, например, поддерживают защиту памяти на уровне аппаратуры, чтобы предотвращать доступ одного процесса к памяти другого
- **Механизм защиты памяти**: с помощью технологии виртуальной памяти операционные системы могут защитить память от несанкционированного доступа. Если процесс пытается обратиться к памяти, которая не была ему выделена, возникает ошибка сегментации (segfault)
- **Изоляция через контейнеры и виртуализацию**:
    - Виртуальные машины (VM) и контейнеры (например, Docker) предлагают дополнительные уровни изоляции, позволяя запускать процессы в отдельных "контейнерах", каждый из которых работает в своем изолированном окружении. Виртуальные машины используют гипервизоры для полного изолирования, в то время как контейнеры изолируют только определенные ресурсы

##### Функции или системные вызовы, связанные с технологией
- **fork()** и **exec()**: эти системные вызовы создают новые процессы, что позволяет обеспечить изоляцию между родительским и дочерним процессами. После вызова `fork()` новый процесс получает копию памяти родительского процесса, но затем оба процесса начинают работать независимо
- **mmap()**: позволяет процессам выделять и маппировать память в виртуальном пространстве, что помогает в управлении памятью и изоляции
- **brk()**: используется для выделения памяти в куче, что также может быть частью механизма изоляции данных процессов
- **ptrace()**: используется для отслеживания процессов, но при этом он может быть использован только в том случае, если операционная система предоставляет такую возможность, что тоже связано с изоляцией процессов для обеспечения безопасности
- **chroot()**: позволяет изменять корневую директорию для процесса, что создает эффект изоляции, в том числе изоляцию файловой системы

##### Какие новые проблемы появляются
- **Накладные расходы на изоляцию**: изоляция требует дополнительных ресурсов и времени, особенно если используется виртуализация или контейнеризация. Это может повлиять на производительность
- **Проблемы с взаимодействием между процессами**: иногда требуется обмениваться данными между процессами. Для этого используются механизмы межпроцессного взаимодействия (IPC), такие как каналы, сокеты, очереди сообщений. Однако, неправильная настройка или неправильное использование этих механизмов может привести к сбоям или уязвимостям
- **Конфигурация изоляции**: в некоторых случаях слишком строгая изоляция может привести к затруднениям в разработке, если процессы должны взаимодействовать друг с другом. Это требует хорошей настройки и грамотного проектирования интерфейсов между процессами
