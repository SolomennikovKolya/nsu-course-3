
### Полезности
- [Медия](https://www.nsumedia.ru/main_potok/third_course/fifth_semester/systems)
- [Задания](file:///C:/Users/%D0%9F%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C/Downloads/Telegram%20Desktop/OS.Semester-2.Tasks.pdf)
- [Хабр про POSIX](https://habr.com/ru/articles/326138/)
- [Критерии оценок](file:///C:/Users/%D0%9F%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C/Downloads/Telegram%20Desktop/BOS.FinalAssessmentCriteria.pdf)
- [Старые лекции в вк](https://vk.com/video/@nsu_fit_os/all)

### Лабы
- [x] 1.1
- [x] 1.2
- [x] 1.3
- [x] 1.4
- [x] 1.5
- [x] 1.6
- [x] 1.7
- [x] 2.1
- [x] 2.2
- [x] 2.3
- [x] 2.4
- [ ] 3

## Старые темы

### Data segment

**Data segment** (секция данных):
1. *Initialized Data Segment* (Инициализированная секция данных) - инициализированные глобальные и статические переменные
2. *Block Started by Symbol* (BSS, Неинициализированная секция данных) - неинициализированные глобальные и статические переменные
	- При запуске программы они автоматически инициализируются нулями)
	- Всегда остаются в этом сегменте даже при изменении
	- В исполняемом файле они не занимают места

| Локальные переменные | Локальные статические переменные | Локальные константные переменные | Глобальные переменные |
| -------------------- | -------------------------------- | -------------------------------- | --------------------- |
| стек                 | Сегмент данных                   | Стек                             | Сегмент данных        |

### Прерывания 

**Прерывания** — это аппаратные события, которые сигнализируют процессору о необходимости выполнения определённых действий. Когда происходит прерывание, процессор приостанавливает текущий процесс (или поток) и переключается на обработку прерывания

##### Виды прерываний:
- *Аппаратные прерывания*: Генерируются аппаратными устройствами (например, клавиатура, сеть, таймер). Например, нажатие клавиши или приход сетевого пакета вызывает аппаратное прерывание
- *Программные прерывания*: Вызываются программно с помощью специальных инструкций. Например, системные вызовы работают через программные прерывания
- *Таймерные прерывания*: Генерируются встроенным в процессор таймером для переключения задач в многозадачной среде

##### Что происходит при прерывании:
1. Прерывание возникает
2. Процессор сохраняет контекст текущей задачи
3. Управление передаётся обработчику прерываний (Interrupt Service Routine, ISR)
4. После завершения ISR выполнение программы продолжается с того места, где было приостановлено

### Сигналы

[Сигналы](https://ru.manpages.org/signal/7) — это механизм, с помощью которого процессы могут асинхронно общаться друг с другом и с ядром операционной системы. Сигналы позволяют ОС или одному процессу уведомлять другой процесс о наступлении события, требующего немедленной реакции. Это очень гибкий и мощный инструмент для управления и обработки событий, но их асинхронная природа может быть сложной для корректной обработки. Сигналы идентифицируются по числовым кодам

#### Виды сигналов
- **Ненадёжные сигналы** (Unreliable signals):
    - Это старая модель сигналов. Она остаётся в новых версиях Linux для обратной совместимости
    - Ненадёжные сигналы могут теряться, если тот же сигнал отправляется процессу несколько раз до того, как процесс успел его обработать. В таком случае обработается только один из поступивших сигналов
    - Ненадёжные сигналы также не гарантируют, что сигнал не будет потерян при переходе между процессами. То есть, когда происходит форк (создание нового процесса), сигналы, отправленные родительскому процессу, могут не передаться новому дочернему процессу
- **Надёжные сигналы POSIX** (Reliable signals):
    - POSIX-сигналы стали стандартом для надежной обработки сигналов
    - Надёжные сигналы поддерживают очереди. Если несколько сигналов одного типа отправляются процессу, они будут поставлены в очередь и обработаны последовательно. Система гарантирует, что ни один из этих сигналов не будет потерян. Единственное, что если очередь достигнил лимит размера `RLIMIT_SIGPENDING`, то отправка сигнала вызовет ошибку
    - Надёжные сигналы можно маскировать (временно блокировать) с помощью `sigprocmask` и `pthread_sigmask`. Заблокированные (замаскированные) сигналы откладываются и будут обработаны, когда маска блокировки будет снята. Каждый процесс имеет свою сигнальныю маску
- **Сигналы реального времени** (Real-time signals):
    - Сигналы реального времени являются подмножеством надёжных сигналов и были добавлены в POSIX, чтобы предоставить возможности для работы с асинхронными событиями в режиме реального времени
	- Поддерживается приоритетность: у сигналов реального времени доставляются в порядке приоритета (их номера). Более низкие номера сигналов доставляются раньше более высоких номеров
	- Вместе с сигналом можно передать дополнительные данные с помощью `sigqueue()`

#### Примеры сигналов
- Ненадёжные сигналы:
	- `SIGINT` - прерывание процесса
	- `SIGTERM` - стандартный сигнал завершения процесса
	- `SIGKILL` - принудительное завершение процесса (нельзя заблокировать)
	- `SIGSEGV` - сегментационная ошибка
	- `SIGSTOP` - приостановка процесса (не может быть перехвачен или игнорирован)
	- `SIGCONT` - возобновление процесса после SIGSTOP
- Надёжные сигналы:
	- `SIGUSR1` и `SIGUSR2` — пользовательские сигналы, которые можно настроить для любой задачи.
	- `SIGCHLD` — отправляется родительскому процессу, когда один из его дочерних процессов завершается или переходит в состояние ожидания.
- Сигналы реального времени:
	- `SIGRTMIN`, `SIGRTMIN + 1`, `SIGRTMIN + 2`, ..., `SIGRTMAX` - действием по умолчанию для необработанных сигналов реального времени является завершение процесса.

#### Отправка сигналов
- `CTRL+C` - отправка SIGINT
- `CTRL+Z` - отправка SIGSTP
- `kill -SIGTERM <pid>` - отправка сигнала командой (есть и другие команды)
- Системные вызовы в си:
	- `kill` - посылает сигнал указанному процессу, всем членам указанной группы процессов или всем процессам в системе.
	- `killpg` - посылает сигнал всем членам указанной группы процессов.
	- `raise` - посылает сигнал вызвавшему потоку.
	- `pthread_kill` - посылает сигнал указанной нити POSIX в том же процессе, что и вызывающий.
	- `tgkill` - посылает сигнал указанной нити в указанном процессе
	- `sigqueue` - посылает сигнал реального времени указанному процессу с сопроводительными данными.
- Сигналы от ядра (ядро может отправить сигналы процессу при определённых событиях)

#### Обработка сигналов
1. Каждый сигнал имеет текущий **обработчик**, который определяет, что будет делать процесс при поступлении сигнала.
2. Каждый не пользовательских сигнал имеет **обработчик по умолчанию**, который задаёт стандартное действие для сигнала.
3. Процесс может:
	- Игнорировать сигнал: просто не реагировать на него.
	- Использовать обработчик по умолчанию.
	- Определить собственный обработчик с помощью `sigaction` или `signal`.

#### Особенности
- Сигналы в UNIX/Linux работают на уровне процессов, а не на уровне потоков. То есть `signal(<SIG>, <signal_handler>)` установит обработчик сигнала для всего процесса.
- Когда сигнал отправляется процессу, любой из потоков может быть выбран системой для обработки сигнала, если он не заблокировал этот сигнал.
- В POSIX-системах нельзя установить отдельные обработчики для каждого потока одного процесса.
- Для отправки сигнала конкретному потоку используют `pthread_kill(<thread>, <SIG>)`

| Сигналы                                                                 | Прерывания                                                                                       |
| ----------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
| Применяются к процессам в пользовательском пространстве.                | Работают на уровне процессора и устройства.                                                      |
| Отправляются ядром или процессами.                                      | Возникают в ответ на аппаратные или программные события.                                         |
| Процесс может определить обработчики сигналов.                          | Прерывания обрабатываются операционной системой через ISR.                                       |
| Используются для межпроцессного взаимодействия и управления процессами. | Используются для взаимодействия процессора с устройствами и системой.                            |
| Могут быть блокированы или обработаны (кроме SIGKILL, SIGSTOP).         | Прерывания нельзя блокировать на уровне программы, но их можно маскировать на уровне процессора. |

### Clone

#### Параметры clone:
1. Указатель на функцию (`fn`):
    - Указатель на функцию, которая будет выполнена в новом потоке.
2. Указатель на стек (`child_stack`):
    - Указатель на область памяти, которая будет использоваться как стек для нового потока. Если этот параметр равен `NULL`, стек будет выделен автоматически.
3. Флаги (`flags`):
    - Эти флаги определяют, какие ресурсы будут разделяться между родительским и дочерним потоками. Например:
        - `CLONE_VM`: общий адресное пространство памяти.
        - `CLONE_FS`: общий файловый системный контекст.
        - `CLONE_FILES`: общий набор открытых файлов.
        - `CLONE_SIGHAND`: общий обработчик сигналов.
        - `CLONE_THREAD`: определяет, что дочерний поток является частью того же процесса (потока).
        - `CLONE_PARENT_SETTID`, `CLONE_CHILD_CLEARTID` и другие флаги для управления потоками.
        - `CLONE_SYSVSEM` - разделение системных семафор SysV с родительским процессом
4. Указатель на идентификатор потока (`ptid`):
    - Указатель на переменную, которая будет содержать идентификатор потока, создаваемого функцией `clone`.
5. Указатель на идентификатор потока родителя (`tid`):
    - Указатель на переменную, в которую будет записан идентификатор потока родителя (если используется `CLONE_CHILD_SETTID`).
6. Сигнал завершения (`exit_signal`):
    - Идентификатор сигнала, который будет отправлен родительскому процессу при завершении дочернего потока (например, `SIGCHLD`).
7. Дополнительные параметры:
    - В зависимости от реализации `clone` могут быть и другие параметры, например, указатели на дополнительные структуры для передачи специфических данных.

#### Возвращает:
- TID нового потока
- -1 при ошибке

### Файловые дескрипторы

**Файловые дескрипторы** — это целые числа, которые операционная система использует для идентификации открытых файлов (и других потоков ввода/вывода) в рамках процесса. Они служат абстракцией, позволяющей программам взаимодействовать с файлами, сокетами, терминалами и другими ресурсами ввода/вывода.

#### Основные характеристики файловых дескрипторов:
1. Уникальность внутри процесса: каждый дескриптор уникален для текущего процесса, но может быть одинаковым в разных процессах. Каждый процесс имеет свою таблицу файловых дескрипторов, которая хранит ссылки на открытые ресурсы. Одинаковые числа в таблицах разных процессов могут указывать на разные ресурсы
2. Автоматическое назначение: дескрипторы выдаются операционной системой при открытии файлов или других ресурсов.
3. Переиспользование: если дескриптор закрыт (например, с помощью `close()`), он может быть назначен для нового ресурса.

#### Стандартные файловые дескрипторы:
При запуске процесса операционная система автоматически открывает три стандартных файловых дескриптора:
1. `stdin` (0) — стандартный поток ввода (обычно клавиатура).
2. `stdout` (1) — стандартный поток вывода (обычно консоль).
3. `stderr` (2) — стандартный поток ошибок (обычно консоль).

#### Дескриптор может указывать на любое устройство ввода/вывода:
- Файлы (обычные файлы, сокеты, FIFO и т. д.).
- Терминалы (например, консоль).
- Сетевые соединения (сокеты).
- Анонимные каналы (например, через `pipe()`).
- Устройства (например, `/dev/null`).

#### Таблица файловых дескрипторов
В ядре каждой программе (процессу) выделяется **таблица файловых дескрипторов**. Эта таблица представляет собой массив, где:
- Индексы массива — это числа, используемые в коде как файловые дескрипторы (например, 0, 1, 2).
- Значения массива — это ссылки на открытые файлы или другие ресурсы ввода-вывода (например, устройства, сокеты). А именно это указатели на структуры данных, хранящие метаинформацию о файле (сокете или др.)
Таблица имеет фиксированный размер, но его можно увеличить с помощью системных вызовов, например `setrlimit` или `fcntl`.

#### Как определяется дискриптор открыт или нет
При закрытии дескриптора соответствующая запись в таблице дескрипторов процесса становится невалидной. Она перестаёт ссылаться на запись в таблице открытых файлов ядра. Операции с таким дескриптором приводят к ошибке (`EBADF`: Bad File Descriptor)

## Работа с потоками

### Oсновы POSIX threads

##### Основные аспекты:
- Базовая единица загрузки ЦПУ - поток
- У всех исполняемых процессов есть как минимум один поток исполнения. Некоторые процессы этим и ограничиваются
- Ядро ОС может создать новый поток на порядок быстрее, чем новый процесс
- Потоки могут быть созданы не только в режиме ядра, но и в режиме пользователя
- Пользовательские потоки по разному отображаются на потоки в режиме ядра. Всего существует три модели, из которых 1:1 является наиболее часто используемой
- В каждом потоке есть своё errno (чтобы не было конфликтов)

| Потоки делят память:                 | Copy On Write:                       |
| ------------------------------------ | ------------------------------------ |
| ![[Pasted image 20240926095813.png]] | ![[Pasted image 20240926100353.png]] |

| N:1                                  | 1:1                                  | M:N                                  |
| ------------------------------------ | ------------------------------------ | ------------------------------------ |
| ![[Pasted image 20240926104431.png]] | ![[Pasted image 20240926104341.png]] | ![[Pasted image 20240926104350.png]] |

##### Другие библиотекии
Существуют и другие библиотеки для работы с потоками, и они не обязательно основываются на стандарте POSIX.
Примеры:
 - C++ Standard Library (std::thread)
 - OpenMP: OpenMP
 - Boost.Thread: Boost
 - Intel Threading Building Blocks (TBB)
 - И другие

### Команды

#### Команды
- `gcc -pthread -o <output_file> <source_file>.c` - компиляции
	- Флаг -pthread при компиляции добавляет директивы компилятору, обеспечивающие поддержку многопоточности (например, адаптирует компилятор для потокобезопасного кода)
    - Флаг -pthread при компоновке (линковке) включает подключение динамической библиотеки libpthread.so, которая содержит определения и реализации функций pthread (таких как pthread_create, pthread_join и др)
- `gcc -lpthread -o <output_file> <source_file>.c` - тоже компиляций
	- Флаг -lpthread просто добавляет библиотеку libpthread.so, но не устанавливает флаги для компиляции и линковки, поэтому флаг -pthread предпочтительнее
- `./main.out` - запуск (так же как и обычное приложение)
- `strace ./main.out` - трассировка системных вызовов программы
- `strace -c ./main.out` - посмотреть суммарное количество разных системных вызовов
- `strace -o output.txt ./main.out` - перенаправление вывода strace в файл
- `valgrind --tool=memcheck ./main.out` - проверка утечек памяти
- `valgrind --tool=helgrind ./main.out` - для анализа конкурентного доступа к памяти

#### Замечание
Библиотека POSIX threads не включена по умолчанию в стандартную библиотеку C, так как libc определяет только базовые возможности, общие для всех платформ, в то время как pthread разработан в соответствии со стандартом POSIX и не является кросс-платформенным

### Основные функции pthread

1. `pthread_create` - создание нового поток
	- `int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)`
    - `thread` - указатель на идентификатор созданного потока (имеет тип pthread_t)
    - `attr` - атрибуты потока (если указать NULL, используются атрибуты по умолчанию)
    - `start_routine` - функция, которую должен выполнить поток
    - `arg` - аргумент, который передаётся в функцию потока

2. `pthread_exit` - явное завершение потока
	- `void pthread_exit(void *retval)`
	- `retval` - возвращаемое значение (аналог return)
	- Если программа завершает работу с помощью return, то весь процесс завершается, поэтому pthread_exit важен, если не надо закрывать все потоки в процессе

3. `pthread_join` - ожидание завершения потока
	- `int pthread_join (pthread_t THREAD_ID, void ** DATA)`
	- `THREAD_ID` - идентификатор ожидаемого потока
	- `DATA` - значение, которое вернул ожидаемый поток
	- Несколько потоков не могут ждать завершения одного. Если они пытаются выполнить это, один поток завершается успешно, а все остальные — с ошибкой ESRCH
	- В каком-то смысле pthread_join похожа на вызов waitpid, ожидающую завершения исполнения процесса, но с некоторыми отличиями. Во-первых, все потоки одноранговые, среди них отсутствует иерархический порядок, в то время как процессы образуют дерево и подчинены иерархии родитель — потомок

4. `pthread_cancel` - досрочное завершение другого потока
	- `int pthread_cancel(pthread_t THREAD_ID)`
	- Поток не только может самостоятельно выбрать момент завершения в ответ на вызов pthread_cancel, но и вовсе его игнорировать, поэтому это больше похоже на запрос на выполнение досрочного завершения потока

5. `pthread_testcancel` - точка потенциального завершения потока
	- `void pthread_testcancel(void)`
	- Проверяет, были ли отправлены запросы на отмену текущего потока (pthread_cancel)
	- Если оказывается, что текущие поток был отменен, то он завершается

6. `pthread_detach` — переводит поток в отсоединённое состояние (detached state). Когда поток находится в таком состоянии, его завершение не нужно отслеживать с помощью pthread_join(), и система автоматически освобождает все ресурсы, связанные с ним, когда он завершает выполнение
	- `int pthread_detach(pthread_t thread)`
	- `thread` - идентификатор потока, который вы хотите отсоединить

7. `pthread_self` — возвращает идентификатор текущего потока
	- `pthread_t pthread_self(void);`

8. `pthread_equal` - сравнивает два идентификатора потоков и возвращает ненулевое значение (истина), если они равны, и 0 (ложь), если не равны
	- `int pthread_equal(pthread_t t1, pthread_t t2)`
	- Для pthread_t нельзя просто использовать == так как это pthread_t - не обязательно число (это может быть структура или другой тип, в зависимости реализации библиотеки в различных системах)


### Системные вызовы pthreads

Потоки в Linux управляются через механизм **kernel threads** (потоков ядра) и используют такие ключевые системные вызовы, как `clone()`, `futex()`, `sched_yield()`, и другие.

1. Создание потока: `pthread_create()` неявно вызывает `clone()`, который принимает флаги, которые определяют, какие ресурсы будут разделяться между потоком и родительским процессом. В результате, новый поток получает доступ к тому же адресному пространству, файловым дескрипторам, таблице сигналов и другим ресурсам, что и основной процесс.
	- `int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...);`

2. Для синхронизации потоков используется механизм системных вызовов futex (Fast Userspace Mutex). `futex()` — это низкоуровневый примитив синхронизации, который работает как гибридная схема: сначала пытается выполнить синхронизацию в пользовательском пространстве без вмешательства ядра, и только при необходимости (например, в случае конфликта) вызывает системный вызов. 
   Основной принцип работы `futex()`:
    - В большинстве случаев операции блокировки и разблокировки происходят в пользовательском пространстве без перехода в ядро.
    - Если поток блокируется на ожидании ресурса (например, мьютекс занят), вызывается системный вызов `futex()` для перевода потока в спящий режим до тех пор, пока ресурс не станет доступен.
    - `int futex(int *uaddr, int futex_op, int val, const struct timespec *timeout, int *uaddr2, int val3);`

3. Управление потоками:
    - Планирование (scheduling): потоки планируются и управляются с помощью планировщика ядра, который контролирует их выполнение. POSIX Threads в основном полагается на системные вызовы, такие как `sched_yield()` для добровольного уступления процессорного времени другим потокам. 
    - Вызов `sched_yield()`:
        `int sched_yield(void);` - переводит текущий поток в состояние ожидания, позволяя другим потокам выполнять свою работу.
    - Завершение потока: когда поток завершается (например, через `pthread_exit()`), ядро освобождает ресурсы, связанные с этим потоком. Обычно это делается с помощью системного вызова `exit()`, если это последний поток процесса, либо с помощью сигнала ядра, который переводит поток в состояние "зомби" до полной его очистки.
 
4.  Механизм планировщика ядра: Потоки в Linux обрабатываются планировщиком ядра, который распределяет процессорное время между потоками в соответствии с их приоритетами и политиками планирования. Это может быть политика:
    - SCHED_OTHER — обычная политика для обычных задач (по умолчанию).
    - SCHED_FIFO — для задач реального времени (FIFO).
    - SCHED_RR — задачи реального времени с круговым циклом (round-robin).
    - Планировщик ядра решает, какой поток будет запущен на CPU в данный момент на основании этих политик и других факторов, таких как время выполнения и приоритеты.

5. Память и разделение ресурсов: Все потоки одного процесса в Linux разделяют одно и то же пространство памяти. Это означает, что глобальные переменные и динамически выделенная память видны всем потокам. Однако у каждого потока есть свой стек, который отделён от стека других потоков, что позволяет каждому потоку сохранять свои локальные данные.

6. Сигналы: Потоки могут получать сигналы (например, от других потоков или процессов), но по умолчанию сигналы обрабатываются на уровне процесса. Это означает, что сигналы, такие как `SIGINT` или `SIGTERM`, посылаются процессу в целом, а не отдельному потоку. Однако POSIX Threads позволяет настраивать, какие потоки будут обрабатывать определённые сигналы.

### Cancel

`pthread_cancel()` — это функция, используемая для запроса завершения другого потока.
Когда один поток вызывает pthread_cancel() для другого потока, операционная система посылает запрос (механизм из pthread) на его завершение. Однако завершение не происходит немедленно.

Режимы отмены (Cancellation Modes):
1. **Отложенная отмена** (по умолчанию). Поток завершает своё выполнение только при достижении определённых точек отмены (cancellation points). Эти точки — это места, где поток может быть безопасно прерван. Примеры точек отмены: функции ввода-вывода, такие как `read()`, `write()`, `sleep()`, `pthread_cond_wait()`, `pthread_testcancel();`
	- `pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL);`
2. **Асинхронная отмена**  — поток может быть прерван в любой момент, что делает отмену мгновенной. Однако это небезопасный режим, так как прерывание может произойти в критическом участке кода (например, при работе с общими данными), что может привести к непредсказуемому поведению и ошибкам.
	- `pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);`

Возможность отмены:
1. **Отменяемое состояние** (по умолчанию) — поток может быть отменён (это состояние).
	- `pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);`
2. **Неотменяемое состояние** — запросы на отмену будут игнорироваться.
	- `pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);`

Когда поток получает запрос на завершение, он может зарегистрировать **обработчики завершения** для правильного освобождения ресурсов и завершения.
``` c
void cleanup(void *arg) { 
	printf("Cleaning up: %s\n", (char *)arg); 
} 
pthread_cleanup_push(cleanup, "Thread finished"); // регистрирует обработчик
// ... критическая секция 
pthread_cleanup_pop(1); // удаляет его
```

`pthread_cond_wait()` — это функция в библиотеке POSIX Threads (pthreads), которая используется для ожидания выполнения некоторого условия, обычно связанного с изменением состояния программы. Она блокирует текущий поток до тех пор, пока не будет выполнено условие, связанное с определённой переменной состояния (условной переменной), которую другие потоки могут изменить и уведомить через вызов соответствующих сигналов. Как работает:
- Ожидание на условной переменной: Функция блокирует поток, который вызвал pthread_cond_wait(), и помещает его в очередь ожидания условной переменной. Поток остаётся заблокированным до тех пор, пока другой поток не вызовет одну из функций сигнализации (например, `pthread_cond_signal()` или `pthread_cond_broadcast()`), которая уведомит об изменении состояния, на которое поток ожидает.
- Работа с мьютексом: Для правильного использования `pthread_cond_wait()` необходимо передать мьютекс (второй аргумент), который защищает разделяемый ресурс или данные, связанные с условием. Поток должен владеть мьютексом перед вызовом `pthread_cond_wait()`. Когда поток входит в состояние ожидания, мьютекс автоматически разблокируется (освобождается), чтобы другие потоки могли работать с этим ресурсом. Как только поток возобновляет выполнение (после пробуждения), он снова захватывает мьютекс, чтобы продолжить работу с защищёнными данными.

### Подробности про потоки

#### Особенности потоков:
- Потоки полностью делят адресное пространство процесса (вирутальное и физическое) 
- Каждый поток имеет свой task struct (так же как и каждый процесс)
- Основная единица деспетчеризации в ОС - это потоки 

#### Clone
`clone3()` - это системный вызов, который непосредственно отвечает за создание новых потоков в Linux. Он принимает несколько флагов, которые определяют, как будет работать новый поток, включая разделение памяти, файловых дескрипторов и сигналов с родительским потоком. В вашем выводе видны следующие флаги:
    - `CLONE_VM` — новый поток будет разделять адресное пространство с родительским.
    - `CLONE_FS`, `CLONE_FILES`, `CLONE_SIGHAND` — поток разделяет файловые системы, файловые дескрипторы и обработчики сигналов.
    - `CLONE_THREAD` — поток будет являться частью того же процесса, что и родительский (POSIX поток).
    - `CLONE_SYSVSEM`, `CLONE_SETTLS`, `CLONE_PARENT_SETTID`, `CLONE_CHILD_CLEARTID` — дополнительные флаги для управления семафорами, настройкой TLS и передачей идентификаторов потоков между родителем и ребенком.

#### Переключение контекств
**Переключение контекста** (context switch) — это процесс, при котором процессор останавливает выполнение одного процесса или потока и переключается на выполнение другого:
1. Сохранение контекста текущего процесса
	- Регистры общего назначения
	- Счётчик команд
	- Указатель стека
	- Указатель базы стека
	- Флаги процессора
	- Контекст сопроцессоров
	- Состояние управления памятью
	- Контексты ядра
2. Выбор нового процесса scheduler-ом
3. Загрузка контекста нового процесса
4. Продолжение выполнения нового процесса

#### Виды потоков:
1. **Ядерные** (kernel-level threads) - их диспетчеризирует ядро.
	- Cоздаются, управляются и уничтожаются ядром. 
	- Операционная система выполняет планирование этих потоков через системные вызовы.
	- Блокировка: Если ядерный поток блокируется, например, при ожидании ввода-вывода (I/O), ядро может переключиться на другой поток. Это позволяет системе эффективно управлять ресурсами.
	- Процессорные ресурсы: Ядерные потоки могут выполняться на нескольких процессорах одновременно
2. **Пользовательские** (user-level threads) - работают только в рамках юзерспейса и ядро не видит их напрямую.
	- Работают быстрее, так как не тратится время на системные вызовы при переключении контекста
3. **Модель смешанных потоков** (Hybrid Threads)
	- Современные системы часто используют гибридную модель, которая сочетает в себе элементы как ядерных, так и пользовательских потоков.

#### Thread Local Storage
**Thread Local Storage** (TLS) — это область памяти, выделенная для хранения данных, уникальных для каждого потока. Каждый поток имеет собственный набор переменных, которые не разделяются с другими потоками и остаются доступными только для него.
1. Локальные переменные с ключевым словом `__thread` или `thread_local`:
	- `__thread int thread_local_var = 0;`
2. Поточные переменные, используемые библиотеками:
	- Например errno из libc

#### Отличия pthread_self() и gettid:
- `pthread_self()` уникален для потоков в процессе и возвращает `pthread_t`
- `gettid()` уникален для потоков в системе и возвращает `pid_t` 

#### Отличие fork и clone:
- `fork` полностью копирует task struct
- `clone` заполняет task struct как надо (зависит от агрументов)

#### Отличия pthread_exit и return:
- `pthread_exit`: Завершает только текущий поток, а остальные потоки продолжают выполнение.
- `return`: Завершает только текущий поток, но если это основной поток (например, в `main`), завершится весь процесс, включая другие потоки.

#### Атрибуты потока
1. Размер стека:
2. Положение стека:
3. Отделение от родительского процесса:
    - `PTHREAD_CREATE_JOINABLE` (по умолчанию) или `PTHREAD_CREATE_DETACHED`.
4. Политика планирования:
	- `SCHED_FIFO` (First In, First Out):
		- Поток выполняется до тех пор, пока он не завершится или не блокируется (например, при ожидании ввода/вывода).
		- Потоки с одинаковым приоритетом выполняются в порядке их создания.
	- `SCHED_RR` (Round Robin):
		- Потоки с одинаковым приоритетом выполняются по очереди на фиксированный промежуток времени (квант времени)
	- `SCHED_OTHER`:
		- Это стандартная политика планирования, используемая для обычных процессов, не относящихся к реальному времени. Обычно она основана на алгоритме CFS (Completely Fair Scheduler), который стремится обеспечить "справедливое" распределение процессорного времени между всеми потоками.
		- Потоки с этой политикой имеют более низкий приоритет по сравнению с потоками `SCHED_FIFO` и `SCHED_RR`.
		- Предоставляет эффективное управление процессорным временем, но не гарантирует выполнение в реальном времени.
5. Приоритет:
    - Устанавливает параметры планирования (включая приоритет) для потока.
    - Политика планирования должна поддерживать приоритеты (например, `SCHED_FIFO` и `SCHED_RR`).
    - Диапазон от 1 до 99, где 99 — наивысший приоритет.
    - Для `SCHED_OTHER` приоритеты обычно задаются системой.
6. Состояние потока:
    - Устанавливает, будет ли новый поток наследовать политику и приоритет планирования от родительского потока (`PTHREAD_INHERIT_SCHED`) или использовать свои собственные параметры (`PTHREAD_EXPLICIT_SCHED`).
7. Наследование атрибутов:
8. Оптимизация для обработки сигналов:
    - Устанавливает область видимости потоков.
    - Может быть `PTHREAD_SCOPE_SYSTEM` (системный уровень, потоки могут быть запланированы на различных процессорах. Это позволяет операционной системе более гибко управлять потоками, используя более сложные алгоритмы планирования, которые могут учитывать состояние других потоков, запущенных в системе) или `PTHREAD_SCOPE_PROCESS` (потоки в пределах одного процесса).

#### Отличия joinable и detached
1. Если поток создан как joinable (присоединяемый):
	- Когда другой поток вызывает `pthread_join()`, операционная система:
		- Ждёт завершения потока.
		- Освобождает его ресурсы (стэк, дескрипторы и другие структуры).
	- Если вы не вызываете pthread_join() после завершения потока, ресурсы будут висеть в памяти (т.н. зомби-поток), пока процесс не завершится.
2. Если поток создан как detached (отсоединённый):
	- Ресурсы освобождаются автоматически после его завершения. Ресурсы освобождаются ядром сразу по окончанию потока.

#### Состояния потока
ОС отслеживает жизненный цикл каждого потока через несколько состояний:
- **Running (выполняется)** — поток активно выполняется на одном из процессоров.
- **Waiting (ожидание)** — поток заблокирован, ожидая завершения операции ввода-вывода или события (например, ожидание освобождения блокировки).
- **Terminated (завершён)** — поток завершил своё выполнение, но его ресурсы ещё не освобождены. В этом состоянии поток может находиться до тех пор, пока другой поток не вызовет `pthread_join()` (если поток joinable).

#### Идентификаторы:
- Каждый поток процесса имеет одинаковый PID
- Каждый поток процесса имеет уникальный TID
- Основной поток процесса имеет TID = PID

### Пользовательские потоки

#### Отличие ядерных потоков от пользовательских
- Ядерные потоки: планируются в ядре (шедулер в ядре)
- Пользовательские потоки: 
	- Планируются в userspace-е (шедулер пользовательский)
	- Работают в рамках одного ядерного процесса
	- Реально на процессоре выполняется только один из пользовательских потоков

**Контекст** представляет собой всю информацию, необходимую для приостановки и последующего возобновления выполнения потока или процесса. Контекст включает множество элементов, которые зависят от уровня абстракции, где происходит управление

Основные составляющие контекста:
1. Состояние регистров процессора:
    - Общие регистры: Содержат промежуточные данные, такие как локальные переменные или результаты арифметических операций.
    - Счётчик команд: Указывает на следующую инструкцию, которую процессор должен выполнить.
    - Указатель стека: Указывает на вершину текущего стека вызовов.
    - Базовый указатель: Используется для работы с локальными переменными в рамках вызова функции.
    - Флаги: Содержат информацию о состоянии процессора (например, результат предыдущей операции, наличие прерываний и т. д.).
2. Состояние памяти:
    - Стек: Содержит локальные переменные, адреса возврата, а также параметры функций. Для каждого потока обычно создаётся свой стек.
    - Сегменты данных и кода: Текущая область памяти, используемая для данных и команд.
    - Динамическая память: Указатели на выделенные области памяти (например, через malloc), если они относятся к текущему процессу/потоку.
4. Информация о сигналах (для процессов):
    - Какие сигналы зарегистрированы.
    - Установленные обработчики сигналов.
    - Маска сигналов (т. е. какие сигналы блокированы).
5. Потоковое состояние (для потоков):
    - Текущие идентификаторы потока.
    - Информация о синхронизации (например, заблокированные мьютексы, ожидание на условной переменной).
    - Текущий статус потока (выполняется, ожидает, завершён и т. д.).
6. Дополнительная информация:
    - Информация о привилегиях: Режимы работы (пользовательский или привилегированный режим).
    - Текущий контекст ввода-вывода: Файловые дескрипторы и указатели файлов.
    - Привязка к процессору: На каком ядре процессора выполняется поток.

#### Сравнение времени переключения контекста

| Тип переключения        | Время переключения | На что тратится время                                                                                                                                                                                                        |
| ----------------------- | ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Пользовательские потоки | Наименьшее         | Смена регистров процессора (в том числе указателя стека)                                                                                                                                                                     |
| Потоки ядра             | Среднее            | Всё предыдущее + сохранение информации о потоках (приоритеты, привязка к ядрам и т.д.) + работа в пространстве ядра (системные вызовы)                                                                                       |
| Процессы                | Наибольшее         | Всё предыдущее + смена адресного пространства (смена таблицы трансляций из-за изоляции памяти) + сохранение системных ресурсов (дескрипторы, файлы, устройства и т.д.) + сброс кэша (из-за изменения адресного пространства) |

#### Элементы кода для работы с пользовательским переключением контекста

- `ucontext_t` - структура для хранения контекста исполнения. Содержит:
	- `uc_stack` - указатель на стек, который будет использоваться при выполнении данного контекста.
	- `uc_sigmask` - множество сигналов, которые блокируются при выполнении этого контекста.
	- **`uc_mcontext`** - аппаратно-зависимое описание состояния процессора (регистры).
	- `uc_link` - указатель на следующий контекст, который будет восстановлен после завершения текущего (если указано `NULL`, то при завершении тукущего контекста завершиться вся программа).

- `int getcontext(ucontext_t *ucp);` - сохраняет текущий контекст выполнения.
	- `ucp` — указатель на структуру `ucontext_t`, куда сохраняется текущий контекст.

- `int setcontext(const ucontext_t *ucp);` - восстанавливает контекст выполнения
	- `ucp` — указатель на структуру `ucontext_t`, содержащую контекст для восстановления.

- `void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);` - используется для настройки контекста выполнения, который можно передать в функцию setcontext или swapcontext. Она позволяет определить, что будет выполняться (какая функция), когда управление перейдёт к заданному контексту.
	- `ucp` - указатель на объект типа `ucontext_t`, который содержит контекст выполнения.
	- `func` - функция, которая будет вызвана, когда управление перейдёт к данному контексту.
	- `argc` - число аргументов, передаваемых в функцию `func`.
	- `...` - аргументы, передаваемые в функцию `func` (в неё можно передать только int-ы). Замечание: аргументы передаются не через обычный вызов функции, а через стек, который предварительно настроен в контексте. Это значит, что `makecontext` сам "готовит" вызов функции, используя переданные аргументы, а не компилятор.

- `int swapcontext(ucontext_t *old_context, const ucontext_t *new_context);` - свап контекстов. Сохраняет текущий контекст и переключается на другой.
	- `old_context` - указатель на структуру, в которую будет сохранён текущий контекст.
	- `new_context` - указатель на структуру, содержащую контекст, к которому нужно переключиться.

## Синхронизация

### **Механизмы синхронизации**

#### Основные механизмы:
- *На уровне ядра* (предоставляются операционной системой):
	- [[#Mutex|Мьютекс]]
	- [[#Futex]]
	- [[#Spinlock|Спинлок]]
	- [[#Семафоры]]
	- [[#Условные переменные]]
	- [[#RW-Locks]]
	- [[#Барьеры]]
- *На уровне пользователя*:
	- [[#Compare And Swap|CAS]]
	- [[#Барьеры памяти]]

| Механизм | Преимущества                   | Недостатки                   |
| -------- | ------------------------------ | ---------------------------- |
| Мьютекс  | Простота, универсальность      | Возможность взаимоблокировок |
| Семафор  | Ограничение параллелизма       | Требует больше ресурсов      |
| Спинлок  | Быстрота на коротких секциях   | Нагрузка на CPU              |
| RW-Lock  | Баланс между чтением и записью | Сложнее в использовании      |
| Futex    | Минимизация затрат на ядро     | Только на Linux              |

### Compare And Swap

**CAS-операция** - атомарная операция сравнения и присвоения.
По логике работает примерно как следующий псевдокод (только атомарно):
```c
int CAS(flag, old, new)
{
	if (*flag != old)
		return 0;
	*flag = new;
	return 1;
}
```

#### CAS функции:
- `_Bool atomic_compare_exchange_strong(volatile A *obj, C *expected, C desired)`
	- **`obj`**  - указатель на атомарную переменную, значение которой нужно проверить и, при необходимости, обновить
	- **`expected`**  - указатель на переменную, содержащую предполагаемое значение `obj`. Если текущее значение `obj` не совпадает с `*expected`, то `*expected` будет обновлено до текущего значения `obj`
	- **`desired`** - новое значение, которое будет записано в `obj`, если текущее значение `obj` совпадает с `*expected`
	- Возвращает `_Bool` (true/false) - произощёл обмен или нет
- `atomic_compare_exchange_weak` — слабая версия CAS
	- Делает то же самое, что и "сильная" версия, но с важным отличием: Может спонтанно "провалиться". Это означает, что даже если ожидаемое значение `expected` совпадает с текущим значением атомарной переменной, операция всё равно может вернуть неуспех (false), не изменяя переменную. Такое поведение связано с архитектурными особенностями некоторых процессоров, где операция CAS может иногда "отменяться" по разным причинам (например, из-за оптимизаций)

### Spinlock

**Спинлоки** используются для синхронизации между потоками, где предполагается, что блокировка будет удерживаться короткое время. Вместо того чтобы блокировать поток, как в случае мьютексов, спинлоки "крутятся" в цикле, ожидая освобождения блокировки

#### Основные функции:
1. `int pthread_spin_init(pthread_spinlock_t *lock, int pshared)`
	- Инициализация спинлока
    - **`lock`** — указатель на объект типа `pthread_spinlock_t`
    - **`pshared`** — указывает, будет ли спинлок доступен только в рамках одного процесса или между процессами:
        - `PTHREAD_PROCESS_PRIVATE` — доступен только в текущем процессе.
        - `PTHREAD_PROCESS_SHARED` — может использоваться между процессами (если поддерживается системой)
2. `int pthread_spin_destroy(pthread_spinlock_t *lock)`
	- Уничтожение спинлока
    - Освобождает ресурсы, связанные со спинлоком. Не уничтожайте спинлок, пока на него ссылаются другие потоки
3. `int pthread_spin_lock(pthread_spinlock_t *lock)`
    - Захватывает спинлок. Если он уже захвачен другим потоком, текущий поток будет "крутиться" в цикле, ожидая освобождения
4. `int pthread_spin_trylock(pthread_spinlock_t *lock)`
    - Попытка захвата спинлока (без блокировки)
    - Захватывает спинлок, если он свободен. Если занят, возвращает `EBUSY`
5. `int pthread_spin_unlock(pthread_spinlock_t *lock)`
    - Освобождает спинлок, делая его доступным для других потоков

#### Ограничения спинлоков
1. *Время ожидания*: Если поток долго удерживает спинлок, другие потоки будут расходовать процессорное время впустую.
2. *Приоритетное инверсирование*: Если поток с низким приоритетом удерживает спинлок, высокоприоритетный поток будет вынужден ждать, что приводит к инверсии приоритетов.
3. *Портативность*: Спинлоки доступны не во всех системах POSIX. Перед использованием убедитесь, что ваша система их поддерживает.

#### Пример простой реализации спинлока:
```c
typedef struct {
    atomic_flag lock;
} spinlock_t;

void spinlock_acquire(spinlock_t *lock) {
    while (atomic_flag_test_and_set(&lock->lock)) {
        // Пустой цикл ...
        // atomic_flag_test_and_set - устанавливает атомарный флаг в true и
        // возвращает его предыдущее значение
    }
}

void spinlock_release(spinlock_t *lock) {
    atomic_flag_clear(&lock->lock);
}

```

### Futex

**Futex** (Fast Userspace Mutex) — это низкоуровневый механизм синхронизации, по минимому использующий системные вызовы. Он решает проблему спинлока (бесполезная загрузка процессора) с помощью перевода потоков в состояние SLEEP и обратно в RUNNABLE. На его основе создаются высокопроизводительных синхронизирующие примитивы (мьютексы, семафоры)

Futex использует разделяемую переменную в памяти (обычно типа `int`), которую потоки проверяют и изменяют атомарными операциями. Это позволяет:
- Синхронизировать доступ к ресурсу без вмешательства ядра, если блокировка свободна.
- При необходимости блокировать поток, обращаясь к ядру

#### Основные состояния процесса:
1. *RUN* - сейчас выполняется
2. *RUNNABLE* - может выполняться (планировщик может выбрать эту задачу для выполнения, переведя её тем самым в состояние RUN)
3. *SLEEP* - не может выполняться, так как ждёт какого-то события. Процессорное время имеется, но делать нечего

#### Интерфейс фьютекса:
`int futex(int *uaddr, int futex_op, int val, const struct timespec *timeout, int *uaddr2, int val3)`
- `uaddr` - указатель на переменную в памяти, используемую для синхронизации
- `futex_op` - операция, которую нужно выполнить
- `val` - значение, используемое в зависимости от операции
- `timeout` - таймаут для операций ожидания (опционально)
- `uaddr2` и `val3` - дополнительные параметры для более сложных операций

#### Основные операции Futex:
- `futex(uaddr, FUTEX_WAIT, expected_val, NULL, NULL, 0);` - переводит поток в режим ожидания, если значение переменной равно заданному. Если значение не совпадает, поток продолжает работу
- `futex(uaddr, FUTEX_WAKE, num_threads_to_wake, NULL, NULL, 0);` - пробуждает один или несколько потоков, ожидающих на данном адресе

#### Замечания:
- Интерфейс Futex в Linux — системный вызов `syscall(SYS_futex, ...)`
- Вместо нескольких функция для работы с примитовом, у фьютекса есть только одна универсальная функция, в которую надо передавать номер, определяющий, какая именно операция должна выполниться
- Переменная синхронизации вынесена в пользовательское пространство для обеспечения гибкости, универсальности и минимизации системных вызовов. Это ключевой принцип фьютексов — оставить максимальную часть работы на стороне пользователя, используя ядро только для операций блокировки и пробуждения.

### Mutex

**Мьютекс** (от mutual exclusion, "взаимное исключение") — работает как замок: только один поток может завладеть мьютексом в данный момент времени, получая доступ к ресурсу. Остальные потоки должны ждать, пока мьютекс освободится

#### Как работает?
1. Захват мьютекса: поток блокирует мьютекс перед доступом к ресурсу. Если поток пытается захватить уже занятый мьютекс, он будет ждать (перейдёт в режим сна) до тех пор, пока мьютекс не освободится
2. Критическая секция: поток выполняет операции с ресурсом
3. Освобождение мьютекса: поток освобождает мьютекс, чтобы другие потоки могли получить доступ

#### Типы мьютексов:
1. **Обычный** (PTHREAD_MUTEX_NORMAL):
    - Самый простой мьютекс
    - Один поток может захватить мьютекс, другие потоки блокируются до его освобождения
    - Используется для синхронизации доступа к ресурсам
2. **Рекурсивный** (PTHREAD_MUTEX_RECURSIVE):
    - Позволяет одному и тому же потоку захватить мьютекс несколько раз
    - Полезен, если функции вызываются рекурсивно и требуется повторный доступ к одному ресурсу
    - Поток должен освободить мьютекс столько же раз, сколько он его захватил
3. **Тайм-аутный** (Timed Mutex):
    - Позволяет потоку попытаться захватить мьютекс в течение определённого времени.
    - Если мьютекс не освободится за это время, поток получит уведомление о неудаче
4. **Приоритетный** (Priority Mutex):
    - Гарантирует, что потоки с более высоким приоритетом получат доступ к мьютексу раньше, чем потоки с более низким приоритетом
5. **Мьютекс с проверкой ошибок** (PTHREAD_MUTEX_ERRORCHECK):
    - Добавляет проверки на корректность вызова
    - В отличае от обычного мьютекса при возникновении ошибки не происходит undefined behavior
    - Потенциальные ошибки:
	    - Если поток пытается снова заблокировать мьютекс, который он уже захватил, возвращается ошибка `EDEADLK` (потенциальный deadlock)
	    - Если поток пытается разблокировать мьютекс, который не захвачен, возвращается ошибка `EPERM`
	    - Если поток разблокирует мьютекс, захваченный другим потоком, возвращается ошибка `EPERM`

##### Изменение типа мьютекса:
```c
pthread_mutex_t mutex;
pthread_mutexattr_t attr; 
// Инициализация атрибутов мьютекса
pthread_mutexattr_init(&attr); 
pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK); 
// Инициализация мьютекса 
pthread_mutex_init(&mutex, &attr);
```

#### Функции для работы с обычным мьютексом:
- `int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);` - инициализирует мьютекс с заданными атрибутами или значениями по умолчанию (если передать NULL в аргументах)
- `int pthread_mutex_lock(pthread_mutex_t *mutex);` - захватывает мьютекс, блокируя выполнение потока, если мьютекс уже захвачен
- `int pthread_mutex_trylock(pthread_mutex_t *mutex);` - пытается захватить мьютекс. Если мьютекс уже захвачен, возвращает немедленно
- `int pthread_mutex_unlock(pthread_mutex_t *mutex);` - освобождает ранее захваченный мьютекс
- `int pthread_mutex_destroy(pthread_mutex_t *mutex);` - освобождает ресурсы, связанные с мьютексом

#### Особенности мьютексов:
1. *Deadlock* (взаимная блокировка):
    - Может произойти, если два потока захватили разные мьютексы и ждут друг друга для их освобождения
2. *Race Condition* (состояние гонки):
    - Если мьютекс не используется или используется неправильно, несколько потоков могут одновременно получить доступ к ресурсу, что приведёт к непредсказуемому поведению
3. *Производительность*:
    - Захват мьютекса может быть дорогой операцией из-за переключения контекста между потоками

### Условные переменные

**Условные переменные** (Condition Variables) позволяют потокам ожидать наступления определённых условий, одновременно освобождая связанный мьютекс, чтобы другие потоки могли изменять эти условия. Это удобное средство синхронизации, помогающее избежать холостых циклов

#### Основные функции:
- `int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);` - Инициализирует условную переменную
- `int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);` - освобождает мьютекс и блокирует поток до тех пор, пока другой поток не подаст сигнал об изменении условия
- `int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex, const struct timespec *abstime);` - как pthread_cond_wait, но с тайм-аутом
- `int pthread_cond_signal(pthread_cond_t *cond);` - пробуждает один поток, ожидающий на условной переменной. Пробуждающийся поток сначала пытается обратно захватить мьютекс. Только после успешного захвата мьютекса поток продолжает выполнение. Если мьютекс уже захвачен другим потоком, пробуждённый поток остаётся заблокированным, пока мьютекс не станет доступным
- `int pthread_cond_broadcast(pthread_cond_t *cond);` - как pthread_cond_signal, но пробуждает все потоки, ожидающие на условной переменной
- `int pthread_cond_destroy(pthread_cond_t *cond);` - освобождает ресурсы, связанные с условной переменной

#### Особенности условных переменных:
1. *Обязательная блокировка мьютекса*: Условные переменные работают только в связке с мьютексами.
2. *Спуриация пробуждений*: Поток может проснуться без явного сигнала, поэтому важно повторно проверять условие после пробуждения.
3. *Производительность*: Условные переменные позволяют избежать холостого цикла, что делает их более эффективными для синхронизации.

### Семафоры

**Семафоры** — предоставляют простой способ ограничить количество потоков, одновременно использующих ресурс. Семафор — это целочисленный счётчик, который указывает, сколько потоков или процессов могут одновременно получить доступ к ресурсу

#### Типы семафоров:
- **Бинарный семафор** (аналог мьютекса): принимает значения 0 или 1, используется для управления доступом к одному ресурсу. В отличае от мьютекса бинарный симофор не обязательно освобождается тем же потоков, который его захватил.
- **Счётный семафор**: принимает значения от 0 до некоторого максимума, ограничивая количество потоков, которым одновременно разрешён доступ.

#### Основные операции:
- `int sem_init(sem_t *sem, int pshared, unsigned int value);` - инициализация
    - `pshared = 0` - семафор используется только потоками внутри процесса.
    - `value` - начальное значение счётчика семафора.
- `int sem_destroy(sem_t *sem);` - удаление
- `sem_wait` - уменьшает значение семафора, блокирует, если значение ≤ 0.
- `sem_post` - увеличивает значение семафора, пробуждая ожидающие потоки.
- `sem_trywait` - не блокирует, если семафор недоступен.

#### Зачем нужны семафоры?
- Используются для ограничения количества потоков или процессов, одновременно имеющих доступ к ресурсу (например, пул соединений, фиксированное количество файлов или сетевых подключений).
- Пример: Если есть 5 принтеров, семафор с начальным значением 5 гарантирует, что одновременно будет использоваться не больше 5 принтеров.

#### Особенности семафоров:
- Не привязан к конкретному потоку:
    - Семафоры не имеют понятия "владельца". Это значит, что один поток может уменьшить счётчик, а другой поток может его увеличить.
- Могут работать между процессами:
    - Семафоры можно использовать для синхронизации процессов (межпроцессная синхронизация). Это отличает их от мьютексов, которые чаще всего работают в пределах одного процесса.

### RW-Locks

**RW-Locks** — это тип синхронизирующего примитива, позволяющий управлять доступом к ресурсу с учетом разделения операций на чтение и запись. Они полезны, когда требуется обеспечить параллельный доступ для операций чтения при условии, что запись выполняется только одной сущностью одновременно

#### Два уровня блокировки:
1. *Читательский блок (shared lock)*:
    - Множественные потоки могут захватывать блокировку на чтение одновременно, если нет активной блокировки на запись
    - Это оптимизирует производительность для операций чтения, которые не изменяют общий ресурс
2. *Писательский блок (exclusive lock)*:
    - Блокировка на запись захватывается только одним потоком
    - Все другие потоки (как читающие, так и записывающие) должны ждать, пока писатель освободит блокировку

#### Функции:
- `pthread_rwlock_init(&rwlock, NULL);` - инициализация
- `pthread_rwlock_rdlock(&rwlock);` - захватывает блокировку на чтение. Если есть активный писатель, поток блокируется
- `pthread_rwlock_wrlock(&rwlock);` - захватывает блокировку на запись. Все читатели и другие писатели блокируются
- `if (pthread_rwlock_tryrdlock(&rwlock) == 0) { // Захват успешен }` - попытка захвата
- `if (pthread_rwlock_trywrlock(&rwlock) == 0) { // Захват успешен }` - попытка захвата
- `pthread_rwlock_unlock(&rwlock);` - освобождение блокировки
- `pthread_rwlock_destroy(&rwlock);` -  уничтожение

#### Замечания:
- В каждый момент времени возможны только следующие сценарии:
	- Один поток пишет (write lock)
	- Несколько потоков одновременно читают (read lock)
	- Ни один поток ничего не делает (ресурс свободен)
- RW-Locks обеспечивают более высокую производительность, чем обычные мьютексы, для сценариев с высокой частотой операций чтения, так как они позволяют множественным потокам читать одновременно
- Проблемы с читателями и писателями:
    - Если читатели занимают ресурс слишком долго, писатели могут быть заблокированы на неопределенное время (*starvation писателей*)
    - Если приоритет у писателей, читатели могут страдать от задержек (ногие реализации дают предпочтение либо читателям, либо писателям)

#### RW-Locks подходят, если:
1. Чтения ресурса происходят гораздо чаще, чем записи
2. Чтения являются независимыми и не изменяют состояние ресурса
3. Вы хотите оптимизировать производительность для параллельных операций чтения

### Барьеры

**Барьеры**  — это механизмы, которые позволяют нескольким потокам или процессам согласовывать свои действия, гарантируя, что каждый из них достигает определённой точки (называемой барьером) перед продолжением выполнения. Барьеры используются для обеспечения синхронности между потоками в многопоточных программах

#### Как работают барьеры?
1. Потоки выполняют свои задачи параллельно
2. В определённый момент они вызывают функцию, связанную с барьером (например, `pthread_barrier_wait` в POSIX)
3. Каждый поток блокируется при достижении барьера и ждёт, пока все другие потоки также не достигнут барьера
4. Когда все потоки достигли барьера, они продолжают выполнение

#### Особенности и ограничения:
1. *Число участников*:
    - Барьер заранее инициализируется с числом потоков, которые должны его достичь. Это число обычно фиксировано
2. *Необходимость учёта всех потоков*:
    - Если один поток не достигает барьера (например, зависает), остальные потоки будут ждать бесконечно, что приведёт к deadlock
3. *Неудобство при динамическом изменении числа потоков*:
    - Барьеры не подходят, если число потоков в процессе синхронизации меняется

### Барьеры памяти

**Барьеры памяти** (memory barriers) — это механизм, используемый в многопоточном программировании для управления порядком выполнения операций с памятью. Они обеспечивают гарантии о том, что операции записи и чтения данных в память будут выполняться в определённом порядке, несмотря на возможные оптимизации процессора или компилятора.

#### Почему нужны барьеры памяти?
1. *Переупорядочивание инструкций:*
    - Процессор может менять порядок выполнения операций, чтобы лучше использовать доступные ресурсы.
2. *Кэширование:*
    - Разные ядра могут видеть устаревшие значения данных из кэша, что нарушает согласованность данных.
3. *Оптимизация компилятора:*
    - Компилятор может удалить или переставить инструкции, если они кажутся независимыми.

#### Типы барьеров памяти:
1. **Load Barrier**:
    - Гарантирует, что все операции чтения, выполненные до барьера, завершатся до начала операций чтения после барьера.
2. **Store Barrier**:
    - Гарантирует, что все операции записи, выполненные до барьера, завершатся до начала операций записи после барьера.
3. **Full Barrier**:
    - Гарантирует, что все операции записи и чтения, выполненные до барьера, завершатся до начала операций чтения и записи после барьера.
4. **Acquire/Release Barriers**:    
    - **Acquire**: предотвращает переупорядочивание инструкций до барьера.
    - **Release**: предотвращает переупорядочивание инструкций после барьера.

#### Когда использовать барьеры памяти?
1. *Работа с lock-free алгоритмами:*
    - Контроль порядка операций критичен.
2. *Согласованность данных между потоками:*
    - Гарантия видимости изменений.
3. *Улучшение производительности:*
    - Различные типы барьеров помогают минимизировать затраты на синхронизацию.

### Атомарные операции

**Атомарные переменные** — это переменные, для которых операции чтения, записи и сравнения выполняются как неделимые (атомарные). Это значит, что в многопоточном окружении доступ к такой переменной не прерывается и не вызывает гонок данных

**Атомарные операции** — это операции, которые выполняются без возможности их прерывания другими потоками. Они гарантируют согласованность данных при работе с разделяемыми ресурсами.

#### Атомарные типы:
- `atomic_int` - атомарный тип для целых чисел
- `atomic_intptr_t` - атомарный тип для указателей целых чисел (`intptr_t`)
- `atomic_size_t` - атомарный тип для размера объектов (`size_t`)
- `atomic_void *` - атомарный указатель на произвольный тип данных
- `atomic_flag` - булевая атомарная переменная
- `_Atomic(type)` - универсальный атомарный тип. Например: `_Atomic(float)`
- И так далее...

#### Ключевые функции атомарных операций:
- `atomic_load` - атомарное читает значения переменной
- `atomic_store` - атомарная запись значения в переменную
- `atomic_fetch_add` - атомарное добавление (возвращает предыдущее значение)
- `atomic_fetch_sub` - атомарное вычитание (возвращает предыдущее значение)
- `atomic_compare_exchange_strong` - сравнивает и, если совпадает, изменяет значение
- `atomic_compare_exchange_weak` - слабая версия, может ложно завершаться неудачно
- `atomic_flag_clear` - установка атомарного флага в false
- `atomic_flag_test_and_set` - устанавливает атомарный флаг в true и возвращает его предыдущее значение

#### Чтобы атомарно изменять переменную необходимо:
1. *Использовать атомарный тип* (например, `atomic_int` из `<stdatomic.h>`):
    - Эти типы специально разработаны для работы с атомарными операциями
    - Они обеспечивают гарантии атомарности благодаря встроенной аппаратной или программной поддержке
2. *Применять атомарные функции и макросы*:
    - Например, `atomic_load`, `atomic_store`, `atomic_fetch_add`, `atomic_compare_exchange_strong` из `<stdatomic.h>`.

#### Замечания:
- Атомарные операции не предназначены для обычных неатомарных типов
- Обычные операции не работают атомарно с переменными атомарных типов

## Дополнительные темы

### Lock-Free алгоритмы

**Lock-Free алгоритмы** — это алгоритмы, которые обеспечивают синхронизацию между потоками без использования блокировок (mutex, spinlock и т.п.). Они гарантируют, что по крайней мере один поток завершит свою операцию за конечное число шагов, независимо от поведения других потоков. Основной инструмент для реализации lock-free алгоритмов - атомарные операции. Lock-free алгоритмы находят применение в системах реального времени, базах данных и других приложениях, где минимизация задержек имеет ключевое значение.

#### Популярные lock-free алгоритмы:
1. Lock-Free Стек
2. Lock-Free Очередь
3. Lock-Free Кольцевой Буфер
4. Lock-Free Списки
5. Lock-Free Хэш-таблица
6. Lock-Free Счётчики
7. Lock-Free Деки
8. Lock-Free Массивы

#### Гарантии lock-free алгоритмов:
- *Lock-Free*: Гарантия прогресса хотя бы одного потока.
- *Wait-Free*: Гарантия прогресса всех потоков за конечное время.
- *Obstruction-Free*: Поток завершит операцию, если не будет конкуренции.

#### Преимущества Lock-Free алгоритмов:
1. Избегают deadlock, starvation и priority inversion.
2. Улучшают производительность в условиях высокой параллельности.
3. Лучше масштабируются на многоядерных системах.

#### Недостатки Lock-Free алгоритмов:
1. Более сложная реализация по сравнению с блокировками.
2. Требуют атомарных операций, которые могут быть медленнее на старых процессорах.
3. Зависимость от архитектуры процессора (некоторые инструкции недоступны на всех системах).
4. ABA-проблема:
	- Возникает, когда указатель A изменился на B, а затем обратно на A, но операция CAS не обнаруживает изменений.
	- Решения: использование счетчиков версий либо примитивы, такие как double-wide CAS (где CAS проверяет одновременно указатель и версию).

### Терминалы

**Shell** (оболочка) — это программа, предоставляющая интерфейс между пользователем и операционной системой. Shell позволяет запускать команды, программы и скрипты, а также управлять процессами и файловой системой

##### Основные оболочки из UNIX:
- *Bash* (Bourne Again Shell): наиболее популярная оболочка в Linux. Обеспечивает мощные возможности, такие как редактирование команд, автодополнение, функции и скрипты.
- *sh* (Bourne Shell): классическая оболочка UNIX, изначально разработанная для написания скриптов.
- *zsh* (Z Shell): улучшенная оболочка с поддержкой тем, плагинов и улучшенного автодополнения.
- *fish* (Friendly Interactive Shell): более современная оболочка с удобным интерфейсом и встроенными функциями автодополнения.
- *ksh* (KornShell): расширение Bourne Shell с добавлением возможностей программирования.

**Tmux** (от "terminal multiplexer") — это инструмент для многозадачной работы в командной строке, который позволяет запускать несколько терминальных сессий в одном окне, а также управлять ими. Он является популярным среди разработчиков и системных администраторов для управления несколькими задачами в одном терминале.

### HTTP кэширующий прокси

#### Ключевые моменты
- **HTTP/1.0 не поддерживает постоянные соединения** по умолчанию. После обработки запроса сервер может закрыть соединение.
- **Каждый HTTP/1.0 запрос требует нового TCP-соединения**, что снижает эффективность по сравнению с HTTP/1.1, где используется "Keep-Alive".

#### Структура HTTP-запроса:
1. Стартовая строка (Request Line):
	- `<Метод> <URL> <Версия HTTP>` - тип запроса, целевой ресурс и версия HTTP
	- Пример: GET /index.html HTTP/1.0
2. Заголовки (Headers):
	- Пары ключ: значение, определяющие дополнительную информацию для сервера
	  - Пример: Host: example.com
		           User-Agent: Mozilla/5.0
		           Accept: text/html
3. Пустая строка:
	- Отделяет заголовки от тела запроса. Если тела запроса нет, запрос заканчивается здесь
4. Тело запроса (Body):
	- Может содержать данные для передачи на сервер (например, при методе POST)

#### Структура URL
URL := <протокол> <хост> <порт> <путь> <запрос> <фрагмент>
Пример: `https://www.example.com:443/path/to/page?user=123#section`
- Протокол: `https`
- Имя хоста: `www.example.com`
- Порт: `443` (опускается, если используется стандартный порт для протокола)
- Путь: `/path/to/page`
- Запрос: `?user=123`
- Фрагмент: `#section`

#### Пример последовательности передачи
Клиент отправляет запрос:
```
GET /index.html HTTP/1.0\r\n
Host: example.com\r\n
\r\n
```
Сервер обрабатывает запрос и отправляет ответ:
```
HTTP/1.0 200 OK\r\n
Content-Length: 13\r\n
\r\n
Hello, World!
```

Пример настройки прозрачного прокси с использованием iptables (для Linux):
`iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 3128`
В данном случае все запросы на порту 80 будут перенаправлены через прокси, устанавливая два соединения.

