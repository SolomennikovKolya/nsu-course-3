
### Полезности
- [Медия](https://www.nsumedia.ru/main_potok/third_course/fifth_semester/systems)
- [Задания](file:///C:/Users/%D0%9F%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C/Downloads/Telegram%20Desktop/OS.Semester-2.Tasks.pdf)
- [Хабр про POSIX](https://habr.com/ru/articles/326138/)
- [Критерии оценок]([BOS.FinalAssessmentCriteria.pdf](file:///C:/Users/%D0%9F%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C/Downloads/Telegram%20Desktop/BOS.FinalAssessmentCriteria.pdf))

### Лабы
- [x] 1.1
- [x] 1.2
- [ ] 1.3
- [ ] 1.4
- [ ] 1.5
- [ ] 1.6
- [ ] 1.7
- [ ] 2.1
- [ ] 2.2
- [ ] 2.3
- [ ] 2.4
- [ ] 3

### Команды
- `ulimit -a` - посмотреть ограничения, заданные в ОС
- `cat /proc/sys/kernel/threads-max` - посмотреть максимальное количество потоков

### POSIX threads - основы

Замечания:
- Базовая единица загрузки ЦПУ - поток.
- У всех исполняемых процессов есть как минимум один поток исполнения. Некоторые процессы этим и ограничиваются.
- Ядро ОС может создать новый поток на порядок быстрее, чем новый процесс.
- Потоки могут быть созданы не только в режиме ядра, но и в режиме пользователя.
- Пользовательские потоки по разному отображаются на потоки в режиме ядра. Всего существует три модели, из которых 1:1 является наиболее часто используемой.
- В каждом потоке есть своё errno, чтобы не было гонки данных.

| Потоки делят память:                 | Copy On Write:                       |
| ------------------------------------ | ------------------------------------ |
| ![[Pasted image 20240926095813.png]] | ![[Pasted image 20240926100353.png]] |

| N:1                                  | 1:1                                  | M:N                                  |
| ------------------------------------ | ------------------------------------ | ------------------------------------ |
| ![[Pasted image 20240926104431.png]] | ![[Pasted image 20240926104341.png]] | ![[Pasted image 20240926104350.png]] |

Основные функции для работы с потоками:
- `pthread_create` — создание нового потока.
- `pthread_join` — ожидание завершения потока.
- `pthread_exit` — завершение потока.
- `pthread_detach` — отделение потока, чтобы его завершение происходило автоматически, без ожидания через `pthread_join`.
- `pthread_mutex_lock` и `pthread_mutex_unlock` — механизмы синхронизации потоков для предотвращения гонок данных.

Набор типов:
- `pthread_t` — идентификатор потока;
- `pthread_mutex_t` — мютекс;
- `pthread_mutexattr_t` — объект атрибутов мютекса
- `pthread_cond_t` — условная переменная
- `pthread_condattr_t` — объект атрибута условной переменной;
- `pthread_key_t` — данные, специфичные для потока;
- `pthread_once_t` — контекст контроля динамической инициализации;
- `pthread_attr_t` — перечень атрибутов потока.

Существуют и другие библиотеки для работы с потоками. Они не обязательно основываются на стандарте POSIX.
 - C++ Standard Library (`std::thread`)
 - OpenMP: OpenMP
 - Boost.Thread: Boost
 - Intel Threading Building Blocks (TBB)
 - И другие

### Функции pthread

1. `pthread_create` - создаёт новый поток.
	- `int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);`
    - `thread` - идентификатор созданного потока.
    - `attr` - атрибуты потока (если указать NULL, используются атрибуты по умолчанию).
    - `start_routine` - функция, которую должен выполнить поток.
    - `arg` - аргумент, который передаётся в функцию потока.

2. `pthread_exit` - явное завершение потока.
	- `void pthread_exit(void *retval);`
	- `retval` - возвращаемое значение (аналогично return)
	- Если программа завершает работу с помощью return, то весь процесс завершается, поэтому pthread_exit важен, если не надо закрывать все потоки в процессе.

3. `pthread_join` - ожидание завершения потока.
	`int pthread_join (pthread_t THREAD_ID, void ** DATA);`
	- `THREAD_ID` - идентификатор ожидаемого потока
	- `DATA` - значение, которое вернул ожидаемый поток 
	- Несколько потоков не могут ждать завершения одного. Если они пытаются выполнить это, один поток завершается успешно, а все остальные — с ошибкой ESRCH.
	- В каком-то смысле `pthread_join()` похожа на вызов `waitpid()`, ожидающую завершения исполнения процесса, но с некоторыми отличиями. Во-первых, все потоки одноранговые, среди них отсутствует иерархический порядок, в то время как процессы образуют дерево и подчинены иерархии родитель — потомок.

4. `pthread_cancel` - досрочное завершение потока.
	- `int pthread_cancel(pthread_t THREAD_ID);`
	- Поток не только может самостоятельно выбрать момент завершения в ответ на вызов pthread_cancel(), но и вовсе его игнорировать, поэтому это больше похоже на запрос на выполнение досрочного завершения потока.

5. `pthread_testcancel` - проверяет, были ли отправлены запросы на отмену текущего потока. Она позволяет программно проверять, нужно ли прервать выполнение потока.
	- `void pthread_testcancel(void);`

6. `pthread_detach` — переводит поток в отсоединённое состояние (detached state). Когда поток находится в таком состоянии, его завершение не нужно отслеживать с помощью pthread_join(), и система автоматически освобождает все ресурсы, связанные с ним, когда он завершает выполнение.
	- `int pthread_detach(pthread_t thread);`
	- `thread` - идентификатор потока, который вы хотите отсоединить.

7. `pthread_self` — возвращает идентификатор текущего потока.
	- `pthread_t pthread_self(void);`

8. `pthread_equal` - сравнивает два идентификатора потоков и возвращает ненулевое значение (истина), если они равны, и 0 (ложь), если не равны.
	- `int pthread_equal(pthread_t t1, pthread_t t2);`
	- Для pthread_t нельзя просто использовать == так как это pthread_t - не обязательно число (это может быть структура или другой тип, в зависимости реализации библиотеки в различных системах). 
 
### Как работает POSIX Threads с точки зрения системных вызовов:

Потоки в Linux управляются через механизм **kernel threads** (потоков ядра) и используют такие ключевые системные вызовы, как `clone()`, `futex()`, `sched_yield()`, и другие.

1. Создание потока: `pthread_create()` неявно вызывает `clone()`, который принимает флаги, которые определяют, какие ресурсы будут разделяться между потоком и родительским процессом. В результате, новый поток получает доступ к тому же адресному пространству, файловым дескрипторам, таблице сигналов и другим ресурсам, что и основной процесс.
	- `int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...);`

2. Для синхронизации потоков используется механизм системных вызовов futex (Fast Userspace Mutex). `futex()` — это низкоуровневый примитив синхронизации, который работает как гибридная схема: сначала пытается выполнить синхронизацию в пользовательском пространстве без вмешательства ядра, и только при необходимости (например, в случае конфликта) вызывает системный вызов. 
   Основной принцип работы `futex()`:
    - В большинстве случаев операции блокировки и разблокировки происходят в пользовательском пространстве без перехода в ядро.
    - Если поток блокируется на ожидании ресурса (например, мьютекс занят), вызывается системный вызов `futex()` для перевода потока в спящий режим до тех пор, пока ресурс не станет доступен.
    - `int futex(int *uaddr, int futex_op, int val, const struct timespec *timeout, int *uaddr2, int val3);`

3. Управление потоками:
    - Планирование (scheduling): потоки планируются и управляются с помощью планировщика ядра, который контролирует их выполнение. POSIX Threads в основном полагается на системные вызовы, такие как `sched_yield()` для добровольного уступления процессорного времени другим потокам. 
    - Вызов `sched_yield()`:
        `int sched_yield(void);` - переводит текущий поток в состояние ожидания, позволяя другим потокам выполнять свою работу.
    - Завершение потока: когда поток завершается (например, через `pthread_exit()`), ядро освобождает ресурсы, связанные с этим потоком. Обычно это делается с помощью системного вызова `exit()`, если это последний поток процесса, либо с помощью сигнала ядра, который переводит поток в состояние "зомби" до полной его очистки.
 
4.  Механизм планировщика ядра: Потоки в Linux обрабатываются планировщиком ядра, который распределяет процессорное время между потоками в соответствии с их приоритетами и политиками планирования. Это может быть политика:
    - SCHED_OTHER — обычная политика для обычных задач (по умолчанию).
    - SCHED_FIFO — для задач реального времени (FIFO).
    - SCHED_RR — задачи реального времени с круговым циклом (round-robin).
    - Планировщик ядра решает, какой поток будет запущен на CPU в данный момент на основании этих политик и других факторов, таких как время выполнения и приоритеты.

5. Память и разделение ресурсов: Все потоки одного процесса в Linux разделяют одно и то же пространство памяти. Это означает, что глобальные переменные и динамически выделенная память видны всем потокам. Однако у каждого потока есть свой стек, который отделён от стека других потоков, что позволяет каждому потоку сохранять свои локальные данные.

6. Сигналы: Потоки могут получать сигналы (например, от других потоков или процессов), но по умолчанию сигналы обрабатываются на уровне процесса. Это означает, что сигналы, такие как `SIGINT` или `SIGTERM`, посылаются процессу в целом, а не отдельному потоку. Однако POSIX Threads позволяет настраивать, какие потоки будут обрабатывать определённые сигналы.

### Data segment

Data segment (секция данных):
1. Initialized Data Segment (Инициализированная секция данных) - инициализированные глобальные и статические переменные
2. Block Started by Symbol (BSS, Неинициализированная секция данных) - неинициализированные глобальные и статические переменные
	- При запуске программы они автоматически инициализируются нулями)
	- Всегда остаются в этом сегменте даже при изменении
	- В исполняемом файле они не занимают места

| Локальные переменные | Локальные статические переменные | Локальные константные переменные | Глобальные переменные |
| -------------------- | -------------------------------- | -------------------------------- | --------------------- |
| стек                 | Сегмент данных                   | Стек                             | Сегмент данных        |
### Прерывания 

**Прерывания** — это аппаратные события, которые сигнализируют процессору о необходимости выполнения определённых действий. Когда происходит прерывание, процессор приостанавливает текущий процесс (или поток) и переключается на обработку прерывания.

Виды прерываний:
- **Аппаратные прерывания**: Генерируются аппаратными устройствами (например, клавиатура, сеть, таймер). Например, нажатие клавиши или приход сетевого пакета вызывает аппаратное прерывание.
- **Программные прерывания**: Вызываются программно с помощью специальных инструкций. Например, системные вызовы работают через программные прерывания.
- **Таймерные прерывания**: Генерируются встроенным в процессор таймером для переключения задач в многозадачной среде.

Что происходит при прерывании:
1. Прерывание возникает.
2. Процессор сохраняет контекст текущей задачи.
3. Управление передаётся обработчику прерываний (Interrupt Service Routine, ISR).
4. После завершения ISR выполнение программы продолжается с того места, где было приостановлено.

### Сигналы

**Сигналы** — это механизмы управления процессами на уровне операционной системы (в пользовательском пространстве). Сигнал — это сообщение, которое одно ядро или процесс может отправить другому процессу (или самому себе) для того, чтобы сообщить о каком-то событии или состоянии.

Неблокируемые сигналы:
1. **SIGKILL** (`9`): Этот сигнал немедленно завершает процесс и не может быть перехвачен или игнорирован.
	- Можно отправить, нажав `CTRL+C`
2. **SIGSTOP** (`19` или `23` в зависимости от архитектуры): Этот сигнал приостанавливает процесс и также не может быть перехвачен или игнорирован. После получения этого сигнала процесс может быть возобновлён с помощью сигнала `SIGCONT`.
	- Можно отправить, нажав `CTRL+Z`

Сигналы можно отправлять вручную. Например:
`kill -SIGTSTP PID` - приостановка процесса

| Сигналы                                                                 | Прерывания                                                                                       |
| ----------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
| Применяются к процессам в пользовательском пространстве.                | Работают на уровне процессора и устройства.                                                      |
| Отправляются ядром или процессами.                                      | Возникают в ответ на аппаратные или программные события.                                         |
| Процесс может определить обработчики сигналов.                          | Прерывания обрабатываются операционной системой через ISR.                                       |
| Используются для межпроцессного взаимодействия и управления процессами. | Используются для взаимодействия процессора с устройствами и системой.                            |
| Могут быть блокированы или обработаны (кроме `SIGKILL`, `SIGSTOP`).     | Прерывания нельзя блокировать на уровне программы, но их можно маскировать на уровне процессора. |

### Подробности про потоки

Особенности потоков:
- Потоки полностью делят адресное пространство процесса (вирутальное и физическое) 
- Каждый поток имеет свой task struct

`clone3()` - это системный вызов, который непосредственно отвечает за создание новых потоков в Linux. Он принимает несколько флагов, которые определяют, как будет работать новый поток, включая разделение памяти, файловых дескрипторов и сигналов с родительским потоком. В вашем выводе видны следующие флаги:
    - `CLONE_VM` — новый поток будет разделять адресное пространство с родительским.
    - `CLONE_FS`, `CLONE_FILES`, `CLONE_SIGHAND` — поток разделяет файловые системы, файловые дескрипторы и обработчики сигналов.
    - `CLONE_THREAD` — поток будет являться частью того же процесса, что и родительский (POSIX поток).
    - `CLONE_SYSVSEM`, `CLONE_SETTLS`, `CLONE_PARENT_SETTID`, `CLONE_CHILD_CLEARTID` — дополнительные флаги для управления семафорами, настройкой TLS и передачей идентификаторов потоков между родителем и ребенком.

Переключение контекста (context switch) — это процесс, при котором процессор останавливает выполнение одного процесса или потока и переключается на выполнение другого:
1. Сохранение контекста текущего процесса
	- Регистры общего назначения
	- Счётчик команд
	- Указатель стека
	- Указатель базы стека
	- Флаги процессора
	- Контекст сопроцессоров
	- Состояние управления памятью
	- Контексты ядра
2. Выбор нового процесса scheduler-ом
3. Загрузка контекста нового процесса
4. Продолжение выполнения нового процесса

Виды потоков:
1. **Ядерные** (kernel-level threads) - их диспетчеризирует ядро.
	- Cоздаются, управляются и уничтожаются ядром. 
	- Операционная система выполняет планирование этих потоков через системные вызовы.
	- Блокировка: Если ядерный поток блокируется, например, при ожидании ввода-вывода (I/O), ядро может переключиться на другой поток. Это позволяет системе эффективно управлять ресурсами.
	- Процессорные ресурсы: Ядерные потоки могут выполняться на нескольких процессорах одновременно
2. **Пользовательские** (user-level threads) - работают только в рамках юзерспейса и ядро не видит их напрямую.
	- Работают быстрее, так как не тратится время на системные вызовы при переключении контекста
3. Модель смешанных потоков (Hybrid Threads)
	- Современные системы часто используют гибридную модель, которая сочетает в себе элементы как ядерных, так и пользовательских потоков.

**Thread Local Storage (TLS)** — это область памяти, выделенная для хранения данных, уникальных для каждого потока. Каждый поток имеет собственный набор переменных, которые не разделяются с другими потоками и остаются доступными только для него.
1. Локальные переменные с ключевым словом `__thread` или `thread_local`:
	- `__thread int thread_local_var = 0;`
2. Поточные переменные, используемые библиотеками:
	- Например errno из libc

Отличия pthread_self() и gettid:
- `pthread_self()` уникален для потоков в процессе и возвращает `pthread_t`
- `gettid()` уникален для потоков в системе и возвращает `pid_t` 

Отличие fork и clone:
- `fork` полностью копирует task struct
- `clone` заполняет task struct как надо (зависит от агрументов)

Отличия pthread_exit и return:
- `pthread_exit`: Завершает только текущий поток, а остальные потоки продолжают выполнение.
- `return`: Завершает только текущий поток, но если это основной поток (например, в `main`), завершится весь процесс, включая другие потоки.

Основные атрибуты потока
1. Размер стека:
2. Положение стека:
3. Отделение от родительского процесса:
    - `PTHREAD_CREATE_JOINABLE` (по умолчанию) или `PTHREAD_CREATE_DETACHED`.
4. Политика планирования:
	- `SCHED_FIFO` (First In, First Out):
		- Поток выполняется до тех пор, пока он не завершится или не блокируется (например, при ожидании ввода/вывода).
		- Потоки с одинаковым приоритетом выполняются в порядке их создания.
	- `SCHED_RR` (Round Robin):
		- Потоки с одинаковым приоритетом выполняются по очереди на фиксированный промежуток времени (квант времени)
	- `SCHED_OTHER`:
		- Это стандартная политика планирования, используемая для обычных процессов, не относящихся к реальному времени. Обычно она основана на алгоритме CFS (Completely Fair Scheduler), который стремится обеспечить "справедливое" распределение процессорного времени между всеми потоками.
		- Потоки с этой политикой имеют более низкий приоритет по сравнению с потоками `SCHED_FIFO` и `SCHED_RR`.
		- Предоставляет эффективное управление процессорным временем, но не гарантирует выполнение в реальном времени.
5. Приоритет:
    - Устанавливает параметры планирования (включая приоритет) для потока.
    - Политика планирования должна поддерживать приоритеты (например, `SCHED_FIFO` и `SCHED_RR`).
    - Диапазон от 1 до 99, где 99 — наивысший приоритет.
    - Для `SCHED_OTHER` приоритеты обычно задаются системой.
6. Состояние потока:
    - Устанавливает, будет ли новый поток наследовать политику и приоритет планирования от родительского потока (`PTHREAD_INHERIT_SCHED`) или использовать свои собственные параметры (`PTHREAD_EXPLICIT_SCHED`).
7. Наследование атрибутов:
8. Оптимизация для обработки сигналов:
    - Устанавливает область видимости потоков.
    - Может быть `PTHREAD_SCOPE_SYSTEM` (системный уровень, потоки могут быть запланированы на различных процессорах. Это позволяет операционной системе более гибко управлять потоками, используя более сложные алгоритмы планирования, которые могут учитывать состояние других потоков, запущенных в системе) или `PTHREAD_SCOPE_PROCESS` (потоки в пределах одного процесса).

Если поток создан как joinable (присоединяемый):
	Когда другой поток вызывает `pthread_join()`, операционная система:
	- Ждёт завершения потока.
	- Освобождает его ресурсы (стэк, дескрипторы и другие структуры).
	Если вы не вызываете pthread_join() после завершения потока, ресурсы будут висеть в памяти (т.н. зомби-поток), пока процесс не завершится.

Если поток создан как detached (отсоединённый):
	Ресурсы освобождаются автоматически после его завершения. Ресурсы освобождаются ядром сразу по окончанию потока.

ОС отслеживает жизненный цикл каждого потока через несколько состояний:
- **Running (выполняется)** — поток активно выполняется на одном из процессоров.
- **Waiting (ожидание)** — поток заблокирован, ожидая завершения операции ввода-вывода или события (например, ожидание освобождения блокировки).
- **Terminated (завершён)** — поток завершил своё выполнение, но его ресурсы ещё не освобождены. В этом состоянии поток может находиться до тех пор, пока другой поток не вызовет `pthread_join()` (если поток joinable).

### pthread_cancel

`pthread_cancel()` — это функция, используемая для запроса завершения другого потока.
Когда один поток вызывает pthread_cancel() для другого потока, операционная система посылает запрос (механизм из pthread) на его завершение. Однако завершение не происходит немедленно.

Режимы отмены (Cancellation Modes):
1. **Отложенная отмена** (по умолчанию). Поток завершает своё выполнение только при достижении определённых точек отмены (cancellation points). Эти точки — это места, где поток может быть безопасно прерван. Примеры точек отмены: функции ввода-вывода, такие как `read()`, `write()`, `sleep()`, `pthread_cond_wait()`, `pthread_testcancel();`
	- `pthread_setcanceltype(PTHREAD_CANCEL_DEFERRED, NULL);`
2. **Асинхронная отмена**  — поток может быть прерван в любой момент, что делает отмену мгновенной. Однако это небезопасный режим, так как прерывание может произойти в критическом участке кода (например, при работе с общими данными), что может привести к непредсказуемому поведению и ошибкам.
	- `pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);`

Возможность отмены:
1. **Отменяемое состояние** (по умолчанию) — поток может быть отменён (это состояние).
	- `pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);`
2. **Неотменяемое состояние** — запросы на отмену будут игнорироваться.
	- `pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);`

Когда поток получает запрос на завершение, он может зарегистрировать **обработчики завершения** для правильного освобождения ресурсов и завершения.
``` c
void cleanup(void *arg) { 
	printf("Cleaning up: %s\n", (char *)arg); 
} 
pthread_cleanup_push(cleanup, "Thread finished"); // регистрирует обработчик
// ... критическая секция 
pthread_cleanup_pop(1); // удаляет его
```

`pthread_cond_wait()` — это функция в библиотеке POSIX Threads (pthreads), которая используется для ожидания выполнения некоторого условия, обычно связанного с изменением состояния программы. Она блокирует текущий поток до тех пор, пока не будет выполнено условие, связанное с определённой переменной состояния (условной переменной), которую другие потоки могут изменить и уведомить через вызов соответствующих сигналов. Как работает:
- Ожидание на условной переменной: Функция блокирует поток, который вызвал pthread_cond_wait(), и помещает его в очередь ожидания условной переменной. Поток остаётся заблокированным до тех пор, пока другой поток не вызовет одну из функций сигнализации (например, `pthread_cond_signal()` или `pthread_cond_broadcast()`), которая уведомит об изменении состояния, на которое поток ожидает.
- Работа с мьютексом: Для правильного использования `pthread_cond_wait()` необходимо передать мьютекс (второй аргумент), который защищает разделяемый ресурс или данные, связанные с условием. Поток должен владеть мьютексом перед вызовом `pthread_cond_wait()`. Когда поток входит в состояние ожидания, мьютекс автоматически разблокируется (освобождается), чтобы другие потоки могли работать с этим ресурсом. Как только поток возобновляет выполнение (после пробуждения), он снова захватывает мьютекс, чтобы продолжить работу с защищёнными данными.