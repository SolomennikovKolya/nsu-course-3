(Модели и методы искусственного интеллекта)

### Полезности
- [Гугл класс с лекциями](https://classroom.google.com/c/NzYwMTczMDE1MTYx)
- [Prolog online](https://swish.swi-prolog.org)
- [Гайд по Prolog](https://habr.com/ru/articles/552318/)

#### Лекции
- [x] 0. Введение в искусственный интеллект
- [x] 1. Логическая модель
- [x] 2. Основы логического программирования
- [x] 3. Сетевая модель
- [x] 4. Продукционная модель
- [x] 5. Представление нечетких знаний
- [ ] 6. Генетические алгоритмы
- [ ] 7. Использование языка PROLOG для построения интеллектуальных систем
- [ ] 8. Решение задач на вычислительных моделях
- [ ] 9. Недоопределённые вычислительные модели
- [ ] 10. Нейронные сети
- [ ] 11. Методы поиска решений 1
- [ ] 12. Методы поиска решений 2
- [ ] 13. Методы поиска решений 3
- [ ] 14. Введение в экспертные системы
- [ ] 15. Приобретение знаний в экспертных системах

### Введение в ИИ
#### Два подхода к моделированию мышления
1. *Символический подход*: Исторически был доминирующим подходом к моделированию интеллекта. Согласно этому подходу все интеллектуальные действия сводятся к оперированию символами или понятиями. Он включает построение формальных моделей и соответствующих им механизмов рассуждений
2. *Нейро-сетевой (нейрокибернетический подход)*: Является противоположностью символического подхода к исследованию и моделированию интеллекта. Основная идея этого направления: единственный объект, способный мыслить, — это человеческий мозг. Поэтому любое мыслящее устройство должно каким-то образом воспроизводить его структуру. Подход ориентирован на программно-аппаратное моделирование структур, подобных структуре мозга. Делается упор на создание элементов, аналогичных нейронам, и их объединение в функционирующие системы, т.е. в нейронные сети (НС)

#### Основные направления исследований в ИИ
- Представление знаний и моделирование рассуждений (построение моделей предметных областей, в конечном итоге - модели «мира», использование этих знаний и моделей при моделировании рассуждений, дескриптивные и другие логики)
- Понимание естественного языка:
	- машинный перевод
	- автоматическая обработка текстов на естественном языке (ЕЯ)
	- вопросно-ответные системы
	- взаимодействие с ЭВМ и роботами на ЕЯ
- Интеллектуальный поиск и анализ информации (Интернет, большие массивы документов, семантические технологии)
- Интеллектуальный анализ данных
- Машинное обучение и нейронные сети
- Экспертные системы и системы поддержки принятия решений
- Распознавание и синтез речи и изображений
- Робототехника (интеллектуальные роботы)

#### Представление знаний
Проблема представления знаний является одной из самых старых проблем. Она решается всякий раз, когда требуется передать кому-то знания и научить ими пользоваться (в нашем случае в качестве получателя знаний выступает ЭВМ).

При решении данной проблемы возникают два вопроса:
- "Что представлять?"
- "Как представлять?"

Если ответ на первый вопрос в основном определяется той конкретной задачей (классом задач), которую мы хотим решить, то с ответом на второй вопрос дело обстоит гораздо сложнее. Главная трудность здесь, по-видимому, состоит в том, что при решении этого вопроса приходится сталкиваться с различными противоречиями. Так, например, оказывается, что средства представления, удобные для человека, неэффективно реализуются на ЭВМ, а средства, эффективно реализуемые на ЭВМ, не всегда удобны для человека. Кроме того, для представления одних знаний больше подходят одни средства, для других - другие. В связи с этим разработано много различных средств представления знаний. Более того, они продолжают разрабатываться. 

Несмотря на такое многообразие средств представления знаний, их можно классифицировать, выделив три вида моделей:
- *Логическая модель*
- *Сетевая модель*
- *Продукционная модель*

### Логическая модель

**Логика предикатов первого порядка** (FOL - First-Order Logic) — это формальная система, расширяющая *логику высказываний* за счёт введения кванторов, предикатов и функций. Она позволяет выражать сложные утверждения о мире, включая свойства объектов и отношения между ними

#### Компоненты FOL
1. *Термы* - выражения, обозначающие объекты предметной области
	- *Константы* - обозначают конкретные объекты (`a`, `иван`, `5`)
	- *Переменные* - обозначают произвольные объекты (`X`, `Y`, `Person`)
	- *Функции* - возвращают объекты (`father(иван)`, `age(X) + 1`)
2. *Предикаты*  - выражают свойства объектов или отношения между ними:
	- Унарные предикаты - свойства (`человек(иван)`, `четное(4)`)
	- Многоарные предикаты - отношения (`родитель(иван, мария)`, `между(X, Y, Z)`)
3. *Атомы* (атомарные формулы) - простейшие утверждения, состоящие из предиката и термов (`любит(мария, мороженое)`, `больше(5, 3)`)
4. *Формулы*
	- Атом есть формула
	- Если F и G – формулы, то `не(F)`, `(F или G)`, `(F и G)`, `(если F то G)` и `(F <=> G)` – формулы
	- Если F – формула, а х – свободная переменная в F, то `(для любого x) F` и `(существует х) F` – формулы
	- Формулы порождаются только конечным числом применений правил 1,2,3


### Продукционная модель

Продукционная модель представления знаний — это один из подходов к формализации и структурированию знаний в системах искусственного интеллекта и экспертных системах. Она основана на использовании правил вида "ЕСЛИ условие, ТО действие", которые называются продукциями

#### Основные компоненты продукционной модели
1. **База правил (продукций)**:
    - Состоит из набора правил, каждое из которых имеет структуру:
        ЕСЛИ (условие), ТО (действие)
    - Условие — это логическое выражение, которое проверяется
    - Действие — это операция или вывод, который выполняется, если условие истинно
2. **База фактов**:
    - Содержит известные факты или данные, которые используются для проверки условий правил
3. **Механизм логического вывода**:
    - Определяет порядок применения правил и обработки фактов
    - Может работать в двух режимах
        - *Прямая цепочка рассуждений (Forward Chaining)* — от фактов к выводам
        - *Обратная цепочка рассуждений (Backward Chaining)* — от цели к фактам

### Prolog

**Пролог** — язык логического программирования (ПРОграммирование в ЛОГике). В основе языка — результаты по автоматизации доказательства теорем в исчислении предикатов первого порядка

#### Команды
- `swipl` - запуск интерпретатора
- `[main].` - запуск своего файла
- `ancestor(john, ann).` - пример запроса
- `halt.` - выход в терминал
- `make.`- перекомпилирует все загруженные файлы и обновит определения предикатов из них. Не удалит динамически добавленные факты, если они не были в исходнике

#### Элементы программы
- База знаний состоит из клаузов:
	1. *Факты* - простое утверждение, которое всегда истинно. Например: `woman(mia).` представляет собой логическое утверждение, что предикат `woman/1` истинен при аргументе `mia` (Мия это женщина)
	2. *Правила* - имеют вид "A если B". Пример: `playGuitar(mia) :- listenToMusic(mia)."` - Мия играет на гитаре, если Мия слушает музыку
- Запросы - вопросы к базе знаний

#### Термы
- *Атомы*:
	1. Последовательность строчных или прописных букв, цифр и символов подчерка, начинающаяся со строчной буквы
	2. Произвольная последовательность символов, заключённая в одинарные кавычки
	3. Последовательность спецсимволов
- *Числа*:
	1. Действительные числа: 2,718; 103,3087; π, . . .
	2. Целые числа: -2, -1, 0, 1, 2, . . .
- *Переменные*:
	- Служат для обозначения объектов, значения которых меняются в ходе выполнения программы
	- Имя переменной задается последовательностью строчных или прописных букв, цифр и символов подчерка, начинающейся с прописной буквы или символа подчерка
- *Составной терм*:
	- Состоит из функтора и последовательности аргументов в скобках:
	1. Имя функтора — это атом
	2. Переменная не может быть функтором
	3. Аргументы составного терма должны быть термами
- *Список*:
	- Это упорядоченный набор объектов любого типа
	- Обозначается квадратными скобками `[ ]`
	- Элементы разделяются запятыми
	- Может быть пустым ([]) или содержать элементы (`[a, b, c]`)
	- Список можно разделить (`[Head | Tail]`):
		- Голова (Head) — первый элемент списка
		- Хвост (Tail) — оставшаяся часть списка (все элементы, кроме первого)
	- У списка можно взять несколько голов сразу (`[X, Y, Z | Tail]`)

#### Встроенные предикаты
1. Логические и управляющие предикаты
	- **`not/1`** - отрицание (не доказуемо)
	- **`fail/0`** - тождественно ложный предикат
	- **`true/0`** - тождественно истинный предикат
	- **`cut/0`** или `!` - отсечение, предотвращает backtracking. Фиксирует все выборы, сделанные до него в текущем правиле
	- **`;/2`** - логическое "ИЛИ" (дизъюнкция)
2. Предикаты для работы с терминами
	- **`=/2`** - унификация (X = Y)
	- **`\=/2`** - проверка на не унифицируемость
	- **`==/2`** - проверка на идентичность терминов
	- **`\==/2`** - проверка на неидентичность
	- **`=../2`** - Преобразование между термом и списком
		- `Терм =.. [Функтор, Арг1, Арг2, ..., АргN]`
3. Арифметические предикаты
	- **`is/2`** - вычисление арифметического выражения (X is 2+3)
	- **`=:=/2`**, **`=\=/2`**, **`</2`**, **`>/2`**, **`=</2`**, **`>=/2`** - арифметические сравнения
	- **`random/1`**, **`random_between/3`** - генерация случайных чисел
4. Предикаты для работы со списками
	- **`member(Element, List)`** 
		- Проверка принадлежности элемента списку
		- `member(X, [a,b,c]).` выдаст поочерёдно `X = a`; `X = b`; `X = c`; `false.`
	- **`append/3`** - конкатенация списков
	- **`length/2`** - длина списка
	- **`select/3`** - выбор элемента из списка
	- **`maplist/2-8`** - применение предиката к элементам списка
5. Предикаты ввода/вывода
	- **`write/1`**, **`writeln/1`** - вывод термина
	- **`read/1`** - чтение термина
	- **`nl/0`** - вывод новой строки
	- **`open/3`**, **`close/1`**, **`read/2`**, **`write/2`** - работа с файлами
6. Предикаты высшего порядка
	- **`call/1`** - вызов цели
	- `findall(Template, Goal, List)`
		- Собирает все возможные `Template`, для которых `Goal` выполним. Не требует, чтобы все переменные в `Goal` были связаны
		- `findall(X, member(X, [a,b,a,c]), L).` => `L = [a, b, a, c].`
	- `bagof/3`, `setof/3` - другой сбор всех решений
	- `forall(Generator, Action).` - для всех истинных Generator запустит Action
	- **`clause/2`** - доступ к клаузам в базе данных
7. Мета-предикаты
	- **`var/1`**, **`nonvar/1`** - проверка типа терма
	- **`atom/1`**, **`integer/1`**, **`number/1`**, **`atomic/1`** - проверка типа
	- **`ground/1`** - проверка, что терм не содержит переменных
	- **`functor/3`** - доступ к имени и арности функтора
	- **`arg/3`** - доступ к аргументам терма
8. Предикаты для работы с базой данных
	- **`asserta/1`**, **`assertz/1`** - добавление клауз
	- **`retract/1`** - удаление клауз
	- **`abolish/1`** - удаление всех клауз для предиката
	- **`listing/0`**, **`listing/1`** - вывод всех клауз
9. Специальные предикаты (зависит от реализации)
	- **`between/3`** - генерация чисел в диапазоне
	- **`succ/2`** - инкремент/декремент для натуральных чисел
	- **`format/2-3`** - форматированный вывод (аналог printf)

#### Списки
Список в Prolog:
- Обозначается квадратными скобками `[ ]`
- Элементы разделяются запятыми
- Может быть пустым ([]) или содержать элементы (`[a, b, c]`)

Список можно разделить на:
- Голову (Head) — первый элемент списка
- Хвост (Tail) — оставшаяся часть списка (все элементы, кроме первого)
Синтаксис: `[Head | Tail]` 

#### Пары
В Prolog записи вида `X-Y` называются парами, и это просто синтаксический сахар. То есть `X-Y` это то же самое что `'-'(X, Y)`

#### Основа
Prolog основан на логике предикатов первого порядка, точнее — на её ограниченном и программируемом подмножестве, называемом Horn-логикой. Horn-формулы — это такие дизъюнкты, в которых максимум один положительный литерал:
`A :- B1, B2, ..., Bn.`

Предикат — логическое утверждение или правило. Он говорит, что является истино. Примеры предикатов:
`father(john, mia).` - факт
`likes(mia, X) :- actor(X).` - правило

Функтор — это имя структурированного терма (данных). Он не говорит о логике, а просто передаёт структуру. Примеры функторов:
`likes(mia, movie(title(pulp_fiction), year(1994))).`

#### Динамические предикаты
По умолчанию в Prolog все факты и правила статичны — их нельзя добавлять, удалять или менять во время выполнения программы
`:- dynamic ...` - директива, разрешающая изменять содержимое предиката в рантайме
Это даёт возможность добавлять и удалять факты:
`assertz(language(python, [...])).`
`retract(language(python, _)).`

### Онтологии

**Онтология** — это формализованная, явная спецификация концептуализации,  
реализованная на логическом формализме, поддерживающая вывод и верификацию. То есть это формальная спецификация понятий и отношений в некоторой предметной области. Она определяет:
- что существует (понятия, классы)
- как это связано (роли, отношения)
- какие существуют ограничения (ограничения на свойства, иерархии, аксиомы)
- как об этом можно логически рассуждать

#### Состав онтологии
1. Классы (концепты)
2. Индивидуумы (экземпляры)
3. Свойств (отношения):
    ├── Object properties (между индивидуумами)
    └── Data properties (между индивидуумом и значением)
4. Аксиом (axioms):
    ├── TBox — о классах
    ├── RBox — о свойствах
    └── ABox — о индивидуальных объектах

##### Классы (classes)
- Абстрактные категории: `Человек`, `Студент`, `Организация`
- Формируют иерархии, ограничения, эквивалентности

Формально, класс в онтологии (OWL или Description Logic) — это множество экземпляров (индивидуумов), обладающих общими свойствами. Пример:
`Студен - подкласс Человек` <-> `:Студент rdfs:subClassOf :Человек .` <->
`Студент ⊑ Человек` <-> `∀x (x ∈ Студент → x ∈ Человек)`

##### Индивидуумы (individuals)
- Конкретные объекты: `Иван`, `МГУ`
- Относятся к классам
- Связаны между собой через отношения и атрибуты

##### Свойства (properties)
Свойства применимы к индивидуумам, так как классы и индивидуумы живут на разных уровнях (метауровнях). Свойства разделяются на два вида:

| Тип               | Что описывает             | Пример                         |
| ----------------- | ------------------------- | ------------------------------ |
| Object properties | Связи между индивидуумами | `учитсяВ`, `являетсяРодителем` |
| Data properties   | Связи с данными           | `имеетВозраст`, `имеетИмя`     |

Данные - это скалярные значения (литералы) из типизированных доменов

##### Аксиомы
В OWL-онтологии аксиомы — это ядро семантики, без них она превращается просто в иерархию терминов без логики
1. TBox-аксиомы — факты о классах. Определяют структуру понятий. Формируют терминологическую часть онтологии (TBox)
2. RBox-аксиомы — факты о свойствах. Описывают свойства и поведение отношений между объектами
3. ABox-аксиомы — факты об экземплярах. Конкретные утверждения о реальных индивидуальных объектах

| Тип                     | Пример                                         |
| ----------------------- | ---------------------------------------------- |
| Подкласс (subClassOf)   | `Студент ⊑ Человек`                            |
| Эквивалентность классов | `Мужчина ≡ Человек ⊓ имеетПол value "мужской"` |
| Дизъюнктность           | `Мужчина ⊥ Женщина` (взаимоисключающие классы) |
| Ограничения             | `Студент ⊑ ∃обучается.ВУЗ`                     |

| Тип                         | Пример                                      |
| --------------------------- | ------------------------------------------- |
| Свойство функционально      | `FunctionalObjectProperty(имеетМать)`       |
| Симметричность              | `SymmetricObjectProperty(являетсяСупругом)` |
| Обратные свойства           | `являетсяРодителем` ↔ `являетсяРебенком`    |
| Свойство имеет домен и ранг | `домен(учится) = Студент`, `range = ВУЗ`    |

| Тип                     | Пример                  |
| ----------------------- | ----------------------- |
| Тип объекта             | `Иван rdf:type Студент` |
| Объектное свойство      | `Иван учитсяВ МГУ`      |
| Атрибут (data property) | `Иван имеетВозраст 21`  |

В OWL (Turtle-синтаксис) каждая конструкция, заканчивающаяся точкой (`.`), — это RDF-тройка, а любая RDF-тройка в OWL-онтологии — это семантически аксиома. Примеры:

| RDF-тройка в OWL                               | Что это за аксиома?                  |
| ---------------------------------------------- | ------------------------------------ |
| `:Иван rdf:type :Человек .`                    | ABox (индивидуум — экземпляр класса) |
| `:Студент rdfs:subClassOf :Человек .`          | TBox (иерархия классов)              |
| `:имеетМать rdf:type owl:FunctionalProperty .` | RBox (ограничение на свойство)       |
| `:Студент owl:equivalentClass ...`             | TBox (эквивалентность классов)       |
| `:Иван :являетсяРодителем :Мария .`            | ABox (связь между индивидуумами)     |

#### Зачем нужны онтологии
- Создать общий словарь для людей и машин
- Обеспечить интероперабельность между системами
- Поддерживать логический вывод, валидацию и проверку знаний
- Повысить переносимость знаний между платформами и контекстами
- Стандартизировать знания для Semantic Web, баз знаний, систем ИИ

#### Чем различаются онтологии

##### 1. По логическому ядру / формализму

| Ядро                 | Характеристика                                    |
| -------------------- | ------------------------------------------------- |
| Логика описаний (DL) | Поддерживает вывод, OWL-онтологии                 |
| FOL                  | Большая выразительность, но тяжелее вычислительно |
| Без формализма       | Только визуальные/понятийные связи                |
##### 2. По степени общности (глубине абстракции)

| Тип онтологии             | Описание                                     | Пример                            |
| ------------------------- | -------------------------------------------- | --------------------------------- |
| Онтология верхнего уровня | Общие понятия, применимые в любой области    | DOLCE, SUMO                       |
| Онтология домена          | Понятия конкретной области                   | Медицинская (SNOMED), юридическая |
| Онтология задачи          | Описывает шаги решения задачи                | Диагностика, планирование         |
| Онтология приложений      | Частные, специфичные, для конкретной системы | OWL-онтология для базы данных     |
##### 3. По способу реализации

| Способ              | Примеры                                          |
| ------------------- | ------------------------------------------------ |
| RDF / OWL           | Semantic Web, Protégé, GraphDB                   |
| XML                 | Более простой, человекочитаемый формат           |
| Neo4j / Cypher      | Онтологии как графовые БД                        |
| Табличные модели    | Простые внутренние онтологии (например, в Excel) |
| Словари / глоссарии | Частично структурированные онтологии             |
#### Почему онтологии популярнее других средств представления знаний

| Причина                                    | Объяснение                                                     |
| ------------------------------------------ | -------------------------------------------------------------- |
| Стандартизация (OWL, RDF)                  | Поддерживаются W3C, совместимы с системами интероперабельности |
| Поддержка логического вывода               | Позволяют получать непрямые знания, проверять консистентность  |
| Формальность + читаемость                  | Понятны как человеку, так и машине                             |
| Широкая поддержка инструментов             | Protégé, GraphDB, Owlready2, SPARQL, Reasoners                 |
| Расширяемость и повторное использование    | Возможность наращивать онтологии и связывать их между собой    |
| Устойчивость к изменениям структуры знаний | Можно изменять аксиоматику без пересборки всей базы            |

Онтологии — универсальное средство представления знаний. Онтологии объединяют:
- символичность (классы, свойства, индивиды)
- формальность (логическое ядро)
- машинную интерпретируемость (например, OWL)
- интероперабельность (стандарты RDF/OWL)   
- объяснимость (можно визуализировать, интерпретировать, проверять)   

Онтологии — это единственное средство, одновременно пригодное для людей и машин, поддерживающее вывод, расширяемость, обмен и логическую строгость

Другие подобные универсальные средства:

| Средство              | Поддержка вывода  | Интерпретируемость | Стандартизация | Универсальность |
| --------------------- | ----------------- | ------------------ | -------------- | --------------- |
| Онтологии (OWL)       | ✅ Полный DL-вывод | ✅ Да               | ✅ Да (W3C)     | ✅ Максимум      |
| Продукционные системы | ✅ Частично        | ✅ Да               | ❌ Нет          | 🟡 Ограниченно  |
| Фреймы                | ❌ Нет             | ✅ Да               | ❌ Нет          | 🟡 Ограниченно  |
| Семантические сети    | ❌ Нет             | ✅ Да               | ❌ Частично     | 🟡 Ограниченно  |
| Нечёткие системы      | 🟡 Частично       | ❌ Ограниченная     | ❌ Нет          | ❌ Ограничено    |

#### DL

**Description Logic (DL, логика описаний)** — это семейство формальных логик, предназначенных для структурированного представления знаний о концептах (классах), объектах (индивидуумах) и отношениях между ними. DL лежит в основе языка OWL, а значит — в основе онтологий семантического веба и интеллектуальных систем

Основные цели DL:
- Структурировать знания в терминах классов и свойств
- Обеспечить логический вывод: вывод новых фактов, проверку согласованности, классификацию
- Быть достаточно формальной и выразительной, но при этом вычислимо эффективной (в отличие от полной логики предикатов)

Основные строительные блоки DL:

| Элемент    | Назначение                | Пример                        |
| ---------- | ------------------------- | ----------------------------- |
| Концепт    | Класс (тип объектов)      | `Человек`, `Студент`          |
| Роль       | Отношение между объектами | `обучаетсяВ`, `имеетРодителя` |
| Индивидуум | Конкретный объект         | `Иван`, `МГУ`                 |

DL позволяет комбинировать концепты и роли:

|Операция|Обозначение|Пример|
|---|---|---|
|Пересечение|`C ⊓ D`|`Студент ⊓ Женщина`|
|Объединение|`C ⊔ D`|`Мужчина ⊔ Женщина`|
|Отрицание|`¬C`|`¬Животное`|
|Существование роли|`∃R.C`|`∃обучаетсяВ.Университет`|
|Универсальность по роли|`∀R.C`|`∀обучаетсяВ.Университет`|
|Кардинальные ограничения|`≥ n R`, `≤ n R`|`≥2 имеетДетей`, `≤1 обучаетсяВ`|

Пример DL-описания:
“Студент — это человек, который учится хотя бы в одном университете”
`Студент ⊑ Человек ⊓ ∃обучаетсяВ.Университет`

Ключевые отличия DL от FOL, обеспечивающие разрешимость:

| №   | Категория             | FOL — логика предикатов             | DL — логика описаний                                |
| --- | --------------------- | ----------------------------------- | --------------------------------------------------- |
| 1   | Общая выразительность | Очень высокая (Turing-полна)        | Ограничена — только то, что нужно для вывода        |
| 2   | Типы предикатов       | Любая арность (n-местные отношения) | Только унарные (концепты) и бинарные (роли)         |
| 3   | Функции и термы       | Допустимы (f(x), g(y))              | Исключены полностью                                 |
| 4   | Явные переменные      | Есть и свободные, и связанные       | Нет переменных — всё выражается через классы и роли |
| 5   | Кванторы              | Произвольные ∀, ∃ + логика          | Только ∃ и ∀ по ролевым ограничениям                |
| 6   | Рекурсия и замыкание  | Разрешены                           | Запрещены или строго ограничены                     |
| 7   | Вывод                 | В общем случае неразрешим           | В DL — разрешим, алгоритмы завершатся               |
| 8   | Цель                  | Общая логическая формализация       | Структурированное и решаемое описание знаний        |

#### RDF и RDFS

**RDF (Resource Description Framework)** — это модель представления знаний в виде графа утверждений (subject–predicate–object)

Каждое знание в RDF записывается как тройка:
`<субъект> <свойство> <объект>`
`<Иван> <учитсяВ> <МГУ>` - пример
`:Иван :учитсяВ :МГУ .` - пример в Turtle-синтаксисе

**RDFS (RDF Schema)** — это надстройка над RDF, которая позволяет:
- определять типы объектов (классы)
- задавать иерархии классов и свойств
- задавать домен (область определения) и ранг (множество значений) для свойств

Пример с RDFS:
```
:Человек rdf:type rdfs:Class .
:Студент rdf:type rdfs:Class .
:Студент rdfs:subClassOf :Человек .

:учитсяВ rdf:type rdf:Property .
:учитсяВ rdfs:domain :Студент .
:учитсяВ rdfs:range :Университет .
```

Конструкции в RDFS:
- `rdfs:Class` — задать класс (тип): `Студент` — класс
- `rdf:type` — принадлежность объекта к классу: `Иван rdf:type Студент`
- `rdfs:subClassOf` — иерархия классов
- `rdfs:domain`, `rdfs:range` — указание, к каким классам относится свойство

#### OWL

**OWL** — это формальный язык описания онтологий, разработанный W3C (World Wide Web Consortium — организация, которая разрабатывает и внедряет технологические стандарты для Всемирной паутины) для нужд Semantic Web. Он позволяет структурировано и логически описывать знания о предметной области так, чтобы с ними могли работать как люди, так и программы, включая автоматические reasoner’ы

OWL предназначен для описания классов, отношений, свойств и ограничений между объектами, с возможностью автоматического логического вывода

OWL основан на логике описаний (Description Logic) — подмножестве логики предикатов первого порядка. Это даёт ему выразительность, формальную семантику и разрешимость вывода. OWL расширяет RDF и RDFS, добавляя возможности для ограничений, аксиом, иерархий

Архитектура OWL:

| Уровень | Назначение                                                     |
| ------- | -------------------------------------------------------------- |
| RDF     | Базовая модель графа: субъект–предикат–объект                  |
| RDFS    | Базовая онтологическая семантика (классы, подклассы, свойства) |
| OWL     | Язык для расширенного описания понятий и отношений             |
| OWL DL  | Подмножество OWL, полностью соответствующее DL                 |
| DL      | Формальная семантика OWL DL                                    |

Пример (в Turtle-нотации):
```
:Человек rdf:type owl:Class .
:Студент rdf:type owl:Class .
:Студент rdfs:subClassOf :Человек .

:обучается rdfs:domain :Студент .
:обучается rdfs:range :Университет .

:Иван rdf:type :Студент .
:МГУ rdf:type :Университет .
:Иван :обучается :МГУ .
```

Варианты OWL:

| Версия   | Особенности                                             |
| -------- | ------------------------------------------------------- |
| OWL Lite | Упрощённый, с ограниченной выразительностью             |
| OWL DL   | Основная версия, основана на логике описаний, разрешима |
| OWL Full | Наиболее гибкая, но вывод может быть неразрешим         |
На практике чаще всего используют OWL DL, так как он балансирует между выразительностью и вычислительной разрешимостью

### Функциональные сети

**Функциональные сети** — это разновидность сетевых моделей представления знаний, в которых акцент сделан на функциональные связи между понятиями или объектами. Такие сети описывают «что делает что», «что для чего нужно», и «как одно влияет на другое». Это удобно для моделирования целей, задач, функциональной структуры систем и взаимодействия компонентов

Цель - отразить функциональную структуру предметной области, где важны:
- предназначение элементов
- целеполагание
- зависимости между функциями

### Задания

#### 4. Protege
Цель задания - знакомство с редактором Protege. Создать иерархию классов. Ввести атрибуты (Data properties) Имя, Возраст, Пол, ... Создать родственные отношения (Object properties) являетсяРодителем, является Ребенком, являетсяСупругом, ... Для некоторых атрибутов и отношений задать свойства (функциональность, симметричность, транзитивность...). Определить аксиомы. Ввести индивиды  (не менее 10 человек, не менее 3-х поколений). Продемонстрировать работу машины вывода.

#### 8. Экспертная система на Prolog

Разработать средствами языка Prolog Экспертную Систему (ЭС) для консультирования пользователя в выбранной предметной области
  
Подзадачи:  
1. Выбор предметной области ЭС
2. Выбор класса ЭС по типу решаемых задач: диагностика, классификация, консультирование, прогнозирование, обучение, планирование
3. Разработка системы понятий, включающей не менее 15 диагностируемых ситуаций (классов, болезней, неисправностей и т.д.)  
4. Разработка подсистемы объяснений. Данная подсистема должна уметь объяснять полученное решение (на основе каких признаков получен именно такой результат) и отвечать на вопрос о признаках любого диагностируемого класса (болезни,  
неисправности, ...). Объяснение решения нужно выдавать сразу после печати ответа.  
Перед тем, как задать вопрос, признаки какого объекта хочет узнать пользователь, нужно выдать список всех объектов
5. Реализация ЭС средствами языка Prolog. Ключевой функционал в коде должен сопровождаться поясняющими комментариями
6. Разработать краткое описание ЭС, где указать: предметную область, класс ЭС и перечислить понятия предметной области

Замечание: Система должна учитывать, что ввёл пользователь

##### Экспертная система подбора языка программирования 

*Предметная область*: Подбор наиболее подходящего языка программирования на основе целей и предпочтений пользователя 

*Класс ЭС*: Консультирование 

*Понятия предметной области*: C, C++, Java, Python, Go, Rust, C#, Swift, Kotlin, Dart, JavaScript, TypeScript, PHP, HTML, CSS, R, Julia, MATLAB, Lua, GDScript, Assembly, Ada, VHDL, Verilog, Haskell, Scheme, OCaml, Prolog, Erlang, Elixir

*Критерии*: 
1. Сфера использования языка: 
	- `general_purpose` - универсальные языки общего назначения
	- `web` - веб-разработка 
	- `mobile` - мобильная разработка 
	- `systems` - системное / низкоуровневое программирование 
	- `data` - анализ данных / ML / AI
	- `games` - разработка игр
	- `academic` - обучение, исследование
2. Целевая платформа:
	- `desktop` - ПК (приложения, запускаемые на персональных компьютерах с графическим интерфейсом)
	- `mobile` - мобильные устройства
	- `server` - серверы
	- `browser` - браузеры
	- `native` - аппаратно-ориентированная среда (программы, компилируемые в машинный код и выполняемые напрямую на железе)
	- `cross_platform` - приложения, ориентированные на запуск на разных типах устройств без изменения кода
3. Парадигма программирования:
	- `imperative` - императивное программирование (указывается последовательность выполняемых действий)
		- `oop` - объектно-ориентированное программирование
		- `procedural` - процедурное программирование (последовательно выполняемые операторы можно собрать в подпрограммы)
	- `declarative` - декларативное программирование (разработчик описывает результат, то есть что именно он хочет получить от кода, что должно сделать приложение)
		- `functional` - функциональное программирование
		- `logical` - логическое программирование
4. Компилируемый, интерпретируемый или транслируемый язык:
	- `compiled` - компилируемый язык
	- `interpreted` - интерпретируемый язык
	- `bytecode_vm` - язык транслируется в байт-код
	- `transpiled` - транслируется в другой язык программирования, обычно более низкого уровня или более широко поддерживаемый
5. Виды типизации:
	- По времени проверки типов:
		- `static_typing` - статическая типизация (типы проверяются во время компиляции)
		- `dynamic_typing` - динамическая типизация (типы проверяются во время выполнения)
	- По строгости проверки типов:
		- `strong_typing` - сильная типизация (язык строго разграничивает типы и запрещает неявные преобразования)
		- `weak_typing` - слабая типизация (язык допускает неявные или нестрогие преобразования между типами)
	- По аннотации типов:
		- `explicit_typing` - явная аннотация типов (программист обязан указывать типы)
		- `implicit_typing` - неявная аннотация типов (типы выводятся автоматически)
6. Дополнительные критерии (ответ - да / нет):
	- `garbage_collector` - наличие сборщика мусора
	- `package_manager` - наличие официального менеджера пакетов
	- `official_toolchain` - наличие официального инструментария
	- `manual_memory_management` - наличие поддержки работы с памятью вручную
	- `generics_support` - наличие поддержки generics (обобщений)

#### 9. Semp-Tao

Ниже выложены мануал, презентация и архив с дистрибутивом Semp-Tao. Нужно реализовать правила, определяющие родственные отношения. Какие отношения кому необходимо реализовать, указано в файле Родственные отношения.doc. Эти правила можно встроить в программу (файлы rodst.dm, rodst_short.pm). Схема родственных отношений приведена в презентации. Желающие могут ввести данные о своих   родственниках.

Файлы:
- `.dm` - модуль определений (data model): описание предметной области
- `.pm` - модуль продукций (process model): программа/модель поведения
- `rodst.dm` - описание классов, типов, отношений (модель мира)
- `rodst_short.pm` - логика обработки знаний, интерфейс, правила вывода

#### 10. Разработка экспертной системы в среде Semp-Tao

Диагностируемые объекты (варианты напитков):
1. Вода
2. Газировка
3. Сок
4. Молоко
5. Кефир
6. Кофе
7. Чай
8. Какао
9. Энергетик
10. Компот
11. Лимонад
12. Квас
13. Йогурт
14. Глинтвейн
15. Холодный чай
16. Минеральная вода
17. Шоколадный напиток

Признаки напитков:
- Вкус: сладкий / несладкий / кислый
- Температура употребления: горячий / холодный
- Содержит кофеин: да / нет
- Молочный: да / нет
- Освежает: да / нет
- Подходит детям: да / нет
- Укрепляет иммунитет: да / нет
- Подходит для утра / вечера
- Натуральный: да / нет

Пример запросов:
- "Хочу что-то бодрящее и горячее"  
    → Кофе или чай
- "Что-то холодное и сладкое без кофеина"  
    → Сок, лимонад, компот
- "Напиток без сахара и без кофеина"  
    → Вода, минеральная вода, кефир

Подсистема объяснений:
- После выбора система сообщает:
    - "Выбран кофе, потому что вы указали: горячее, бодрящее, с кофеином"
- Также можно запросить:
    - "Что за напиток какао?"  
        → система выведет его свойства

