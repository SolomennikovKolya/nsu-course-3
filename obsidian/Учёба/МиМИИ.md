(Модели и методы искусственного интеллекта)

### Полезности
- [Гугл класс с лекциями](https://classroom.google.com/c/NzYwMTczMDE1MTYx)
- [Prolog online](https://swish.swi-prolog.org)
- [Гайд по Prolog](https://habr.com/ru/articles/552318/)

task8 - система должна учитывать, что ввёл пользователь

Логическая модель
Сетевая модель
Система Поста
Нормальные алгоритмы Маркова
Формальные грамматики

#### Основные модели представления знаний
- Логическая модель
- Сетевая модель
- Продукционная модель

### Логическая модель

**Логика предикатов первого порядка** (FOL - First-Order Logic) — это формальная система, расширяющая *логику высказываний* за счёт введения кванторов, предикатов и функций. Она позволяет выражать сложные утверждения о мире, включая свойства объектов и отношения между ними

#### Компоненты FOL
1. *Термы* - выражения, обозначающие объекты предметной области
	- *Константы* - обозначают конкретные объекты (`a`, `иван`, `5`)
	- *Переменные* - обозначают произвольные объекты (`X`, `Y`, `Person`)
	- *Функции* - возвращают объекты (`father(иван)`, `age(X) + 1`)
2. *Предикаты*  - выражают свойства объектов или отношения между ними:
	- Унарные предикаты - свойства (`человек(иван)`, `четное(4)`)
	- Многоарные предикаты - отношения (`родитель(иван, мария)`, `между(X, Y, Z)`)
3. *Атомы* (атомарные формулы) - простейшие утверждения, состоящие из предиката и термов (`любит(мария, мороженое)`, `больше(5, 3)`)
4. *Формулы*
	- Атом есть формула
	- Если F и G – формулы, то `не(F)`, `(F или G)`, `(F и G)`, `(если F то G)` и `(F <=> G)` – формулы
	- Если F – формула, а х – свободная переменная в F, то `(для любого x) F` и `(существует х) F` – формулы
	- Формулы порождаются только конечным числом применений правил 1,2,3


### Продукционная модель

Продукционная модель представления знаний — это один из подходов к формализации и структурированию знаний в системах искусственного интеллекта и экспертных системах. Она основана на использовании правил вида "ЕСЛИ условие, ТО действие", которые называются продукциями

#### Основные компоненты продукционной модели
1. **База правил (продукций)**:
    - Состоит из набора правил, каждое из которых имеет структуру:
        ЕСЛИ (условие), ТО (действие)
    - Условие — это логическое выражение, которое проверяется
    - Действие — это операция или вывод, который выполняется, если условие истинно
2. **База фактов**:
    - Содержит известные факты или данные, которые используются для проверки условий правил
3. **Механизм логического вывода**:
    - Определяет порядок применения правил и обработки фактов
    - Может работать в двух режимах
        - *Прямая цепочка рассуждений (Forward Chaining)* — от фактов к выводам
        - *Обратная цепочка рассуждений (Backward Chaining)* — от цели к фактам

### Prolog

**Пролог** — язык логического программирования (ПРОграммирование в ЛОГике). В основе языка — результаты по автоматизации доказательства теорем в исчислении предикатов первого порядка

#### Элементы программы
- База знаний состоит из клаузов:
	1. *Факты* - простое утверждение, которое всегда истинно. Например: `woman(mia).` - Мия это женщина
	2. *Правила* - имеют вид "A если B". Пример: `playGuitar(mia) :- listenToMusic(mia)."` - Мия играет на гитаре, если Мия слушает музыку
- Запросы - вопросы к базе знаний

#### Термы
- *Атомы*:
	1. Последовательность строчных или прописных букв, цифр и символов подчерка, начинающаяся со строчной буквы
	2. Произвольная последовательность символов, заключённая в одинарные кавычки
	3. Последовательность спецсимволов
- *Числа*:
	1. Действительные числа: 2,718; 103,3087; π, . . .
	2. Целые числа: -2, -1, 0, 1, 2, . . .
- *Переменные*:
	- Служат для обозначения объектов, значения которых меняются в ходе выполнения программы
	- Имя переменной задается последовательностью строчных или прописных букв, цифр и символов подчерка, начинающейся с прописной буквы или символа подчерка
- *Составной терм*:
	- Состоит из функтора и последовательности аргументов в скобках:
	1. Имя функтора — это атом
	2. Переменная не может быть функтором
	3. Аргументы составного терма должны быть термами
- *Список*:
	- Это упорядоченный набор объектов любого типа
	- Обозначается квадратными скобками `[ ]`
	- Элементы разделяются запятыми
	- Может быть пустым ([]) или содержать элементы (`[a, b, c]`)
	- Список можно разделить (`[Head | Tail]`):
		- Голова (Head) — первый элемент списка
		- Хвост (Tail) — оставшаяся часть списка (все элементы, кроме первого)
	- У списка можно взять несколько голов сразу (`[X, Y, Z | Tail]`)

#### Встроенные предикаты
1. Логические и управляющие предикаты
	- **`not/1`** - отрицание (не доказуемо)
	- **`fail/0`** - тождественно ложный предикат
	- **`true/0`** - тождественно истинный предикат
	- **`cut/0`** или `!` - отсечение, предотвращает backtracking. Фиксирует все выборы, сделанные до него в текущем правиле
	- **`;/2`** - логическое "ИЛИ" (дизъюнкция)
2. Предикаты для работы с терминами
	- **`=/2`** - унификация (X = Y)
	- **`\=/2`** - проверка на не унифицируемость
	- **`==/2`** - проверка на идентичность терминов
	- **`\==/2`** - проверка на неидентичность
	- **`=../2`** - преобразование между термом и списком (functor и аргументы)
3. Арифметические предикаты
	- **`is/2`** - вычисление арифметического выражения (X is 2+3)
	- **`=:=/2`**, **`=\=/2`**, **`</2`**, **`>/2`**, **`=</2`**, **`>=/2`** - арифметические сравнения
	- **`random/1`**, **`random_between/3`** - генерация случайных чисел
4. Предикаты для работы со списками
	- **`member/2`** - проверка принадлежности элемента списку
	- **`append/3`** - конкатенация списков
	- **`length/2`** - длина списка
	- **`select/3`** - выбор элемента из списка
	- **`maplist/2-8`** - применение предиката к элементам списка
5. Предикаты ввода/вывода
	- **`write/1`**, **`writeln/1`** - вывод термина
	- **`read/1`** - чтение термина
	- **`nl/0`** - вывод новой строки
	- **`open/3`**, **`close/1`**, **`read/2`**, **`write/2`** - работа с файлами
6. Предикаты высшего порядка
	- **`call/1`** - вызов цели
	- **`findall/3`**, **`bagof/3`**, **`setof/3`** - сбор всех решений
	- **`forall/2`** - проверка для всех случаев
	- **`clause/2`** - доступ к клаузам в базе данных
7. Мета-предикаты
	- **`var/1`**, **`nonvar/1`** - проверка типа терма
	- **`atom/1`**, **`integer/1`**, **`number/1`**, **`atomic/1`** - проверка типа
	- **`ground/1`** - проверка, что терм не содержит переменных
	- **`functor/3`** - доступ к имени и арности функтора
	- **`arg/3`** - доступ к аргументам терма
8. Предикаты для работы с базой данных
	- **`asserta/1`**, **`assertz/1`** - добавление клауз
	- **`retract/1`** - удаление клауз
	- **`abolish/1`** - удаление всех клауз для предиката
	- **`listing/0`**, **`listing/1`** - вывод всех клауз
9. Специальные предикаты (зависит от реализации)
	- **`between/3`** - генерация чисел в диапазоне
	- **`succ/2`** - инкремент/декремент для натуральных чисел
	- **`format/2-3`** - форматированный вывод (аналог printf)

#### Списки

Список в Prolog:
- Обозначается квадратными скобками `[ ]`
- Элементы разделяются запятыми
- Может быть пустым ([]) или содержать элементы (`[a, b, c]`)

Список можно разделить на:
- Голову (Head) — первый элемент списка
- Хвост (Tail) — оставшаяся часть списка (все элементы, кроме первого)
Синтаксис: `[Head | Tail]`  
