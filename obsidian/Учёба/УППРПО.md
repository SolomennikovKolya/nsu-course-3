(Управление производственным процессом разработки программного обеспечения)

## Теория

### Методологий разработки ПО

| Год       | Методология                         | Краткое описание                                                                  | Зачем нужна / цель                                                                          |
| --------- | ----------------------------------- | --------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| 1950–1970 | Code & Fix                          | Разработка без чёткого плана: код → тест → исправление                            | Использовалась на заре программирования, когда ПО было простым и команды — маленькими       |
| 1970      | Waterfall (каскадная)               | Линейный процесс: Анализ → Проектирование → Реализация → Тестирование → Поддержка | Для крупных, предсказуемых проектов с фиксированными требованиями                           |
| 1980–1990 | V-Model                             | Улучшенный Waterfall с жёсткой связкой между этапами и тестированием              | Стандартизованная модель для сертифицируемых и регламентированных систем (военка, медицина) |
| 1986      | Spiral Model                        | Итеративная модель с анализом рисков на каждом витке                              | Для сложных проектов с высокими рисками — объединила каскадный подход с итерациями          |
| 1991      | Rapid Application Development (RAD) | Быстрая разработка с использованием прототипов, меньший акцент на планирование    | Подходит для приложений с быстро меняющимися требованиями                                   |
| 1995      | Extreme Programming (XP)            | Инженерная Agile-методология: TDD, парное программирование, CI                    | Для улучшения качества и гибкости на уровне кода                                            |
| 2001      | Agile (манифест)                    | Философия: итерации, адаптация, взаимодействие, результат                         | Противодействие "тяжёлым" процессам. Для гибкой работы с изменяющимися требованиями         |
| 2001      | Scrum                               | Agile-метод с фиксированными ролями, спринтами и событиями                        | Организация командной работы и циклической поставки продукта                                |
| 2004      | Kanban (в ИТ)                       | Визуальное управление задачами, ограничение WIP                                   | Оптимизация потока задач и устранение узких мест                                            |
| 2009      | SAFe (Scaled Agile Framework)       | Расширение Agile/Scrum на уровне больших организаций                              | Согласование работы множества команд на уровне всей компании                                |
| 2011      | DevOps                              | Культура и практики объединения разработки и эксплуатации                         | Ускорение доставки, автоматизация, непрерывная интеграция и доставка                        |
| 2015+     | Lean Software Development           | Принципы "бережливого" производства, адаптированные под ИТ                        | Минимизация потерь, ценность для пользователя, постоянное улучшение                         |
| 2019+     | Agile@Scale / Nexus / LeSS          | Модели масштабирования Agile на десятки команд                                    | Управление большими программами с множеством зависимостей                                   |

#### Примечания
- В реальности многие компании комбинируют методологии
- Современные подходы — это Agile + DevOps + Lean (например, CI/CD в Scrum-процессе)
- Некоторые старые подходы (например, Waterfall) до сих пор применяются, если требования стабильны и формализованы (госзаказы, финтех, критические системы)

![[ChatGPT Image 20 апр. 2025 г., 16_35_32.png]]

#### Agile
- Что это: Общий подход (философия) к разработке программного обеспечения, основанный на гибкости, итерациях и обратной связи от заказчика. Это набор принципов и ценностей. Он был создан как альтернатива громоздким методологиям типа Waterfall (каскадной модели), где проект строго делился на фазы: анализ → проектирование → реализация → тестирование → внедрение
- 4 ключевые ценности:
	1. Людей и взаимодействие — выше процессов и инструментов
	2. Работающее ПО — выше исчерпывающей документации
	3. Сотрудничество с заказчиком — выше согласования условий контракта
	4. Готовность к изменениям — выше следования первоначальному плану
- 12 принципов Agile (сокращённо):
	1. Удовлетворение клиента — путём ранней и постоянной поставки ценного ПО
	2. Приветствуем изменения требований, даже на поздних этапах
	3. Частая поставка рабочего ПО (недели/месяцы)
	4. Бизнес и разработка должны работать вместе ежедневно
	5. Проекты строятся вокруг мотивированных людей
	6. Личное общение — лучший способ передачи информации
	7. Рабочее ПО — главный показатель прогресса
	8. Постоянное внимание к техническому совершенству
	9. Простота — искусство максимизации незавершённой работы
	10. Самоорганизующиеся команды дают лучший результат
	11. Команды регулярно рефлексируют и улучшаются
	12. Постоянный устойчивый темп разработки

#### Scrum
- Что это: Конкретная реализация Agile. Это фреймворк для гибкой разработки программного обеспечения. Он используется для управления сложной работой, фокусируясь на постоянной поставке ценности, самоорганизации команды и итеративном подходе
- Подходит: Когда проект развивается поэтапно и есть понятные требования
- Ключевые элементы:
	- Спринты (обычно 1–4 недели) — фиксированные итерации
	- Роли: 
		- Product Owner - Представляет интересы заказчика, управляет Product Backlog, приоритизирует задачи
		- Scrum Master - Следит за соблюдением Scrum, устраняет блокеры, коучит команду
		- Developers - Кросс-функциональная команда, реализующая задачи спринта (разработка, тестирование, проектирование и т.д.).
	- Артефакты:
		- Product Backlog - Приоритезированный список всех фич, требований, улучшений. Управляется Product Owner’ом
		- Sprint Backlog - Задачи, отобранные на текущий спринт (из Product Backlog) + план выполнения
		- Increment - Потенциально готовый к выпуску продукт или его часть, созданная в течение спринта
		- Burndown Chart - Диаграмма сгорания задач. Показывает, сколько работы и времени осталось до завершения проекта или спринта
	- События (Scrum Events):
		- Sprint (1–4 недели) - Основной цикл работы, фиксированной длины. В конце — поставка ценности
		- Sprint Planning - Планирование задач и целей спринта. Команда определяет, что и как будет сделано
		- Daily Scrum (15 мин) - Ежедневный стендап для синхронизации. Обсуждаются: что сделано, что мешает, что будет делаться
		- Sprint Review - Демонстрация результата заинтересованным сторонам. Сбор обратной связи
		- Sprint Retrospective - Внутренняя ретроспектива команды. Что было хорошо / плохо, как улучшиться
- Принципы Scrum
	- Прозрачность: все участники понимают, что происходит
	- Инспекция: регулярные проверки состояния проекта и процесса
	- Адаптация: корректировка планов и методов работы

#### Kanban
- Что это: Метод управления задачами без жёстких итераций. Это способ управлять потоком задач, не разбивая работу на фиксированные итерации (как в Scrum), а максимально оптимизируя непрерывную доставку ценности
- Подходит: Для команд с постоянным потоком задач (например, техподдержка, DevOps)
- Основные принципы Kanban:
	1. Визуализируй поток работы:  Используется Kanban-доска с колонками:  
	        `To Do → In Progress → Code Review → Testing → Done`. Каждая карточка — отдельная задача
	2. Ограничивай WIP (Work In Progress): Вводятся лимиты на количество задач в колонке. Например: "In Progress ≤ 3", чтобы не перегружать команду
	3. Управляй потоком: Цель — равномерный, предсказуемый поток задач до "Done". Измеряются метрики: throughput, lead time, cycle time
	4. Явно определяй правила: Каждая колонка имеет чёткие критерии перехода задач (Definition of Done на каждом этапе)
	5. Постоянно улучшай: На основе анализа потока и ретроспектив команда улучшает процесс

#### DevOps
DevOps (Development + Operations / Разработка + Эксплуатация) — это подход к организации процессов, где разработчики, тестировщики и админы работают как единая команда. Это культура, философия и набор практик, направленные на:
- сокращение времени между изменением кода и его выпуском в прод
- улучшение качества релизов
- устранение разрыва между разработкой (Dev) и эксплуатацией (Ops)

| Практика                                                        | Назначение                                                        |
| --------------------------------------------------------------- | ----------------------------------------------------------------- |
| CI/CD (Continuous Integration / Continuous Delivery/Deployment) | Автоматизация сборки, тестов и релизов                            |
| Infrastructure as Code (IaC)                                    | Инфраструктура описывается как код (Terraform, Ansible)           |
| Monitoring & Logging                                            | Сбор метрик и логов в реальном времени (Prometheus, Grafana, ELK) |
| Automated Testing                                               | Покрытие всего пайплайна тестами (unit, integration, e2e)         |
| Containerization                                                | Изоляция приложений (Docker, Podman)                              |
| Orchestration                                                   | Управление кластерами контейнеров (Kubernetes, Nomad)             |
| Version Control Everything                                      | Весь код, конфигурации и пайплайны — в Git                        |
| ChatOps (по желанию)                                            | Управление CI/CD и мониторингом через чаты (Slack, Telegram)      |

DevOps Pipeline (типовой):
```
Git Push →
    CI: Build → Test →
    CD: Deploy to staging →
        Manual/Auto Approval →
    Deploy to production →
        Monitoring →
            Alerting → Feedback → Git
```

#### CI/CD
CI/CD — это основа DevOps и современного процесса доставки программного обеспечения. CI (Continuous Integration) - Непрерывная интеграция изменений в код. CD (Continuous Delivery / Deployment) - Непрерывная доставка или развертывание

CI — это практика, при которой разработчики часто сливают код в общую тестовую ветку (обычно dev), и каждый коммит автоматически проверяется
Что включает CI:
- Автоматическая сборка (build)
- Юнит и интеграционные тесты
- Статический анализ (линтеры, SonarQube и пр.)
- Проверка качества кода (coverage, code style)
- Возможные проверки безопасности
Зачем нужен CI:
- Быстро ловить ошибки и конфликты
- Убедиться, что код не сломал проект
- Экономить время на ручном тестировании

CD (Delivery / поставка) — это этап, на котором протестированный код готов к развертыванию в прод, но деплой может быть ручным
- Автоматическая сборка артефактов (дистрибутивов, контейнеров)
- Развёртывание на staging/QA-окружения
- Возможность ручного запуска прод-релиза
Подходит, если прод-релизы требуют одобрения, бумажной работы, уведомлений заказчику и т.д.

CD (Deployment / развёртывание) — это полная автоматизация: после прохождения всех этапов тестирования и сборки код сразу уходит в прод
- Без ручного участия
- Возможность релизов хоть каждый час
- Требует высокого доверия к пайплайну
Используется в зрелых продуктах, например, в веб-приложениях, где можно быстро откатить и отследить баги

#### Иерархия задач
1. *Epic*:
	- Что это: Крупная пользовательская история, охватывающая значительную часть функциональности
	- Пример: "Система авторизации пользователей"
	- Особенности:
	    - Слишком большая, чтобы быть реализована за один спринт
	    - Делится на features или user stories
2. *Feature*:
	- Что это: Функциональный блок, представляющий конкретную ценность для пользователя
	- Пример: "Вход через Google", "Сброс пароля"
	- Особенности:
	    - Может входить в состав Epic
	    - Обычно реализуется в течение 1–2 спринтов
	    - Делится на tasks
3. *Task*:
	- Что это: Конкретная техническая задача для выполнения
	- Пример: "Реализовать REST endpoint для авторизации", "Настроить OAuth2-клиент"
	- Особенности:
	    - Назначается на конкретного разработчика
	    - Маленькая по объёму, занимает от нескольких часов до пары дней

### Микросервисы

**Микросервисы** — это архитектурный стиль разработки программного обеспечения, при котором приложение строится как набор небольших, автономных сервисов. Каждый сервис реализует определённую бизнес-функцию, работает независимо и общается с другими сервисами через лёгкие протоколы, как правило, через HTTP/REST или очередь сообщений

#### Основные характеристики микросервисов
1. Малый размер и изолированность: Каждый сервис выполняет строго определённую задачу
2. Независимость разработки и развёртывания: Команды могут разрабатывать, тестировать и развёртывать микросервисы независимо друг от друга
3. Собственные данные и логика: Каждый сервис может использовать собственную базу данных, не разделяя схему с другими
4. Горизонтальное масштабирование: Можно масштабировать только те части системы, которые требуют большего ресурса
5. Устойчивость к сбоям: Сбой одного сервиса не приводит к отказу всей системы (если предусмотрены механизмы устойчивости)

#### Пример микросервисов
(Допустим, вы разрабатываете интернет-магазин):

| Микросервис          | Задача                                                |
| -------------------- | ----------------------------------------------------- |
| User Service         | Управление пользователями, регистрация, авторизация   |
| Product Service      | Управление товарами: добавление, редактирование       |
| Order Service        | Обработка заказов, расчёт стоимости                   |
| Payment Service      | Обработка платежей, интеграция с платёжными системами |
| Notification Service | Отправка e-mail и SMS уведомлений                     |
| Review Service       | Хранение и отображение отзывов покупателей            |

## Проект

Inspira - Ежедневные мотивационные цитаты и сообщения

### Задачи
#### На оценку удовлетворительно
- [ ] Декомпозиция на epic, feature, task: Разбить проект на крупные бизнес-направления (epic), из них — функциональные блоки (feature), и затем — конкретные задачи (task) для разработки
- [x] Распределить задачи между участниками: Назначить задачи конкретным разработчикам / членам команды.
- [ ] Создание чек листов для самопроверки: Создать чеклист для разработчика, чтобы он проверил качество перед сдачей (тесты, логика, покрытие и т.д.).
- [ ] Создание чек листов для тестирования: Чеклист для ручного/автоматического тестирования фичи — шаги, сценарии, ожидания
- [x] Документация API в postman: Описать все публичные и внутренние API в Postman Collection, добавить примеры запросов/ответов
- [x] Git: Настроить git-репозиторий, стандарты ветвления (`main`, `develop`, `feature/*`, и т.п.)
- [ ] Pull request на каждую задачу: На каждую задачу создаётся отдельная ветка и pull request с код-ревью
- [ ] Связь задач и коммитов: В коммитах и PR указывать ID задачи, чтобы отслеживать изменения (например, `feat: [TASK-123] Добавлен API входа`)
#### На оценку хорошо
- [ ] Файл сборки: Создать/настроить файл сборки проекта (`pom.xml`, `build.gradle`, `package.json`, и т.п.).
- [ ] Контейнеры: Упаковать приложение в Docker-контейнеры для локальной разработки, CI и прода
- [ ] CI/CD: Настроить автоматический пайплайн: сборка, тесты, деплой в тест/прод
- [ ] Unit тесты: Покрыть бизнес-логику юнит-тестами, следить за покрытием
- [ ] Статический анализ кода (Sonar): Интегрировать SonarQube (или аналог) для анализа качества кода (code smells, баги, дублирование, покрытие)
- [ ] Документация на публичные методы: Прописать Javadoc / Docstrings / TS-docs для всех публичных интерфейсов, классов, методов
- [ ] Внешние публичные API: Реализовать и документировать API, которое будет использоваться другими сервисами/клиентами
#### На оценку отлично
- [ ] Логирование: Внедрить структурированное логирование (уровни логов, трассировки, исключения)
- [ ] Дополнительные сервисы (Rabbit/Kafka/Redis): Интегрировать внешние сервисы, если нужны очереди, кэш или событийная шина
- [ ] Нагрузочные тесты: Протестировать систему под нагрузкой (использовать JMeter, k6, Locust и т.п.), определить пределы
- [ ] e2e тесты: Автоматические сквозные тесты (через UI или API), эмулирующие поведение пользователя

### Команды
- `run-db.bat` - поднять контейнер с БД
- `docker ps` - проверить, что контейнер поднят
- `docker exec -it postgres-with-logs psql -U admin -d inspira_db` - подключиться к контейнеру вручную
	- `\dn` - посмотреть список схем
	- `\dt` - посмотреть список таблиц
	- `\du` - посмотреть список пользователей
- `docker compose down -v` - удалить запущенный контейнер и связанный том

### Фронт

**React Native** — это фреймворк от Facebook (Meta), который позволяет писать мобильные приложения на JavaScript или TypeScript, используя синтаксис React, но при этом получать нативные Android и iOS приложения

React Native состоит из трёх основных частей
1. *JavaScript Thread (JS Engine)*
	- Здесь работает твой React-код
	- Он написан на JavaScript/TypeScript
	- Использует React (JSX, хуки и т.п.)
	- Выполняется внутри движка JavaScript — чаще всего Hermes (или JSC, раньше)
	- React обновляет виртуальное дерево компонентов (Virtual DOM) и передаёт команды ниже — на уровень нативного интерфейса
2. *Bridge (мост)* — посредник
	- Это механизм, который связывает JS-код с нативным кодом (Java/Swift)
	- Когда ты, например, пишешь `<Text>Hello</Text>` — React Native через bridge говорит Android/iOS: «Нарисуй тут текст "Hello"»
	- Это асинхронная связь, поэтому иногда бывают лаги, если обмен слишком частый (например, в анимациях)
3. *Native Threads (UI / Rendering Layer)*
	- Это настоящий Android или iOS UI
	- React Native создаёт нативные элементы интерфейса**: `View`, `Text`, `Button`, и т.д.
	- То есть, это не WebView и не HTML — UI реально нативный

**Нативный** код или интерфейс работает напрямую с ОС, без прослойки типа браузера или виртуальной машины, если это возможно. То есть — это "свой" для платформы код. Примеры:
- Android → нативный код на Java или Kotlin
- iOS → нативный код на Swift или Objective-C
- Windows → нативный код на C++, C# с WinAPI

### Бэкенд

Аннотация `@SpringBootApplication` объединяет три других:
- `@Configuration` — говорит Spring, что этот класс содержит конфигурацию приложения (бины и настройки)
- `@EnableAutoConfiguration` — включает автоматическую настройку Spring компонентов на основе зависимостей (например, если есть `spring-web`, настраивается веб-сервер)
- `@ComponentScan` — указывает искать компоненты (`@Component`, `@Service`, `@Repository`, `@Controller`) в текущем пакете и под-пакетах (`nsu.fit` и глубже)