
### Полезости
- [Медия](https://www.nsumedia.ru/main_potok/third_course/fifth_semester/network)
- [Лекции Ипполитова из CS-центра](https://compscicenter.ru/courses/comp-networks/nsk/2018-autumn/classes/)
- [Сайт Ипполитова с лабами и инфой](http://fit.ippolitov.me/CN_2/2024)
- [Гугл-диск с материалами](https://drive.google.com/drive/folders/1pyXqCG1B137wpjqSC1U3q88MLXunWWbc?usp=drive_link)
- [[GO]]
- [Отзывы об экзаменах](https://docs.google.com/spreadsheets/d/1f7Ul7q0BK61sFfOVHNRiad904Ts8MQDXsimatGEt5S4/edit?gid=2010672661#gid=2010672661)
- [Отзывы о преподавателях](https://docs.google.com/document/d/16hbDYg7dMCo3DLn8NgGGI-eOoDxosUn0yKN1fwrPcsA/edit#heading=h.jcnhp9p1wgko)
- [Отзывы о преподавателях 2.0](https://docs.google.com/document/d/11VQiY0Cr86lxh0qlV4kj7X857_xOVnfCdQMilYKfob0/edit#heading=h.z9gt69h3lhwi)

### Лабы
- [x] 1. [Обнаружение копий себя в локальной сети](http://fit.ippolitov.me/CN_2/2024/1.html)  
- [x] 2. [Передача файла по TCP с подсчётом скорости](http://fit.ippolitov.me/CN_2/2024/2.html)  
- [x] 3. [Места (асинхронное сетевое взаимодействие)](http://fit.ippolitov.me/CN_2/2024/3.html)  
- [ ] 4. [Змейка по сети](https://gitlab.ccfit.nsu.ru/vadipp/04_snakes_task)  
- [ ] 5. [SOCKS-прокси](http://fit.ippolitov.me/CN_2/2024/5.html)

### Комманды
- `ipconfig` - посмотреть ip на винде
- `ip address` - посмотреть ip на линуксе

### Утилиты
- `tcpdump` — это инструмент командной строки для захвата сетевых пакетов
	- sudo tcpdump -i eth0 port 12345 - Захват трафика по порту
	- sudo tcpdump -i eth0 udp - Захват всех UDP пакетов
	- sudo tcpdump -i eth0 host 192.168.1.10 - Захват трафика по IP-адресу
- `ss` — это инструмент для отображения информации о сокетах
	- ss -tuln - Список всех TCP/UDP сокетов с информацией о портах
	- ss -u -a - Информация обо всех UDP сокетах
	- ss -t -a - Информация обо всех TCP сокетах
- `netstat` — ещё один инструмент для мониторинга сокетов и сетевых подключений
	- netstat -anp | grep 8080 - Найти сокет по порту
- `strace`  — отслеживает системные вызовы программы
	- strace -e trace=network ./prog - Отображение только сетевых системных вызовов
- `lsof` - показывает файлы, которые открыты процессами, включая сетевые сокеты
	- sudo lsof -i -nP | grep prog - Отображение сокетов, открытых вашей программой

### Сокеты

**Сокет** - это абстракция, которая представляет собой конечную точку для обмена данными между двумя программами через сеть. 
- Сокеты могут работать с различными протоколами, но наиболее распространённые — это TCP и UDP. 
- Типы сокетов: Stream Sockets (SOCK_STREAM), Datagram Sockets (SOCK_DGRAM). 
- Сокеты связываются с IP-адресом и портом, чтобы определить, какие данные отправляются и откуда. Это позволяет нескольким приложениям на одном устройстве использовать сокеты одновременно, так как каждый сокет будет использовать свой уникальный порт.

#### Виды сокетов
1. **Блокирующие сокеты**
	- По умолчанию сокеты являются блокирующими.
	- В блокирующем режиме операции чтения (например, `recv`, `recvfrom`) и записи (например, `send`, `sendto`) блокируют выполнение программы, пока операция не будет завершена.
2. **Неблокирующие сокеты**
	- В неблокирующем режиме операции чтения и записи немедленно возвращают управление программе, даже если данные еще не готовы.
	- Например, если вы вызываете `recv` на неблокирующем сокете, и данных нет, функция немедленно вернёт ошибку (например, `EAGAIN` или `EWOULDBLOCK`), сигнализируя, что сейчас нет данных, но программа не блокируется.
3. **Асинхронные сокеты**
	- Асинхронные сокеты используют механизм уведомлений о готовности операций. Приложение получает уведомление (например, через коллбэк или сигнал), когда сокет готов к чтению или записи.
	- Это обычно реализуется через различные API, например, IOCP (Input/Output Completion Ports) в Windows или с помощью асинхронных библиотек (например, `asyncio` в Python, `libuv`).
	- Асинхронные сокеты не требуют активного опроса сокета, и выполнение программы продолжается до получения уведомления.
	- Асинхронные сокеты подходят для высоконагруженных серверов, когда необходимо обработать большое количество соединений без блокирования потока выполнения на каждой операции.

#### Способы решения проблемы блокировки
1. Неблокирующий режим
	- Минусы: нельзя тупо делать опрос неблокирующего сокета в цикле, так как это сильно нагружает процессор
2. Асинхронный режим
	- Минусы: тяжело писать код и в случае использования колбэков, и в случае использования других механизмов (например фьючеров в java)
3. Отдельные потоки
	- Минусы: тратится время на переключение контекста (чтобы переключать потоки)
4. Легковесные потоки (например go-рутины)

### Мультикаст

**Мультикаст** - это механизм, позволяющий одному устройству отправлять данные на несколько устройств одновременно по IP-сети, не отправляя отдельное сообщение каждому получателю. 
- Мультикаст-группа — это набор устройств, которые "подписались" на получение данных, отправляемых на определённый мультикаст-адрес. Устройство может подписаться на одну или несколько таких групп
- В отличие от unicast (один-ко-одному) и broadcast (один-ко-всем), мультикаст позволяет одному источнику посылать данные только тем устройствам, которые явно заинтересованы в их получении.
- Мультикаст в IPv4 использует диапазон адресов от `224.0.0.0` до `239.255.255.255` (класс D). Эти адреса зарезервированы для мультикаст-групп.
- Типы мультикаст-групп:
	- Well-known Multicast: Эти адреса зарезервированы для специальных целей. Например:
	    - `224.0.0.1`: Все устройства в сети.
	    - `224.0.0.2`: Все маршрутизаторы в сети.
	- Globally Scoped Multicast: Адреса от `224.0.1.0` до `238.255.255.255` используются для глобальных мультикаст-групп.
	- Administratively Scoped Multicast: Адреса от `239.0.0.0` до `239.255.255.255` зарезервированы для использования внутри локальных сетей (аналог частных адресов в unicast, как `192.168.0.0/16`).
- Мультикаст-адрес — это групповой адрес, но каждый узел в этой группе всё равно использует свой порт для приёма данных. Если сокет не привязан к порту, он не будет знать, на какой порт принимать данные, и это приведёт к невозможности корректного приёма.

Переиспользование (reuse) позволяет одному сокету повторно использовать адрес и порт, которые недавно использовались другим сокетом. Без настройки переиспользования адреса и порта при попытке повторного открытия сокета на том же адресе и порте (например, после перезапуска сервера) может возникнуть ошибка, так как система может считать, что этот адрес и порт всё ещё заняты.

Сокет может принимать сообщения, отправленные на другую мультикаст группу (в данном случае на `ff02::4`, хотя сокет присоединён к `ff02::5`), из-за того, что оба этих адреса находятся в пределах одного диапазона IPv6 мультикаст групп с одинаковым объемом (scope). Причины такого поведения:
1. Объем (Scope) мультикаст группы:
    - Мультикаст адреса `ff02::4` и `ff02::5` оба относятся к link-local мультикаст группам (диапазон `ff02::/16`). Это значит, что их сообщения распространяются только в пределах одного сетевого сегмента или канала (обычно внутри одного локального интерфейса).
    - Если сокет настроен принимать мультикаст сообщения на уровне локальной сети (link-local scope), он может иногда принимать пакеты, предназначенные для других мультикаст адресов в том же объёме.
2. Механизм обработки мультикастов в сетевом стекe:
    - Сетевые стеки некоторых операционных систем могут передавать мультикаст сообщения всем приложениям или сокетам, которые "слушают" мультикаст сообщения на конкретном сетевом интерфейсе, даже если они присоединились к разным группам, если эти группы имеют одинаковый scope.
3. Ошибочная конфигурация маршрутизации:
    - В некоторых случаях сетевые драйверы или маршрутизаторы могут быть неправильно настроены и передавать пакеты на неправильные группы, если они видят похожие или близкие адреса.

### Порядок байт

Функции `htons`, `htonl`, `ntohs` и `ntohl` используются для преобразования данных между порядком байт, используемым внутри компьютера (часто называемым host byte order), и порядком байт, используемым в сети (network byte order). Это важно для того, чтобы данные правильно передавались и интерпретировались между машинами с разной архитектурой. 
- `htons` — Host TO Network Short
- `htonl` — Host TO Network Long
- `ntohs` — Network TO Host Short
- `ntohl` — Network TO Host Long

Порядок байт (endianness):
- Host byte order — это порядок байт, который используется внутри конкретной системы
    - **Big-endian**: старший байт хранится первым (например, сетевые протоколы, такие как TCP/IP, используют big-endian).
    - **Little-endian**: младший байт хранится первым (некоторые архитектуры, такие как x86, используют little-endian).
- Network byte order — это стандартный порядок байт, принятый для передачи данных по сети (всегда big-endian).

### HTTP

**HTTP** (HyperText Transfer Protocol)  — протокол передачи гипертекста. Это набор правил, по которым данные в интернете передаются между разными источниками, обычно между компьютерами и серверами.
- Это протокол передачи данных, который описывает, как браузер и сервер обмениваются информацией.
- Задача HTTP — обмен данными между пользовательским приложением, осуществляющим доступ к веб-ресурсам (обычно это веб-браузер), и веб-сервером
- HTTP основан на TCP. Это протокол прикладного уровня, который использует TCP для надёжной передачи данных между клиентом и сервером

**HTTP запросы** — это сообщения, которые клиент (например, веб-браузер или любое другое приложение) отправляет на сервер для выполнения определённых операций.
Основные типы запросов:
1. `GET` - Запрос данных с сервера
2. `POST` - Отправка данных на сервер для создания или обработки информации
3. `PUT` - Полное обновление существующего ресурса или создание нового
4. `PATCH` - Частичное обновление ресурса
5. `DELETE` - Удаление ресурса
6. `HEAD` - Получение метаданных ресурса без самого ресурса
7. `OPTIONS` - Получение информации о доступных методах HTTP для ресурса
8. `CONNECT` - Устанавливает туннель для передачи данных
9. `TRACE` - Возвращает запрос, как его видит сервер

Структура HTTP-сообщения всегда одинакова:
- **Стартовая строка**. В ней определяется адрес, по которому отправляется запрос, и тип сообщения. Указывается метод, который определяет действия при получении этого сообщения
- **Заголовки** (Headers). В них прописаны определённые параметры сообщения. Например, может быть напрямую задан язык
- **Тело запроса** (Request Body). Текст сообщения — данные, которые передаются. Например, файлы, отправляемые на сервер

**HTTPS** - расширение HTTP. Буква S в аббревиатуре означает Secure, то есть «защищённый». Он организует передачу данных более безопасно, так как сообщение перед отправкой шифруется по специальным правилам.

**URL** (Uniform Resource Locator) — это унифицированный указатель ресурса, используемый для обозначения адреса ресурса в интернете. Он представляет собой строку, которая указывает, как и где можно получить доступ к ресурсу (например, веб-странице, файлу, изображению и т.д.)
- Пример: `https://www.example.com:443/path/to/page?user=123#section`
	- Протокол: `https`
	- Имя хоста: `www.example.com`
	- Порт: `443` (опускается, если используется стандартный порт для протокола)
	- Путь: `/path/to/page`
	- Запрос: `?user=123`
	- Фрагмент: `#section`

### Прокси

**Прокси-сервер** — это промежуточный сервер (комплекс программ) в компьютерных сетях, выполняющий роль посредника между пользователем и целевым сервером.

#### Сравнение прокси и VPN:
- Прокси: Работает на уровне отдельных приложений или сетевых соединений, может скрывать ваш IP-адрес, но, как правило, не шифрует трафик.
- VPN: Создает зашифрованный туннель между вашим устройством и VPN-сервером, скрывая ваш IP и защищая все передаваемые данные.

#### Применение прокси-серверов:
- Обход географических ограничений.
- Анонимизация интернет-соединений.
- Кэширование данных для ускорения доступа.
- Фильтрация контента на уровне корпоративных сетей.
- Защита серверов от DDoS-атак.

### Основные виды прокси-серверов

#### HTTP-прокси 
- Протоколы: HTTP, HTTPS
- Уровень: Приложений (уровень 7 модели OSI)  
- Описание:  
	- HTTP-прокси работают на уровне приложений и предназначены для обработки веб-трафика. Они поддерживают только протоколы HTTP и HTTPS, что делает их оптимальными для веб-браузеров и других веб-приложений. Запросы через HTTP-прокси передаются с помощью стандартного HTTP или HTTPS-запроса. Эти прокси часто используют для кэширования веб-страниц и сокращения задержек доступа к популярным веб-ресурсам.
- Отличия:
    - Поддерживает только HTTP и HTTPS.
    - Можно кэшировать страницы для ускорения доступа.
    - Может изменять запросы и ответы (например, для блокировки рекламы или фильтрации контента).
    - Используется для обхода блокировок веб-сайтов и анонимизации веб-трафика.

#### SOCKS-прокси
- Протоколы: TCP, UDP
- Уровень: Сессий (уровень 5 модели OSI)
- Описание: 
	- SOCKS-прокси работает на более низком уровне, чем HTTP-прокси, и может обрабатывать не только HTTP-трафик, но и любой другой тип данных, такой как FTP, POP3, SMTP и даже трафик игр или P2P-приложений. SOCKS-прокси бывает двух версий: SOCKS4 и SOCKS5. SOCKS5 поддерживает шифрование, аутентификацию и работу с UDP-трафиком.
- Отличия:
    - Поддерживает любые протоколы (TCP и UDP).
    - Может использоваться для игр, стриминговых сервисов и P2P.
    - SOCKS5 поддерживает аутентификацию и IPv6.
    - Не кэширует данные и не изменяет трафик.

#### Транспарентный (прозрачный) прокси
- Протоколы: HTTP, HTTPS (и другие)
- Описание:
	- Прозрачный прокси перехватывает трафик между клиентом и сервером без необходимости настраивать клиент. Внешне такой прокси не виден для пользователя, так как весь трафик автоматически проходит через него. Эти прокси часто используют провайдеры или корпоративные сети для фильтрации трафика, блокировки сайтов, мониторинга активности пользователей и кэширования данных.
- Отличия:
    - Не требует настройки со стороны клиента.
    - Может перехватывать и фильтровать трафик без ведома пользователя.
    - Часто используется для корпоративных политик контроля и фильтрации трафика.

#### Анонимные прокси
- Описание:
	- Анонимные прокси скрывают реальный IP-адрес пользователя и заменяют его на собственный IP. Это делает пользователя анонимным при посещении веб-ресурсов, что затрудняет отслеживание его действий в интернете.
- Отличия:
    - Скрывает реальный IP пользователя.
    - Не передает информацию об IP пользователя целевым сайтам.
    - Подходит для защиты конфиденциальности.

#### Элитные прокси
- Описание:
	- Элитные прокси (иногда называемые высокоанонимными) предлагают максимальный уровень анонимности. В отличие от обычных анонимных прокси, они не передают целевому серверу никаких заголовков, которые могли бы указывать на использование прокси. Они полностью скрывают факт использования прокси.
- Отличия:
    - Максимальная анонимность.
    - Целевые серверы не могут определить, что вы используете прокси.

#### Реверс-прокси
- Протоколы: HTTP, HTTPS (и другие)
- Описание:
	- Реверс-прокси работает с другой стороны соединения — он действует как посредник для серверов. Он принимает запросы от клиентов и перенаправляет их на внутренние серверы. Реверс-прокси используется для балансировки нагрузки, распределения трафика между несколькими серверами, защиты серверов от DDoS-атак и ускорения доступа к данным (через кэширование).
- Отличия:
    - Работает от имени сервера, а не клиента.
    - Используется для балансировки нагрузки, безопасности и кэширования.
    - Может скрывать внутренние серверы от внешнего мира.

#### FTP-прокси
- Протоколы: FTP
- Описание:
	- FTP-прокси используется для работы с FTP-протоколом и передачи файлов. Он позволяет клиенту подключаться к FTP-серверам через прокси, что полезно для контроля доступа и анонимизации при работе с FTP.
- Отличия:
    - Специализируется на передаче файлов по протоколу FTP.

#### CGI-прокси
- Протоколы: HTTP
- Описание:
	- CGI-прокси — это веб-страница, которая позволяет пользователям заходить на другие сайты через браузер, используя интерфейс CGI (Common Gateway Interface). Такие прокси не требуют настройки на клиенте и часто используются для обхода блокировок или анонимизации трафика.
- Отличия:
    - Прокси реализован как веб-страница.
    - Позволяет пользователю получить доступ к сайтам через интерфейс браузера.

### Фаерволы

**Файрволы (брандмауэры)** — это сетевые устройства или программные системы, предназначенные для контроля и фильтрации входящего и исходящего сетевого трафика на основе определённых правил безопасности. Они используются для защиты сети от несанкционированного доступа, предотвращения атак, а также для ограничения доступа к определённым ресурсам.

Основные функции и задачи файрволов:
1. **Защита от несанкционированного доступа**: Файрволы фильтруют трафик и блокируют подозрительные или нежелательные соединения, что помогает предотвратить взломы и проникновения в сеть.
2. **Фильтрация трафика**: Файрволы могут блокировать или разрешать трафик на основе различных параметров, таких как IP-адреса, порты, протоколы или типы приложений.
3. **Контроль доступа**: Они могут использоваться для ограничения доступа к определённым веб-сайтам, службам или приложениям на основе политик организации или государства.
4. **Защита от атак**: Файрволы помогают предотвращать различные типы атак, такие как **DDoS-атаки**, **сканирование портов**, **вредоносные** и **ботнет-сети**.    
5. **Мониторинг и ведение журналов**: Они предоставляют средства для мониторинга сетевого трафика и журналирования событий, что полезно для анализа и обнаружения потенциальных угроз.

### SOCKS-прокси

Особенности
- Работает на уровне сессий в модели OSI, благодаря чему может передавать трафик различных протоколов, таких как HTTP, HTTPS, FTP, и даже UDP-трафик
- Просто передает сетевые пакеты между клиентом и сервером, не изменяя их содержимого. Поэтому, в отличие от HTTP-прокси, он может работать с любыми типами трафика (веб, игры, торрент-клиенты и т.д.)
- Работает прозрачно
- Между клиентом и SOCKS-сервером и между SOCKS-сервером и сервером назначения могут использоваться разные протоколы (UDP или TCP)

Типы SOCKS-прокси:
1. **SOCKS4**:
    - Поддерживает только TCP-трафик.
    - Не поддерживает аутентификацию.
    - Работает с IPv4.
2. **SOCKS5**:
    - Поддерживает как TCP, так и UDP-трафик.
    - Поддерживает аутентификацию (можно настроить проверку пользователей).
    - Работает как с IPv4, так и с IPv6.
    - Может использоваться для обхода блокировок, так как передает любые данные, включая те, которые не ограничены HTTP.

#### Как работает SOCKS-прокси?

1. **Установка соединения с SOCKS-сервером**:
    - Клиент (например, браузер или приложение) подключается к SOCKS-серверу, обычно указывая его IP-адрес и порт (обычно порт 1080).
    - После соединения клиент и сервер обменятся данными для установления туннеля и определения, какой тип соединения (TCP или UDP) будет использоваться, а также настроек аутентификации (если включена).

2. **Аутентификация (опционально)**:
    - В случае SOCKS5 поддерживается опциональная аутентификация (например, по паролю). Клиент отправляет запрос авторизации с указанием имени пользователя и пароля, и SOCKS-сервер проверяет их перед разрешением дальнейшего соединения.

3. **Отправка запроса на соединение с целевым сервером**:
    - SOCKS-клиент формирует запрос на соединение, в котором указывает:
        - **Тип запроса**: подключение, привязка или отправка данных через UDP (в случае SOCKS5).
        - **Адрес назначения**: IP-адрес или доменное имя конечного сервера, с которым хочет связаться клиент.
        - **Порт назначения**: Порт на конечном сервере, к которому хочет подключиться клиент.

4. **Обработка запроса на подключение**:
    - SOCKS-сервер принимает запрос от клиента, устанавливает исходящее соединение с указанным сервером назначения и, при успешном подключении, возвращает клиенту ответ о том, что соединение установлено.
    - В случае ошибки (например, если сервер назначения недоступен или отклоняет соединение), SOCKS-сервер сообщает клиенту об отказе, отправив код ошибки.

5. **Передача данных через туннель**:    
    - Как только соединение установлено, весь трафик, идущий от клиента, перенаправляется через SOCKS-сервер к серверу назначения, при этом клиент как бы “прозрачно” отправляет данные, не связываясь напрямую с конечным сервером.
    - SOCKS-сервер передаёт данные как есть и передаёт ответные данные от целевого сервера обратно клиенту.

#### Пример обработки TCP-соединения клиентом и SOCKS-сервером

Если клиент хочет установить TCP-соединение с сервером назначения:
1. **Запрос на подключение**: Клиент отправляет запрос на TCP-соединение к SOCKS-серверу, указывая в запросе IP и порт конечного сервера.
2. **Переподключение на стороне SOCKS-сервера**: SOCKS-сервер принимает запрос и самостоятельно инициирует подключение к целевому серверу.
3. **Прозрачное соединение**: Если соединение установлено, весь последующий трафик клиента проксируется через SOCKS-сервер к конечному серверу.

