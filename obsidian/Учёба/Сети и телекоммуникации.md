
### Полезости
- [Медия](https://www.nsumedia.ru/main_potok/third_course/fifth_semester/network)
- [Лекции Ипполитова из CS-центра](https://compscicenter.ru/courses/comp-networks/nsk/2018-autumn/classes/)
- [Сайт Ипполитова с лабами и инфой](http://fit.ippolitov.me/CN_2/2024)
- [Гугл-диск с материалами](https://drive.google.com/drive/folders/1pyXqCG1B137wpjqSC1U3q88MLXunWWbc?usp=drive_link)
- [[GO]]
- [Отзывы об экзаменах](https://docs.google.com/spreadsheets/d/1f7Ul7q0BK61sFfOVHNRiad904Ts8MQDXsimatGEt5S4/edit?gid=2010672661#gid=2010672661)
- [Отзывы о преподавателях](https://docs.google.com/document/d/16hbDYg7dMCo3DLn8NgGGI-eOoDxosUn0yKN1fwrPcsA/edit#heading=h.jcnhp9p1wgko)
- [Отзывы о преподавателях 2.0](https://docs.google.com/document/d/11VQiY0Cr86lxh0qlV4kj7X857_xOVnfCdQMilYKfob0/edit#heading=h.z9gt69h3lhwi)

### Лабы
- [x] 1. [Обнаружение копий себя в локальной сети](http://fit.ippolitov.me/CN_2/2024/1.html)  
- [x] 2. [Передача файла по TCP с подсчётом скорости](http://fit.ippolitov.me/CN_2/2024/2.html)  
- [x] 3. [Места (асинхронное сетевое взаимодействие)](http://fit.ippolitov.me/CN_2/2024/3.html)  
- [ ] 4. [Змейка по сети](https://gitlab.ccfit.nsu.ru/vadipp/04_snakes_task)  
- [ ] 5. [SOCKS-прокси](http://fit.ippolitov.me/CN_2/2024/5.html)

### Комманды
- `ipconfig` - посмотреть ip на винде
- `ip address` - посмотреть ip на линуксе

### Утилиты
- `tcpdump` — это инструмент командной строки для захвата сетевых пакетов
	- sudo tcpdump -i eth0 port 12345 - Захват трафика по порту
	- sudo tcpdump -i eth0 udp - Захват всех UDP пакетов
	- sudo tcpdump -i eth0 host 192.168.1.10 - Захват трафика по IP-адресу
- `ss` — это инструмент для отображения информации о сокетах
	- ss -tuln - Список всех TCP/UDP сокетов с информацией о портах
	- ss -u -a - Информация обо всех UDP сокетах
	- ss -t -a - Информация обо всех TCP сокетах
- `netstat` — ещё один инструмент для мониторинга сокетов и сетевых подключений
	- netstat -anp | grep 8080 - Найти сокет по порту
- `strace`  — отслеживает системные вызовы программы
	- strace -e trace=network ./prog - Отображение только сетевых системных вызовов
- `lsof` - показывает файлы, которые открыты процессами, включая сетевые сокеты
	- sudo lsof -i -nP | grep prog - Отображение сокетов, открытых вашей программой

### Сокеты

**Сокет** - это абстракция, которая представляет собой конечную точку для обмена данными между двумя программами через сеть. 
- Сокеты могут работать с различными протоколами, но наиболее распространённые — это TCP и UDP. 
- Типы сокетов: Stream Sockets (SOCK_STREAM), Datagram Sockets (SOCK_DGRAM). 
- Сокеты связываются с IP-адресом и портом, чтобы определить, какие данные отправляются и откуда. Это позволяет нескольким приложениям на одном устройстве использовать сокеты одновременно, так как каждый сокет будет использовать свой уникальный порт.

#### Виды сокетов
1. **Блокирующие сокеты**
	- По умолчанию сокеты являются блокирующими.
	- В блокирующем режиме операции чтения (например, `recv`, `recvfrom`) и записи (например, `send`, `sendto`) блокируют выполнение программы, пока операция не будет завершена.
2. **Неблокирующие сокеты**
	- В неблокирующем режиме операции чтения и записи немедленно возвращают управление программе, даже если данные еще не готовы.
	- Например, если вы вызываете `recv` на неблокирующем сокете, и данных нет, функция немедленно вернёт ошибку (например, `EAGAIN` или `EWOULDBLOCK`), сигнализируя, что сейчас нет данных, но программа не блокируется.
3. **Асинхронные сокеты**
	- Асинхронные сокеты используют механизм уведомлений о готовности операций. Приложение получает уведомление (например, через коллбэк или сигнал), когда сокет готов к чтению или записи.
	- Это обычно реализуется через различные API, например, IOCP (Input/Output Completion Ports) в Windows или с помощью асинхронных библиотек (например, `asyncio` в Python, `libuv`).
	- Асинхронные сокеты не требуют активного опроса сокета, и выполнение программы продолжается до получения уведомления.
	- Асинхронные сокеты подходят для высоконагруженных серверов, когда необходимо обработать большое количество соединений без блокирования потока выполнения на каждой операции.

#### Способы решения проблемы блокировки
1. Неблокирующий режим
	- Минусы: нельзя тупо делать опрос неблокирующего сокета в цикле, так как это сильно нагружает процессор
2. Асинхронный режим
	- Минусы: тяжело писать код и в случае использования колбэков, и в случае использования других механизмов (например фьючеров в java)
3. Отдельные потоки
	- Минусы: тратится время на переключение контекста (чтобы переключать потоки)
4. Легковесные потоки (например go-рутины)

### Мультикаст

**Мультикаст** - это механизм, позволяющий одному устройству отправлять данные на несколько устройств одновременно по IP-сети, не отправляя отдельное сообщение каждому получателю. 
- Мультикаст-группа — это набор устройств, которые "подписались" на получение данных, отправляемых на определённый мультикаст-адрес. Устройство может подписаться на одну или несколько таких групп
- В отличие от unicast (один-ко-одному) и broadcast (один-ко-всем), мультикаст позволяет одному источнику посылать данные только тем устройствам, которые явно заинтересованы в их получении.
- Мультикаст в IPv4 использует диапазон адресов от `224.0.0.0` до `239.255.255.255` (класс D). Эти адреса зарезервированы для мультикаст-групп.
- Типы мультикаст-групп:
	- Well-known Multicast: Эти адреса зарезервированы для специальных целей. Например:
	    - `224.0.0.1`: Все устройства в сети.
	    - `224.0.0.2`: Все маршрутизаторы в сети.
	- Globally Scoped Multicast: Адреса от `224.0.1.0` до `238.255.255.255` используются для глобальных мультикаст-групп.
	- Administratively Scoped Multicast: Адреса от `239.0.0.0` до `239.255.255.255` зарезервированы для использования внутри локальных сетей (аналог частных адресов в unicast, как `192.168.0.0/16`).
- Мультикаст-адрес — это групповой адрес, но каждый узел в этой группе всё равно использует свой порт для приёма данных. Если сокет не привязан к порту, он не будет знать, на какой порт принимать данные, и это приведёт к невозможности корректного приёма.

Переиспользование (reuse) позволяет одному сокету повторно использовать адрес и порт, которые недавно использовались другим сокетом. Без настройки переиспользования адреса и порта при попытке повторного открытия сокета на том же адресе и порте (например, после перезапуска сервера) может возникнуть ошибка, так как система может считать, что этот адрес и порт всё ещё заняты.

Сокет может принимать сообщения, отправленные на другую мультикаст группу (в данном случае на `ff02::4`, хотя сокет присоединён к `ff02::5`), из-за того, что оба этих адреса находятся в пределах одного диапазона IPv6 мультикаст групп с одинаковым объемом (scope). Причины такого поведения:
1. Объем (Scope) мультикаст группы:
    - Мультикаст адреса `ff02::4` и `ff02::5` оба относятся к link-local мультикаст группам (диапазон `ff02::/16`). Это значит, что их сообщения распространяются только в пределах одного сетевого сегмента или канала (обычно внутри одного локального интерфейса).
    - Если сокет настроен принимать мультикаст сообщения на уровне локальной сети (link-local scope), он может иногда принимать пакеты, предназначенные для других мультикаст адресов в том же объёме.
2. Механизм обработки мультикастов в сетевом стекe:
    - Сетевые стеки некоторых операционных систем могут передавать мультикаст сообщения всем приложениям или сокетам, которые "слушают" мультикаст сообщения на конкретном сетевом интерфейсе, даже если они присоединились к разным группам, если эти группы имеют одинаковый scope.
3. Ошибочная конфигурация маршрутизации:
    - В некоторых случаях сетевые драйверы или маршрутизаторы могут быть неправильно настроены и передавать пакеты на неправильные группы, если они видят похожие или близкие адреса.

### Порядок байт

Функции `htons`, `htonl`, `ntohs` и `ntohl` используются для преобразования данных между порядком байт, используемым внутри компьютера (часто называемым host byte order), и порядком байт, используемым в сети (network byte order). Это важно для того, чтобы данные правильно передавались и интерпретировались между машинами с разной архитектурой. 
- `htons` — Host TO Network Short
- `htonl` — Host TO Network Long
- `ntohs` — Network TO Host Short
- `ntohl` — Network TO Host Long

Порядок байт (endianness):
- Host byte order — это порядок байт, который используется внутри конкретной системы
    - **Big-endian**: старший байт хранится первым (например, сетевые протоколы, такие как TCP/IP, используют big-endian).
    - **Little-endian**: младший байт хранится первым (некоторые архитектуры, такие как x86, используют little-endian).
- Network byte order — это стандартный порядок байт, принятый для передачи данных по сети (всегда big-endian).

### HTTP

**HTTP** (HyperText Transfer Protocol)  — протокол передачи гипертекста. Это набор правил, по которым данные в интернете передаются между разными источниками, обычно между компьютерами и серверами.
- Задача HTTP — обмен данными между пользовательским приложением, осуществляющим доступ к веб-ресурсам (обычно это веб-браузер), и веб-сервером
- HTTP основан на TCP. Это протокол прикладного уровня, который использует TCP для надёжной передачи данных между клиентом и сервером

**HTTP запросы** — это сообщения, которые клиент (например, веб-браузер или любое другое приложение) отправляет на сервер для выполнения определённых операций.
Основные типы запросов:
1. `GET` - Запрос данных с сервера
2. `POST` - Отправка данных на сервер для создания или обработки информации
3. `PUT` - Полное обновление существующего ресурса или создание нового
4. `PATCH` - Частичное обновление ресурса
5. `DELETE` - Удаление ресурса
6. `HEAD` - Получение метаданных ресурса без самого ресурса
7. `OPTIONS` - Получение информации о доступных методах HTTP для ресурса
8. `CONNECT` - Устанавливает туннель для передачи данных
9. `TRACE` - Возвращает запрос, как его видит сервер

Структура HTTP-сообщения всегда одинакова:
- **Стартовая строка**. В ней определяется адрес, по которому отправляется запрос, и тип сообщения. Указывается метод, который определяет действия при получении этого сообщения
- **Заголовки** (Headers). В них прописаны определённые параметры сообщения. Например, может быть напрямую задан язык
- **Тело запроса** (Request Body). Текст сообщения — данные, которые передаются. Например, файлы, отправляемые на сервер

**HTTPS** - расширение HTTP. Буква S в аббревиатуре означает Secure, то есть «защищённый». Он организует передачу данных более безопасно, так как сообщение перед отправкой шифруется по специальным правилам.

**URL** (Uniform Resource Locator) — это унифицированный указатель ресурса, используемый для обозначения адреса ресурса в интернете. Он представляет собой строку, которая указывает, как и где можно получить доступ к ресурсу (например, веб-странице, файлу, изображению и т.д.)
- Пример: `https://www.example.com:443/path/to/page?user=123#section`
	- Протокол: `https`
	- Имя хоста: `www.example.com`
	- Порт: `443` (опускается, если используется стандартный порт для протокола)
	- Путь: `/path/to/page`
	- Запрос: `?user=123`
	- Фрагмент: `#section`

### Остальное

В lab3 надо использовать библиотеку, которая кидает http запрос и 