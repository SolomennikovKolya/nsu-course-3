(Сети и телекоммуникации)

### Полезности
- [Медия](https://www.nsumedia.ru/main_potok/third_course/fifth_semester/network)
- [Лекции Ипполитова из CS-центра](https://compscicenter.ru/courses/comp-networks/nsk/2018-autumn/classes/)
- [Сайт Ипполитова с лабами и инфой](http://fit.ippolitov.me/CN_2/2024)
- [Гугл-диск с материалами](https://drive.google.com/drive/folders/1pyXqCG1B137wpjqSC1U3q88MLXunWWbc?usp=drive_link)

### Лабы
- [x] 1. [Обнаружение копий себя в локальной сети](http://fit.ippolitov.me/CN_2/2024/1.html)  
- [x] 2. [Передача файла по TCP с подсчётом скорости](http://fit.ippolitov.me/CN_2/2024/2.html)  
- [x] 3. [Места (асинхронное сетевое взаимодействие)](http://fit.ippolitov.me/CN_2/2024/3.html)  
- [ ] 4. [Змейка по сети](https://gitlab.ccfit.nsu.ru/vadipp/04_snakes_task)  
- [x] 5. [SOCKS-прокси](http://fit.ippolitov.me/CN_2/2024/5.html)

### Утилиты
- `ipconfig` - посмотреть сетевые интерфейсы в windows
- `ip addr` - посмотреть сетевые интерфейсы в linux
- `netstat -ano` - посмтореть на каких интерфейсах и портах запущены приложения
- `tcpdump` — это инструмент командной строки для захвата сетевых пакетов
	- sudo tcpdump -i eth0 port 12345 - Захват трафика по порту
	- sudo tcpdump -i eth0 udp - Захват всех UDP пакетов
	- sudo tcpdump -i eth0 host 192.168.1.10 - Захват трафика по IP-адресу
- `ss` — это инструмент для отображения информации о сокетах
	- ss -tuln - Список всех TCP/UDP сокетов с информацией о портах
	- ss -u -a - Информация обо всех UDP сокетах
	- ss -t -a - Информация обо всех TCP сокетах
- `netstat` — ещё один инструмент для мониторинга сокетов и сетевых подключений
	- netstat -anp | grep 8080 - Найти сокет по порту
- `strace`  — отслеживает системные вызовы программы
	- strace -e trace=network ./prog - Отображение только сетевых системных вызовов
- `lsof` - показывает файлы, которые открыты процессами, включая сетевые сокеты
	- sudo lsof -i -nP | grep prog - Отображение сокетов, открытых вашей программой

### OSI и TCP/IP

Сетевые модели:
![[Pasted image 20241223203539.png]]
![[Pasted image 20241223203614.png]]

### Сокеты

**Сокет** - это абстракция, которая представляет собой конечную точку для обмена данными между двумя программами через сеть. 
- Сокеты могут работать с различными протоколами, но наиболее распространённые — это TCP и UDP. 
- Типы сокетов: Stream Sockets (SOCK_STREAM), Datagram Sockets (SOCK_DGRAM). 
- Сокеты связываются с IP-адресом и портом, чтобы определить, какие данные отправляются и откуда. Это позволяет нескольким приложениям на одном устройстве использовать сокеты одновременно, так как каждый сокет будет использовать свой уникальный порт.

#### Виды сокетов
1. **Блокирующие сокеты**
	- По умолчанию сокеты являются блокирующими.
	- В блокирующем режиме операции чтения (например, `recv`, `recvfrom`) и записи (например, `send`, `sendto`) блокируют выполнение программы, пока операция не будет завершена.
2. **Неблокирующие сокеты**
	- В неблокирующем режиме операции чтения и записи немедленно возвращают управление программе, даже если данные еще не готовы.
	- Например, если вы вызываете `recv` на неблокирующем сокете, и данных нет, функция немедленно вернёт ошибку (например, `EAGAIN` или `EWOULDBLOCK`), сигнализируя, что сейчас нет данных, но программа не блокируется.
3. **Асинхронные сокеты**
	- Асинхронные сокеты используют механизм уведомлений о готовности операций. Приложение получает уведомление (например, через коллбэк или сигнал), когда сокет готов к чтению или записи.
	- Это обычно реализуется через различные API, например, IOCP (Input/Output Completion Ports) в Windows или с помощью асинхронных библиотек (например, `asyncio` в Python, `libuv`).
	- Асинхронные сокеты не требуют активного опроса сокета, и выполнение программы продолжается до получения уведомления.
	- Асинхронные сокеты подходят для высоконагруженных серверов, когда необходимо обработать большое количество соединений без блокирования потока выполнения на каждой операции.

#### Способы решения проблемы блокировки
1. Неблокирующий режим
	- Минусы: нельзя тупо делать опрос неблокирующего сокета в цикле, так как это сильно нагружает процессор
2. Асинхронный режим
	- Минусы: тяжело писать код и в случае использования колбэков, и в случае использования других механизмов (например фьючеров в java)
3. Отдельные потоки
	- Минусы: тратится время на переключение контекста (чтобы переключать потоки)
4. Легковесные потоки (например go-рутины)

### Мультикаст

**Мультикаст** - это механизм, позволяющий одному устройству отправлять данные на несколько устройств одновременно по IP-сети, не отправляя отдельное сообщение каждому получателю. 
- Мультикаст-группа — это набор устройств, которые "подписались" на получение данных, отправляемых на определённый мультикаст-адрес. Устройство может подписаться на одну или несколько таких групп
- В отличие от unicast (один-ко-одному) и broadcast (один-ко-всем), мультикаст позволяет одному источнику посылать данные только тем устройствам, которые явно заинтересованы в их получении.
- Мультикаст в IPv4 использует диапазон адресов от `224.0.0.0` до `239.255.255.255` (класс D). Эти адреса зарезервированы для мультикаст-групп.
- Типы мультикаст-групп:
	- Well-known Multicast: Эти адреса зарезервированы для специальных целей. Например:
	    - `224.0.0.1`: Все устройства в сети.
	    - `224.0.0.2`: Все маршрутизаторы в сети.
	- Globally Scoped Multicast: Адреса от `224.0.1.0` до `238.255.255.255` используются для глобальных мультикаст-групп.
	- Administratively Scoped Multicast: Адреса от `239.0.0.0` до `239.255.255.255` зарезервированы для использования внутри локальных сетей (аналог частных адресов в unicast, как `192.168.0.0/16`).
- Мультикаст-адрес — это групповой адрес, но каждый узел в этой группе всё равно использует свой порт для приёма данных. Если сокет не привязан к порту, он не будет знать, на какой порт принимать данные, и это приведёт к невозможности корректного приёма.

Переиспользование (reuse) позволяет одному сокету повторно использовать адрес и порт, которые недавно использовались другим сокетом. Без настройки переиспользования адреса и порта при попытке повторного открытия сокета на том же адресе и порте (например, после перезапуска сервера) может возникнуть ошибка, так как система может считать, что этот адрес и порт всё ещё заняты.

Сокет может принимать сообщения, отправленные на другую мультикаст группу (в данном случае на `ff02::4`, хотя сокет присоединён к `ff02::5`), из-за того, что оба этих адреса находятся в пределах одного диапазона IPv6 мультикаст групп с одинаковым объемом (scope). Причины такого поведения:
1. Объем (Scope) мультикаст группы:
    - Мультикаст адреса `ff02::4` и `ff02::5` оба относятся к link-local мультикаст группам (диапазон `ff02::/16`). Это значит, что их сообщения распространяются только в пределах одного сетевого сегмента или канала (обычно внутри одного локального интерфейса).
    - Если сокет настроен принимать мультикаст сообщения на уровне локальной сети (link-local scope), он может иногда принимать пакеты, предназначенные для других мультикаст адресов в том же объёме.
2. Механизм обработки мультикастов в сетевом стекe:
    - Сетевые стеки некоторых операционных систем могут передавать мультикаст сообщения всем приложениям или сокетам, которые "слушают" мультикаст сообщения на конкретном сетевом интерфейсе, даже если они присоединились к разным группам, если эти группы имеют одинаковый scope.
3. Ошибочная конфигурация маршрутизации:
    - В некоторых случаях сетевые драйверы или маршрутизаторы могут быть неправильно настроены и передавать пакеты на неправильные группы, если они видят похожие или близкие адреса.

### Порядок байт

Функции `htons`, `htonl`, `ntohs` и `ntohl` используются для преобразования данных между порядком байт, используемым внутри компьютера (часто называемым host byte order), и порядком байт, используемым в сети (network byte order). Это важно для того, чтобы данные правильно передавались и интерпретировались между машинами с разной архитектурой. 
- `htons` — Host TO Network Short
- `htonl` — Host TO Network Long
- `ntohs` — Network TO Host Short
- `ntohl` — Network TO Host Long

Порядок байт (endianness):
- Host byte order — это порядок байт, который используется внутри конкретной системы
    - **Big-endian**: старший байт хранится первым (например, сетевые протоколы, такие как TCP/IP, используют big-endian).
    - **Little-endian**: младший байт хранится первым (некоторые архитектуры, такие как x86, используют little-endian).
- Network byte order — это стандартный порядок байт, принятый для передачи данных по сети (всегда big-endian).

### HTTP

[HTTP (HyperText Transfer Protocol)](https://habr.com/ru/companies/avito/articles/710660/)  — протокол передачи гипертекста. Это набор правил, по которым данные в интернете передаются между разными источниками, обычно между компьютерами и серверами. Весь современный веб построен на протоколе HTTP. Каждый сайт использует его для общения клиента с сервером.
Особенности:
- Главная особенность HTTP — представление всех данных в виде простого текста
- HTTP основан на TCP. Это протокол прикладного уровня, который использует TCP для надёжной передачи данных между клиентом и сервером
- На данный момент существует четыре версии HTTP и все они до сих пор используются
- Протокол не сохраняет состояние между запросами. Каждый запрос от клиента для сервера — отдельная транзакция. Когда поступают два соседних запроса, сервер не понимает, от одного и того же клиента они поступили, или от разных

**HTTPS** (HTTP Secure) — это надстройка над протоколом HTTP, которая поддерживает шифрование посредством криптографических протоколов SSL и TLS. Они шифруют отправляемые данные на клиенте и дешифруют их на сервере. Это защищает данные от чтения злоумышленниками, даже если им удастся их перехватить. HTTPS -> TLS -> HTTP -> TCP

#### Версии протокола
1. *HTTP/0.9*
	- Предназначался исключительно для загрузки HTML страниц и поддерживал всего одну команду (GET)
	- Пример: `GET /http-spec.html`
2. *HTTP/1.0*
	- В запросе теперь надо было указывать версию протокола. Так сервер мог понимать, как обрабатывать полученные данные
	- В ответе от сервера появился статус завершения обработки запроса
	- К запросу и ответу добавился новый блок с заголовками
	- Новые методы:
		- `HEAD` запрашивает ресурс так же, как и метод GET, но без тела ответа. Так можно получить только заголовки, без самого ресурса
		- `POST` добавляет сущность к определённому ресурсу. Часто вызывает изменение состояния или побочные эффекты на сервере. Например, так можно отправить запрос на добавление нового поста в блог
3. *HTTP/1.1*
	- Устранены недостатки HTTP/1.0
	- Поддержка устойчивых соединений (Persistent Connections) для многократного использования одного TCP-соединения
	- Новые методы: `OPTIONS`, `TRACE`, `DELETE`
	- Поддержка Chunked Transfer Encoding для передачи больших объемов данных
	- Кэширование, обработка ошибок и управления соединениями стали более эффективными
	- Указание виртуального хоста через заголовок `Host` стало обязательным
4. *HTTP/2*
	- Переключение на бинарный формат вместо текстового, что улучшило производительность
	- Поддержка мультиплексирования: одновременная передача нескольких запросов и ответов по одному TCP-соединению
	- Использование сжатия заголовков (HPACK), что уменьшает накладные расходы
	- Улучшенная поддержка потоков данных и приоритизация запросов
	- Базируется на протоколе SPDY, разработанном Google
5. *HTTP/3*
	- Основан на протоколе QUIC, использующем UDP вместо TCP
	- Более быстрая установка соединения (нет "трёхкратного рукопожатия" TCP)
	- Лучшая устойчивость к потере пакетов благодаря независимым потокам данных
	- Мультиплексирование запросов и ответов без блокировок (как в HTTP/2, но на UDP)
	- Повышенная безопасность: все соединения шифруются (аналогично TLS)

##### Основные методы запросов
1. `GET` - Запрос данных с сервера
2. `HEAD` - Получение метаданных ресурса без самого ресурса (тела)
3. `POST` - Отправка данных на сервер для создания или обработки информации
4. `PUT` - Добавление нового ресурса (чтобы он был доступен по url)
5. `DELETE` - Удаление ресурса
6. `PATCH` - Частичное обновление ресурса
7. `OPTIONS` - Получение информации о доступных методах HTTP для ресурса
8. `CONNECT` - Устанавливает туннель для передачи данных
9. `TRACE` - Возвращает запрос, как его видит сервер

#### Структура HTTP-запроса (отправляется клиентом)
- *Стартовая строка*: метод, URL (или путь к ресурсу), версия HTTP
- *Блок заголовков*. Заголовки — это пары (ключ: значение), каждая из которых записывается с новой строки. Значение заголовка может содержать несколько параметров, разделённых точкой с запятой. Заголовки передают дополнительные данные и настройки от клиента к серверу и обратно
- *Тело запроса*. Текст сообщения — данные, которые передаются (например, HTML страницы или файлы, отправляемые на сервер). Важно, что между блоком заголовков и телом запроса должна быть пустая строка. Тело запроса не обязательно (например в методах GET и HEAD оно не передаётся, хотя и могут передаваться). Узнать длину тела можно из заголовка Content-Length, по механизму Transfer-Encoding: chunked, по наличию 2-ух пустых строк или просто по закрытию TCP соединения

#### Структура HTTP-ответа (отправляется сервером)
- *Стартовая строка*: версия протокола и статус ответа (например 200 OK)
- *Блок заголовков*: заголовки ответа
- *Тело ответа*: так же как тело запроса (может содержать например просто OK)

##### Статусы ответов
Это трёхзначные числовые коды с небольшими текстовыми обозначениями. Их можно увидеть в терминале или браузере. Сами коды делятся на 5 классов:
- *Информационные ответы*: 100–199
- *Успешные ответы*: 200–299
- *Редиректы*: 300–399
- *Клиентские ошибки*: 400–499
- *Серверные ошибки*: 500–599

#### URL
**URL** (Uniform Resource Locator) — это унифицированный указатель ресурса, используемый для обозначения адреса ресурса в интернете. Он представляет собой строку, которая указывает, как и где можно получить доступ к ресурсу (например, веб-странице, файлу, изображению и т.д.).
Общая структура URL: `<scheme>://<userinfo>@<host>:<port>/<path>?<query>#<fragment>`
Пример: `https://www.example.com:443/path/to/page?user=123#section`

##### Компоненты URL
1. *Схема (scheme)*:
    - Указывает протокол доступа к ресурсу (формат записи после двоеточия)
    - Примеры: `http`, `https`, `ftp`, `file`, `mailto`
    - Завершается двоеточием (`:`)
    - Пример: `https://`
2. *Имя пользователя и пароль (userinfo)* (опционально):
    - Предоставляет информацию для аутентификации
    - Формат: `<username>:<password>`
    - Следует перед хостом и разделяется символом `@`
    - Пример: `user:password@`
3. *Хост (host)*:
    - Указывает адрес сервера или устройства, где расположен ресурс
    - Это может быть доменное имя (`example.com`), IP-адрес (`192.168.0.1`) или даже `localhost`
    - Пример: `www.example.com`
4. *Порт (port)* (опционально):
    - Указывает номер порта для подключения (по умолчанию зависит от схемы: `80` для HTTP, `443` для HTTPS)
    - Разделяется двоеточием (`:`) после хоста
    - Пример: `:8080`
5. *Путь (path)*:
    - Указывает местоположение ресурса на сервере
    - Формат: `/`-разделённые сегменты
    - Пример: `/path/to/resource`
6. *Запрос (query)* (опционально):
    - Содержит параметры запроса в виде пар ключ-значение
    - Начинается с `?` и разделяет параметры символом `&`
    - Пример: `?id=123&sort=asc`
7. *Фрагмент (fragment)* (опционально):
    - Указывает конкретную часть ресурса (например, якорь на странице)
    - Особенность: в отличае от других секций url, эта обрабатывается на клиенте, а не на сервере (например клиент отображает только заданный параграф) 
    - Может использоваться как угодно (например javascript на странице может подгружать ресурсы, указанные в фрагменте)
    - Начинается с `#`
    - Пример: `#section1`

### Прокси

**Прокси-сервер** — это промежуточный сервер (комплекс программ) в компьютерных сетях, выполняющий роль посредника между пользователем и целевым сервером.

#### Сравнение прокси и VPN:
- Прокси: Работает на уровне отдельных приложений или сетевых соединений, может скрывать ваш IP-адрес, но, как правило, не шифрует трафик.
- VPN: Создает зашифрованный туннель между вашим устройством и VPN-сервером, скрывая ваш IP и защищая все передаваемые данные.

#### Применение прокси-серверов:
- Обход географических ограничений.
- Анонимизация интернет-соединений.
- Кэширование данных для ускорения доступа.
- Фильтрация контента на уровне корпоративных сетей.
- Защита серверов от DDoS-атак.

### Основные виды прокси-серверов

#### HTTP-прокси 
- Протоколы: HTTP, HTTPS
- Уровень: Приложений (уровень 7 модели OSI)  
- Описание:  
	- HTTP-прокси работают на уровне приложений и предназначены для обработки веб-трафика. Они поддерживают только протоколы HTTP и HTTPS, что делает их оптимальными для веб-браузеров и других веб-приложений. Запросы через HTTP-прокси передаются с помощью стандартного HTTP или HTTPS-запроса. Эти прокси часто используют для кэширования веб-страниц и сокращения задержек доступа к популярным веб-ресурсам.
- Отличия:
    - Поддерживает только HTTP и HTTPS.
    - Можно кэшировать страницы для ускорения доступа.
    - Может изменять запросы и ответы (например, для блокировки рекламы или фильтрации контента).
    - Используется для обхода блокировок веб-сайтов и анонимизации веб-трафика.

#### SOCKS-прокси
- Протоколы: TCP, UDP
- Уровень: Сессий (уровень 5 модели OSI)
- Описание: 
	- SOCKS-прокси работает на более низком уровне, чем HTTP-прокси, и может обрабатывать не только HTTP-трафик, но и любой другой тип данных, такой как FTP, POP3, SMTP и даже трафик игр или P2P-приложений. SOCKS-прокси бывает двух версий: SOCKS4 и SOCKS5. SOCKS5 поддерживает шифрование, аутентификацию и работу с UDP-трафиком.
- Отличия:
    - Поддерживает любые протоколы (TCP и UDP).
    - Может использоваться для игр, стриминговых сервисов и P2P.
    - SOCKS5 поддерживает аутентификацию и IPv6.
    - Не кэширует данные и не изменяет трафик.

#### Транспарентный (прозрачный) прокси
- Протоколы: HTTP, HTTPS (и другие)
- Описание:
	- Прозрачный прокси перехватывает трафик между клиентом и сервером без необходимости настраивать клиент. Внешне такой прокси не виден для пользователя, так как весь трафик автоматически проходит через него. Эти прокси часто используют провайдеры или корпоративные сети для фильтрации трафика, блокировки сайтов, мониторинга активности пользователей и кэширования данных.
- Отличия:
    - Не требует настройки со стороны клиента.
    - Может перехватывать и фильтровать трафик без ведома пользователя.
    - Часто используется для корпоративных политик контроля и фильтрации трафика.

#### Анонимные прокси
- Описание:
	- Анонимные прокси скрывают реальный IP-адрес пользователя и заменяют его на собственный IP. Это делает пользователя анонимным при посещении веб-ресурсов, что затрудняет отслеживание его действий в интернете.
- Отличия:
    - Скрывает реальный IP пользователя.
    - Не передает информацию об IP пользователя целевым сайтам.
    - Подходит для защиты конфиденциальности.

#### Элитные прокси
- Описание:
	- Элитные прокси (иногда называемые высокоанонимными) предлагают максимальный уровень анонимности. В отличие от обычных анонимных прокси, они не передают целевому серверу никаких заголовков, которые могли бы указывать на использование прокси. Они полностью скрывают факт использования прокси.
- Отличия:
    - Максимальная анонимность.
    - Целевые серверы не могут определить, что вы используете прокси.

#### Реверс-прокси
- Протоколы: HTTP, HTTPS (и другие)
- Описание:
	- Реверс-прокси работает с другой стороны соединения — он действует как посредник для серверов. Он принимает запросы от клиентов и перенаправляет их на внутренние серверы. Реверс-прокси используется для балансировки нагрузки, распределения трафика между несколькими серверами, защиты серверов от DDoS-атак и ускорения доступа к данным (через кэширование).
- Отличия:
    - Работает от имени сервера, а не клиента.
    - Используется для балансировки нагрузки, безопасности и кэширования.
    - Может скрывать внутренние серверы от внешнего мира.

#### FTP-прокси
- Протоколы: FTP
- Описание:
	- FTP-прокси используется для работы с FTP-протоколом и передачи файлов. Он позволяет клиенту подключаться к FTP-серверам через прокси, что полезно для контроля доступа и анонимизации при работе с FTP.
- Отличия:
    - Специализируется на передаче файлов по протоколу FTP.

#### CGI-прокси
- Протоколы: HTTP
- Описание:
	- CGI-прокси — это веб-страница, которая позволяет пользователям заходить на другие сайты через браузер, используя интерфейс CGI (Common Gateway Interface). Такие прокси не требуют настройки на клиенте и часто используются для обхода блокировок или анонимизации трафика.
- Отличия:
    - Прокси реализован как веб-страница.
    - Позволяет пользователю получить доступ к сайтам через интерфейс браузера.

### Фаерволы

**Файрволы (брандмауэры)** — это сетевые устройства или программные системы, предназначенные для контроля и фильтрации входящего и исходящего сетевого трафика на основе определённых правил безопасности. Они используются для защиты сети от несанкционированного доступа, предотвращения атак, а также для ограничения доступа к определённым ресурсам.

Основные функции и задачи файрволов:
1. **Защита от несанкционированного доступа**: Файрволы фильтруют трафик и блокируют подозрительные или нежелательные соединения, что помогает предотвратить взломы и проникновения в сеть.
2. **Фильтрация трафика**: Файрволы могут блокировать или разрешать трафик на основе различных параметров, таких как IP-адреса, порты, протоколы или типы приложений.
3. **Контроль доступа**: Они могут использоваться для ограничения доступа к определённым веб-сайтам, службам или приложениям на основе политик организации или государства.
4. **Защита от атак**: Файрволы помогают предотвращать различные типы атак, такие как **DDoS-атаки**, **сканирование портов**, **вредоносные** и **ботнет-сети**.    
5. **Мониторинг и ведение журналов**: Они предоставляют средства для мониторинга сетевого трафика и журналирования событий, что полезно для анализа и обнаружения потенциальных угроз.

### SOCKS-прокси
#### Особенности
- Работает на уровне сессий в модели OSI, благодаря чему может передавать трафик различных протоколов, таких как HTTP, HTTPS, FTP, и даже UDP-трафик
- Просто передает сетевые пакеты между клиентом и сервером, не изменяя их содержимого. Поэтому, в отличие от HTTP-прокси, он может работать с любыми типами трафика (веб, игры, торрент-клиенты и т.д.)
- Работает прозрачно
- Между клиентом и SOCKS-сервером и между SOCKS-сервером и сервером назначения могут использоваться разные протоколы (UDP или TCP)
- Версии протокола (SOCKS4 и SOCKS5) несовместимы
- Подробно про SOCKS с описанием содержимого пакетов: [wiki](https://en.wikipedia.org/wiki/SOCKS)

#### Версии SOCKS:
1. **SOCKS4**:
    - Поддерживает только TCP-трафик
    - Работает только с IPv4
2. **SOCKS4a**:
	- То же самое что SOCKS4, но с поддержкой разрешения доменных имён
3. **SOCKS5**:
    - Поддерживает как TCP, так и UDP-трафик
    - Поддерживает аутентификацию (можно настроить проверку пользователей)
    - Работает как с IPv4, так и с IPv6
    - Может использоваться для обхода блокировок, так как передает любые данные, включая те, которые не ограничены HTTP

#### Общий алгоритм работы SOCKS-прокси
1. **Установка соединения с прокси**:
    - Клиент (например, браузер или приложение) подключается к прокси, обычно указывая его IP-адрес и порт (обычно порт 1080)
    - После соединения клиент и прокси обменятся данными для установления туннеля и определения, какой тип соединения (TCP или UDP) будет использоваться, а также настроек аутентификации (если включена)
2. **Аутентификация (опционально)**:
    - В случае SOCKS5 поддерживается опциональная аутентификация (например, по паролю). Клиент отправляет запрос авторизации с указанием имени пользователя и пароля, и SOCKS-сервер проверяет их перед разрешением дальнейшего соединения
3. **Отправка запроса на соединение с целевым сервером**:
    - SOCKS-клиент формирует запрос на соединение, в котором указывает:
        - *Тип запроса*: подключение, привязка или отправка данных через UDP (в случае SOCKS5)
        - *Адрес назначения*: IP-адрес или доменное имя конечного сервера, с которым хочет связаться клиент
        - *Порт назначения*: Порт на конечном сервере, к которому хочет подключиться клиент
4. **Обработка запроса на подключение**:
    - SOCKS-сервер принимает запрос от клиента, устанавливает исходящее соединение с указанным сервером назначения и, при успешном подключении, возвращает клиенту ответ о том, что соединение установлено
    - В случае ошибки (например, если сервер назначения недоступен или отклоняет соединение), SOCKS-сервер сообщает клиенту об отказе, отправив код ошибки
5. **Передача данных через туннель**:    
    - Как только соединение установлено, весь трафик, идущий от клиента, перенаправляется через SOCKS-сервер к серверу назначения, при этом клиент как бы “прозрачно” отправляет данные, не связываясь напрямую с конечным сервером
    - SOCKS-сервер передаёт данные как есть и передаёт ответные данные от целевого сервера обратно клиенту

#### Алгоритм SOCKS4
1. Клиент устанавливает прямое TCP соединение с прокси по его ip и порту
2. Клиент отправляет на прокси пакет "First packet to server". В этом пакете указывается одна из команд:
	- `establish a [TCP/IP] stream connection` - запрос на установку соединения с целевым сервером по его ip и порту
	- `establish a TCP/IP port binding` -  запрос на установку обратного подключения. Используется в сценариях, когда сервер назначения инициирует подключение обратно к клиенту через прокси
3. В зависимости от команды, указанной в первом пакете от клиента, сервер делает следующее:
	- Установливает TCP соединение с сервером назначения и отправляет "Response packet from server" в котором указывается статус (всё ок или ошибка)
	- Открывает порт для входящих подключений и также отправляет "Response packet from server" в котором дополнительно указывается открытый порт. Далее целевой сервер инициирует соединение с прокси-сервером на порт биндинга. Прокси-сервер связывает это входящее соединение с клиентом
4. Прокси перенаправляет данные между клиентом и сервером

### Структура пакета IPv4

1. **Заголовок (Header)**  
- Заголовок состоит из 20 байт (минимум) или больше, если используются дополнительные опции

| Поле                    | Размер (бит)       | Описание                                                                           |
| ----------------------- | ------------------ | ---------------------------------------------------------------------------------- |
| *Version*               | 4                  | Версия IP-протокола (для IPv4 значение равно 4)                                    |
| *IHL (Header Length)*   | 4                  | Длина заголовка в 32-битных словах (минимум 5, то есть 20 байт)                    |
| *Type of Service (ToS)* | 8                  | Поле, указывающее приоритет или тип трафика (например, low delay, high throughput) |
| *Total Length*          | 16                 | Полная длина пакета (заголовок + данные) в байтах (максимум 65 535)                |
| *Identification*        | 16                 | Уникальный идентификатор для фрагментации пакетов                                  |
| *Flags*                 | 3                  | Управляющие флаги для фрагментации:                                                |
|                         |                    | - DF (Don't Fragment): запрет фрагментации                                         |
|                         |                    | - MF (More Fragments): указание, что есть последующие фрагменты                    |
| *Fragment Offset*       | 13                 | Смещение фрагмента относительно начала исходного пакета (используется для сборки)  |
| *Time to Live (TTL)*    | 8                  | Время жизни пакета (в секундах или в количестве хопов, уменьшается на каждом узле) |
| *Protocol*              | 8                  | Указывает протокол верхнего уровня (например, TCP — 6, UDP — 17)                   |
| *Header Checksum*       | 16                 | Контрольная сумма заголовка для проверки ошибок                                    |
| *Source Address*        | 32                 | IP-адрес отправителя                                                               |
| *Destination Address*   | 32                 | IP-адрес получателя                                                                |
| *Options (опционально)* | (переменная длина) | Дополнительные параметры (например, для маршрутизации или отладки)                 |
2. **Данные (Payload)**
- Полезная нагрузка пакета. Это может быть фрагмент данных протоколов верхнего уровня, таких как TCP, UDP или ICMP

#### Особенности
1. *Фрагментация*: Если пакет больше, чем поддерживается MTU (максимальный размер блока данных), он фрагментируется, и части передаются отдельно
2. *Контрольная сумма:* Рассчитывается только для заголовка. Полезная нагрузка не проверяется
3. *TTL*: Это защита от зацикливания пакетов в сети. Если TTL достигает нуля, пакет отбрасывается
4. *Опции*: Используются редко. Примеры — запись маршрута, метки времени и т. д.

### Структура пакета IPv6

1. **Заголовок (Header)**  
- Заголовок IPv6 фиксированного размера — 40 байт. Он меньше и проще, чем заголовок IPv4 (минимум 20 байт + опции)

| Поле                  | Размер (бит) | Описание                                                                                       |
| --------------------- | ------------ | ---------------------------------------------------------------------------------------------- |
| *Version*             | 4            | Версия протокола (для IPv6 значение равно 6)                                                   |
| *Traffic Class*       | 8            | Класс обслуживания, указывает приоритет или тип трафика (аналог ToS в IPv4)                    |
| *Flow Label*          | 20           | Метка потока, используется для идентификации пакетов, принадлежащих одному потоку данных       |
| *Payload Length*      | 16           | Длина полезной нагрузки (включая заголовки верхнего уровня). Максимум: 65 535 байт             |
| *Next Header*         | 8            | Указывает тип следующего заголовка (аналог Protocol в IPv4), например, TCP, UDP или расширение |
| *Hop Limit*           | 8            | Время жизни пакета, уменьшается на каждом маршрутизаторе (аналог TTL в IPv4)                   |
| *Source Address*      | 128          | IP-адрес отправителя (128 бит)                                                                 |
| *Destination Address* | 128          | IP-адрес получателя (128 бит)                                                                  |

2. **Расширенные заголовки (Extension Headers)**  
- В отличие от IPv4, где опции включены в основной заголовок, в IPv6 они вынесены в цепочку расширенных заголовков. Каждый расширенный заголовок указывается в поле Next Header предыдущего заголовка
- Основные типы расширенных заголовков:
    - *Hop-by-Hop Options*: Для обработки каждым маршрутизатором (например, для меток времени)
    - *Routing*: Указывает промежуточные маршруты
    - *Fragmentation*: Используется для фрагментации пакетов
    - *Authentication Header (AH)*: Для проверки подлинности и целостности
    - *Encapsulating Security Payload (ESP)*: Для шифрования данных
    - *Destination Options*: Опции, которые обрабатываются только конечным узлом

3. **Полезная нагрузка (Payload)**  
- Это данные верхнего уровня (например, TCP или UDP-пакеты). Полезная нагрузка включена после основного и расширенных заголовков

### SSH

**SSH (Secure Shell)** — это сетевой протокол и набор инструментов, которые позволяют безопасно подключаться к удаленным серверам и управлять ими. SSH обеспечивает шифрование данных, аутентификацию и защиту от перехвата информации. Давайте разберем основные аспекты SSH

#### Основные возможности SSH
1. *Удаленное управление сервером*:
    - SSH позволяет подключаться к удаленному серверу и выполнять команды в терминале, как если бы вы работали на локальной машине
2. *Безопасная передача данных*:
    - Весь трафик между клиентом и сервером шифруется, что защищает данные от перехвата
3. *Аутентификация*:
    - SSH поддерживает несколько методов аутентификации: по паролю, с использованием SSH-ключей (более безопасный способ) и многофакторную аутентификацию
4. *Проброска портов (туннелирование)*:
    - SSH позволяет перенаправлять сетевой трафик между локальной машиной и удаленным сервером, что полезно для доступа к защищенным сервисам
5. *Передача файлов*:
    - С помощью утилит, таких как `scp` или `sftp`, можно безопасно передавать файлы между компьютерами

#### Как работает SSH?
1. *Установление соединения*:
    - Клиент SSH подключается к SSH-серверу, обычно на порту 22 (хотя порт можно изменить)
2. *Обмен ключами*:
    - Клиент и сервер обмениваются криптографическими ключами для установления безопасного соединения
3. *Аутентификация*:
    - Сервер проверяет подлинность клиента (например, запрашивает пароль или проверяет SSH-ключ)
4. *Шифрование данных*:
    - После успешной аутентификации все данные передаются в зашифрованном виде

#### Основные команды SSH
1. *Подключение к серверу*:
	- `ssh пользователь@адрес_сервера`
2. *Подключение с указанием порта*:   
	- Если SSH-сервер использует нестандартный порт (не 22):
	- `ssh -p порт пользователь@адрес_сервера`
3. *Использование SSH-ключа*:  
	- Если вы настроили аутентификацию по SSH-ключу:
	- `ssh -i /путь/к/ключу пользователь@адрес_сервера`
4. *Проброска портов (туннелирование)*:
	- Локальный проброс: 
	- `ssh -L локальный_порт:удаленный_адрес:удаленный_порт пользователь@адрес_сервера`
	- Удаленный проброс: 
	- `ssh -R удаленный_порт:локальный_адрес:локальный_порт пользователь@адрес_сервера`
5. *Копирование файлов*:
	- Использование scp:
	- `scp файл пользователь@адрес_сервера:/путь/на/сервере`
	- Использование `sftp`:
	- `sftp пользователь@адрес_сервера`

#### SSH-ключи
SSH-ключи — это более безопасный способ аутентификации, чем пароли. Они состоят из двух частей:
1. **Приватный ключ** (хранится на вашем компьютере)
2. **Публичный ключ** (размещается на удаленном сервере)

##### Как создать SSH-ключ:
- `ssh-keygen -t rsa -b 4096 -C "ваш_email@example.com"`
- Ключи сохраняются в `~/.ssh/id_rsa` (приватный) и `~/.ssh/id_rsa.pub` (публичный)

##### Как добавить публичный ключ на сервер:
- `ssh-copy-id пользователь@адрес_сервера`
- Или вручную скопируйте содержимое `~/.ssh/id_rsa.pub` в файл `~/.ssh/authorized_keys` на сервере

#### Безопасность SSH
1. *Используйте SSH-ключи вместо паролей*:
    - Пароли могут быть взломаны методом перебора, а SSH-ключи — нет
2. *Измените порт SSH*:
    - По умолчанию SSH использует порт 22. Измените его на нестандартный, чтобы уменьшить количество атак
3. *Отключите вход по паролю*:
    - Если вы используете SSH-ключи, отключите аутентификацию по паролю в конфигурации SSH-сервера
4. *Используйте Fail2Ban*:
    - Эта утилита блокирует IP-адреса после нескольких неудачных попыток входа

#### Проброска портов
"Пробросить порт через SSH" (или SSH-туннелирование) — это техника, которая позволяет перенаправлять сетевой трафик между локальной машиной и удаленным сервером через зашифрованное SSH-соединение. Это может быть полезно для безопасного доступа к сервисам, которые работают на удаленном сервере, или для обхода ограничений сети

##### Как это работает:
Когда вы пробрасываете порт через SSH, вы создаете туннель между вашим локальным компьютером и удаленным сервером. Трафик, который вы отправляете на определенный порт локальной машины, перенаправляется через SSH-соединение на указанный порт удаленного сервера (или наоборот)

##### Пример:
Допустим, на удаленном сервере `remote-server.com` работает веб-сервер на порту `80`, но этот порт недоступен напрямую из вашей сети. Вы можете пробросить порт через SSH, чтобы получить доступ к этому веб-серверу через локальный порт на вашем компьютере

##### Команда для проброса порта:
`ssh -L [локальный_порт]:[удаленный_адрес]:[удаленный_порт] [пользователь]@[сервер]`
- `-L` — указывает, что мы пробрасываем порт локально (от вашего компьютера к удаленному серверу)
- `локальный_порт` — порт на вашем компьютере, через который будет доступен сервис
- `удаленный_адрес` — адрес сервера или службы, к которой вы хотите получить доступ (может быть `localhost`, если служба находится на удаленном сервере)
- `удаленный_порт` — порт, на котором работает служба на удаленном сервере
- `пользователь@сервер` — ваши учетные данные и адрес удаленного сервера
    
##### Типы проброса портов:
1. **Локальный проброс (-L)**:
    - Трафик с вашего компьютера перенаправляется на удаленный сервер
    - Пример: `ssh -L 8080:localhost:80 user@remote-server.com`
2. **Удаленный проброс (-R)**:
    - Трафик с удаленного сервера перенаправляется на ваш компьютер
    - Пример: `ssh -R 8080:localhost:80 user@remote-server.com`
3. **Динамический проброс (-D)**:
    - Создает SOCKS-прокси, который можно использовать для перенаправления трафика через SSH-туннель
    - Пример: `ssh -D 1080 user@remote-server.com`

