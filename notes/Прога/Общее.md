
### Принципы ООП

1. **Инкапсуляция**
	- Суть: Сокрытие внутренней реализации объекта и предоставление строго определённого интерфейса для взаимодействия с ним
	- Зачем: Чтобы защитить данные объекта от несанкционированного доступа и упростить использование объекта, скрыв сложность его внутренней логики
2. **Наследование**
	- Суть: Возможность создания новых классов на основе существующих, с целью повторного использования кода и создания иерархии классов
	- Зачем: Чтобы избежать дублирования кода и организовать логическую структуру программы
3. **Полиморфизм**
	- Суть: Возможность объектов с одинаковым интерфейсом иметь разную реализацию
	- Зачем: Чтобы обеспечить гибкость и расширяемость программы, позволяя работать с разными типами объектов через единый интерфейс
4. **Абстракция**
	- Суть: Выделение основных характеристик объекта, игнорируя несущественные детали
	- Зачем: Чтобы упростить работу с сложными системами, фокусируясь на ключевых аспектах

### SOLID

1. **Single Responsibility Principle (Принцип единственной ответственности)**
	- Суть: Каждый класс должен иметь только одну причину для изменения, то есть выполнять только одну задачу
	- Зачем: Чтобы упростить поддержку и тестирование кода, а также избежать сложных зависимостей
	- Пример: Класс User должен отвечать только за данные пользователя, а не за логику отправки email
2. **Open/Closed Principle (Принцип открытости/закрытости)**
	- Суть: Программные сущности (классы, модули, функции) должны быть открыты для расширения, но закрыты для модификации
	- Зачем: Чтобы можно было добавлять новую функциональность, не изменяя существующий код
	- Пример: Использование интерфейсов или абстрактных классов для добавления новых типов без изменения старого кода
3. **Liskov Substitution Principle (Принцип подстановки Барбары Лисков)**
	- Суть: Объекты в программе должны быть заменяемы экземплярами их подтипов без изменения правильности работы программы
	- Зачем: Чтобы обеспечить корректную работу наследования и полиморфизма
	- Пример: Если у вас есть класс Bird, то его подкласс Penguin не должен нарушать ожидаемое поведение (например, пингвины не летают, поэтому метод fly() не должен быть в этом классе)
4. **Interface Segregation Principle (Принцип разделения интерфейса)**
	- Суть: Клиенты не должны зависеть от интерфейсов, которые они не используют. Лучше создавать узкоспециализированные интерфейсы, чем один общий
	- Зачем: Чтобы избежать "раздутых" интерфейсов и ненужных зависимостей
	- Пример: Вместо одного интерфейса Printer, который включает методы print(), scan() и fax(), лучше создать отдельные интерфейсы для каждой функции
5. **Dependency Inversion Principle (Принцип инверсии зависимостей)**
	- Суть: Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций
	- Зачем: Чтобы уменьшить связанность между компонентами и упростить тестирование и замену модулей
	- Пример: Вместо того чтобы класс UserService напрямую зависел от класса MySQLDatabase, он должен зависеть от абстракции (интерфейса) Database

### Сравнение стека и кучи

#### Разница в скорости выделения и освобождения памяти
- Стек работает по принципу LIFO, поэтому выделение памяти для новых объектов — это просто смещение указателя стека, что очень быстро (`O(1)`)
- Куча использует более сложные алгоритмы управления памятью, такие как разбиение памяти на блоки и управление фрагментацией, что делает выделение и освобождение намного медленнее (`O(log n)` в худшем случае, но в среднем быстрее благодаря оптимизированным аллокаторам)

#### Разница в скорости доступа к памяти
- Доступ к памяти на стеке быстрее, потому что:
	- Данные находятся рядом друг с другом (высокая локальность данных)
	- Доступ идёт через регистры процессора, а стек часто находится в кэше процессора
	- Нет указателей: обращение идёт напрямую к переменной
- Доступ к куче медленнее, потому что:
	- Данные могут быть разбросаны по памяти из-за фрагментации
	- Для доступа к данным нужен указатель, что добавляет дополнительное косвенное разыменование
	- Кэш-промахи: из-за случайного расположения данных в памяти кэш-память может не использоваться эффективно

#### Насколько велика разница
- Разница в скорости выделения/освобождения может быть в десятки или сотни раз (стек быстрее)
- Разница в доступе к данным на стеке и куче обычно в 2-5 раз (но сильно зависит от доступа к кэшу)

#### Вывод
- Если можно — используй стек, так как он быстрее и безопаснее (нет утечек памяти)
- Используй кучу, только если нужно:
	- Хранить очень большие объекты, которые не помещаются на стеке
	- Создавать объекты с неопределённым временем жизни (например, объект должен существовать после выхода из функции)
	- Делать динамические структуры данных (например, `std::vector`, `std::map`)

