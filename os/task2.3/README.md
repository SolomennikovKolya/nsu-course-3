
### Односвязный список

Реализуйте односвязный список, хранящий строки длиной менее 100 символов, у которого с каждым элементом связан отдельный примитив синхронизации (за основу можно взять реализацию списка, на котором построен очередь queue_t). Объявление такого списка может выглядеть, например, так:

```c
typedef struct _Node {
	char value[100];
	struct _Node* next;
	pthread_mutex_t sync;
} Node;

typedef struct _Storage {
	Node *first;
} Storage;
```

Первый поток пробегает по всему хранилищу и ищет количество пар строк, идущих по возрастанию длины. Как только достигнут конец списка, поток инкрементирует глобальную переменную, в которой хранится, количество выполненных им итераций и сразу начинает новый поиск.

Второй поток пробегает по всему хранилищу и ищет количество пар строк, идущих по убыванию длины. Как только достигнут конец списка, поток инкрементирует глобальную переменную, в которой хранится количество выполненных им итераций и сразу начинает новый поиск.

Третий поток пробегает по всему хранилищу и ищет количество пар строк, имеющих одинаковую длину. Как только достигнут конец списка, поток инкрементирует глобальную переменную, в которой хранится количество выполненных им итераций и сразу начинает новый поиск.

Запускает 3 потока, которые в непрерывном бесконечном цикле случайным образом проверяют- требуется ли переставлять соседние элементы списка (не значения) и выполняют перестановку. Каждая успешная попытка перестановки фиксируется в соответствующей глобальной переменной-счетчике.

Используйте для синхронизации доступа к элементам списка спинлоки, мутексы и блокировки чтения-записи. Понаблюдайте как изменяются (и изменяются ли) значения переменных счетчиков и объясните результат. Проверьте для списков длины 100, 1000, 10000, 100000 При реализации обратите внимание на следующие пункты:
- продумайте ваше решение, чтобы избежать ошибок соревнования.
- необходимо блокировать все записи с данными которых производится работа.
- при перестановке записей списка, необходимо блокировать три записи.
- чтобы избежать мертвых блокировок, примитивы записей, более близких к началу списка, всегда захватывайте раньше.

### Результаты
- list-spinlock
	- n = 100:    12110           12073           12198           52406
	- n = 1000:   1924            1925            1924            6527
	- n = 10000:  208             208             207             694
	- n = 10000:  24              24              23              72
- list-mutex
	- n = 100:    7409            7868            7298            29999
	- n = 1000:   1476            1456            1458            6429
	- n = 10000:  123             123             118             731
	- n = 10000:  10              12              12              77
- list-spinlock
	- n = 100:    3786            3751            3749            10628
	- n = 1000:   1779            1770            1770            5301
	- n = 10000:  196             195             197             597
	- n = 10000:  19              18              18              53
